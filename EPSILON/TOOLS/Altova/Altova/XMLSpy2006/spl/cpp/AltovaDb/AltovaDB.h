////////////////////////////////////////////////////////////////////////
//
// AltovaDB.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVADB_H_INCLUDED
#define ALTOVADB_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000


#ifndef _USRDLL
	#define ALTOVADB_DECLSPECIFIER
#else
	#ifdef ALTOVADB_EXPORTS
		#define ALTOVADB_DECLSPECIFIER __declspec(dllexport)
		#define ALTOVADB_EXPIMP_TEMPLATE
	#else
		#define ALTOVADB_DECLSPECIFIER __declspec(dllimport)
		#define ALTOVADB_EXPIMP_TEMPLATE extern
	#endif

	#ifndef _MFC_VER
		#pragma warning(disable: 4660)
		#pragma warning(disable: 4231)
		#pragma warning(disable: 4251)
	#endif
#endif

namespace altova {


////////////////////////////////////////////////////////////////////////
// Commands
////////////////////////////////////////////////////////////////////////

class ALTOVADB_DECLSPECIFIER CFieldValue
{
public:
	CFieldValue(tstring sName = _T(""), _variant_t vValue = _variant_t(), bool bUseValueIndirect = false) 
		: m_sName(sName)
		, m_vValue(vValue)
		, m_bUseValueIndirect( bUseValueIndirect )
	{};
	CFieldValue(const CFieldValue& rOther)
		: m_sName( rOther.m_sName )
		, m_vValue(rOther.m_vValue)
		, m_bUseValueIndirect( rOther.m_bUseValueIndirect )
	{};

	tstring		GetName() const { return m_sName; }

	tstring		m_sName;
	_variant_t	m_vValue;
	bool		m_bUseValueIndirect;
};

typedef std::vector<CFieldValue>	TFieldValueList;
typedef TFieldValueList::iterator	TFieldValueListIt;


class ALTOVADB_DECLSPECIFIER CCommand
{
public:
	CCommand(tstring sStatement = _T(""), bool bAutoReadFieldsIntoBuffer = false );
	CCommand(const CCommand& rOther)
		: m_sStatement( rOther.m_sStatement )
		, m_bAutoReadFieldsIntoBuffer( rOther.m_bAutoReadFieldsIntoBuffer )
	{
		m_listParameters = rOther.m_listParameters;
	}

	tstring				GetStatement() const				{ return m_sStatement;	}
	void				SetStatement(tstring sSQL)			{ m_sStatement = sSQL; }
	bool				IsEmpty() const						{ return m_sStatement.empty(); }

	TFieldValueList&	GetParameters()						{ return m_listParameters; }
	void				AddParameter(_variant_t vValue, bool bUseValueIndirect = false);

	bool				IsAutoReadFieldsIntoBuffer()		{ return m_bAutoReadFieldsIntoBuffer; }
	void				SetAutoReadFieldsIntoBuffer( bool bAutoReadFieldsIntoBuffer = true );

protected:
	tstring				m_sStatement;
	TFieldValueList		m_listParameters;
	bool				m_bAutoReadFieldsIntoBuffer;
};



class ALTOVADB_DECLSPECIFIER CCommandList : public std::vector<CCommand>
{
public:
	CCommandList()	{};
	CCommandList(CCommand command);

	bool		IsEmpty()	{ return size() == 0; }
};

typedef CCommandList::iterator CCommandListIt;


////////////////////////////////////////////////////////////////////////
// Exceptions
////////////////////////////////////////////////////////////////////////

// --------------------------------------------------------------------------
// CAltovaDBException
//
// Base class for all DB-specific exceptions
// --------------------------------------------------------------------------

class ALTOVADB_DECLSPECIFIER CAltovaDBException : public CAltovaException
{
public: 
	CAltovaDBException( 
		const tstring&	sFailed,	
		const tstring&	sErrorMessage
	)
		: CAltovaException( CAltovaException::eDatabaseError, sFailed + _T(" \\n") + sErrorMessage )
		, m_sFailed( sFailed )
		, m_sErrorMessage( sErrorMessage )
	{
	};
	CAltovaDBException( const CAltovaDBException& rOther )
		: CAltovaException( CAltovaException::eDatabaseError, rOther.m_sFailed + _T(" \\n") + rOther.m_sErrorMessage )
		, m_sFailed( rOther.m_sFailed )
		, m_sErrorMessage( rOther.m_sErrorMessage )
	{
	};

	const tstring	GetFailedItem() const	{ return m_sFailed;	}
	const tstring	GetErrorMessage() const { return m_sErrorMessage; }
protected:
	const tstring	m_sFailed;
	const tstring	m_sErrorMessage;
};


// --------------------------------------------------------------------------
// CAltovaDBConnectionException
//
// Is thrown when a error occurs during DB-connect / DB-disconnect
// --------------------------------------------------------------------------

typedef enum
{
	k_AltovaDBConnectionError_Open,
	k_AltovaDBConnectionError_Init,
	k_AltovaDBConnectionError_Finalize,
	k_AltovaDBConnectionError_Close,
	// ---------
	k_AltovaDBConnectionError_Count,
	k_AltovaDBConnectionError_Unknown = -1
} EAltovaDBConnectionErrorKind;

class ALTOVADB_DECLSPECIFIER CAltovaDBConnectionException : public CAltovaDBException
{
public: 
	CAltovaDBConnectionException( 
		const EAltovaDBConnectionErrorKind	eKind, 
		const tstring&				sConnectionString, 
		const tstring&				sErrorMessage 
	)
		: CAltovaDBException( sConnectionString, sErrorMessage )
		, m_eKind( eKind )
	{
	};

	const EAltovaDBConnectionErrorKind	GetErrorKind() const		{ return m_eKind; }
	const tstring				GetConnectionString() const	{ return m_sFailed; }

protected:
	const EAltovaDBConnectionErrorKind	m_eKind;
};


// --------------------------------------------------------------------------
// CAltovaDBExecuteException
// --------------------------------------------------------------------------
typedef enum
{
	k_AltovaDBExecuteError_PrepareCommand,
	k_AltovaDBExecuteError_PrepareParams,
	k_AltovaDBExecuteError_Execute,
	k_AltovaDBExecuteError_GetAffected,
	k_AltovaDBExecuteError_GetColumn,
	k_AltovaDBExecuteError_SetColumn,
	k_AltovaDBExecuteError_ReadNextResult,
	// ----------
	k_AltovaDBExecuteError_Count,
	k_AltovaDBExecuteError_Unknown = -1
} EAltovaDBExecuteErrorKind;

class ALTOVADB_DECLSPECIFIER CAltovaDBExecuteException : public CAltovaDBException
{
public:
	CAltovaDBExecuteException(
		const EAltovaDBExecuteErrorKind	eKind,
		const tstring&				sSQLCmd, 
		const tstring&				sErrorMessage,
		const tstring&				sAdditionalInfo = tstring()
	)
		: CAltovaDBException( sSQLCmd + sAdditionalInfo, sErrorMessage )
		, m_eKind( eKind )
		, m_sCommand( sSQLCmd )
		, m_sAdditionalInfo( sAdditionalInfo )
	{
	};

	CAltovaDBExecuteException( const CAltovaDBExecuteException& rOther )
		: CAltovaDBException( rOther.GetFailedItem(), rOther.GetErrorMessage() )
		, m_eKind( rOther.m_eKind )
		, m_sCommand( rOther.m_sCommand )
		, m_sAdditionalInfo( rOther.m_sAdditionalInfo )
	{
	};

	const EAltovaDBExecuteErrorKind	GetErrorKind() const	{ return m_eKind; }
	const tstring&				GetSQLCommand() const	{ return m_sCommand; }

protected:
	const EAltovaDBExecuteErrorKind	m_eKind;
	const tstring				m_sCommand;
	const tstring				m_sAdditionalInfo;
};


// --------------------------------------------------------------------------
// CAltovaDBTransactionException
// --------------------------------------------------------------------------
typedef enum
{
	k_AltovaDBTransactionAction_Stop,
	k_AltovaDBTransactionAction_RollbackAll,
	// ----------
	k_AltovaDBTransactionAction_Count,
	k_AltovaDBTransactionAction_Unknown = -1
} EAltovaDBTransactionActionKind;

class ALTOVADB_DECLSPECIFIER CAltovaDBTransactionException : public CAltovaDBException
{
public: 
	CAltovaDBTransactionException( 
		const EAltovaDBTransactionActionKind	eActionKind,
		const tstring					sTransactionName,
		const CAltovaDBExecuteException&		rExecuteException
	)
		: CAltovaDBException( sTransactionName, rExecuteException.GetErrorMessage() )
		, m_eActionKind( eActionKind )
		, m_sTransactionName( sTransactionName )
		, m_ExecuteException( rExecuteException )
	{
	};

	const EAltovaDBTransactionActionKind	GetActionKind() const		{ return m_eActionKind;	}
	const tstring&					GetTransactionName() const	{ return m_sTransactionName; }
	const CAltovaDBExecuteException&		GetExecuteException() const	{ return m_ExecuteException; }

protected:
	const EAltovaDBTransactionActionKind	m_eActionKind;
	const tstring					m_sTransactionName;
	const CAltovaDBExecuteException		m_ExecuteException;
};


////////////////////////////////////////////////////////////////////////
// Database Objects
////////////////////////////////////////////////////////////////////////


class ALTOVADB_DECLSPECIFIER CDatabase
{
public:
	ADODB::_ConnectionPtr	GetConnection() { return m_spConnection; }

	// transaction handling
	void					SetRollbackTransaction( bool bRollback = true ) { m_bRollbackTransaction = bRollback; }
	void					BeginTransaction( LPCTSTR szName = 0 );
	void					CommitTransaction( LPCTSTR szName = 0 );
	void					RollbackTransaction( LPCTSTR szName = 0 );

protected:
	// construction & destruction
	CDatabase();
	CDatabase(const CDatabase& other);
	CDatabase(const tstring& sConnectionString);
	virtual ~CDatabase();

	// protected member functions
	virtual void			InternalBeginTransaction() = 0;
	virtual void			InternalCommitTransaction() = 0;
	virtual void			InternalRollbackTransaction() = 0;
	virtual void			InternalSetSavepoint( LPCTSTR szTransactionName ) = 0;
	virtual void			InternalRollbackToSavepoint( LPCTSTR szTransactionName ) = 0;

	// member varibles
	ADODB::_ConnectionPtr	m_spConnection;
	bool					m_bRollbackTransaction;
	long					m_nTransactionCounter;
};


class ALTOVADB_DECLSPECIFIER CRecordSet
{
public:
	CRecordSet&				Assign( const CRecordSet& rOther );
	CRecordSet&				operator=( const CRecordSet& rOther ) { return Assign( rOther ); }

	CDatabase&				GetDatabase()	{ return *m_pDatabase; }

	// command handling
	void					SetCommand(CCommandList cmdSQLList);
	CCommandList			GetCommand()	{ return m_CommandList; }
	long					Execute(CCommandList cmdList = CCommandList() );

	// recordset handling
	ADODB::_RecordsetPtr	GetRecordset() 	{ return *m_itActRecordset; }
	bool					HasNext();	// check if there is a next row in actual recordset (false when EOF or recordset is empty)
	void					MoveNext();	// move to the next row; values of columns are accessed via InternalGetValue()
	bool					NextRecordset(long& nRecordsAffected);	// in a multiple recordset query this moves to the next recordset; returns FALSE if there is none

	_variant_t				GetRowsToDelete()	{ return m_MapforceDelRows; }

	// interface
	virtual void			Prepare( bool bReadOnlyAccess ) = 0;
	virtual _variant_t		GetValueByName(const tstring& sColumn) = 0;
	virtual void			SetValueByName(const tstring& sColumn, const _variant_t& vValue ) = 0;

protected:
	CRecordSet();
	CRecordSet(const CRecordSet& other);
	CRecordSet(CDatabase& rDatabase, const CCommand& cmdQuery, const bool bReadAccess = true);
	virtual ~CRecordSet();

	void					CloseRecordsets();
	void					ReadFieldsIntoBuffer();

	_variant_t				InternalGetValue(const tstring& sName, const bool bReadFromBuffer = false );
	void					InternalSetValue(const tstring& sName, const _variant_t& vValue );

	// Member variables
	CDatabase*				m_pDatabase;
	bool					m_bReadAccess;
	CCommandList			m_CommandList;

	typedef std::vector<ADODB::_RecordsetPtr>	TADORecordSetPtrList;
	typedef TADORecordSetPtrList::iterator		TADORecordSetPtrListIt;

	TADORecordSetPtrList	m_Recordsets;
	TADORecordSetPtrListIt	m_itActRecordset;
	bool					m_bRecordsetOwner;
	bool					m_bRecordsetOpened;

	_variant_t				m_MapforceDelRows;
};


} // namespace altova

#endif // ALTOVADB_H_INCLUDED
