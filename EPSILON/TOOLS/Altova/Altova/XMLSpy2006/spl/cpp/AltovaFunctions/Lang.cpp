////////////////////////////////////////////////////////////////////////
//
// Lang.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include <Altova.h>
#include <SchemaTypes.h>
#include <AltovaException.h>
#include <SchemaTypeCalendar.h>
#include <SchemaTypeNumber.h>
#include <SchemaTypeString.h>
#include <SchemaTypeBinary.h>
#include "Lang.h"
#include <math.h>
#include <time.h>

namespace altova {


TMapLongToLong	Lang::ms_AutoNumberValues;


CSchemaDouble	Lang::Sin(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( sin(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Cos(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( cos(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Tan(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( tan(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Asin(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( asin(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Acos(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( acos(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Atan(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( atan(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Radians(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( rNum.ToDouble() / 180.0 * M_PI );
}

CSchemaDouble	Lang::Degrees(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( rNum.ToDouble() * 180.0 / M_PI );
}

CSchemaDouble	Lang::Exp(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( exp(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Log(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( log(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Log10(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( log10(rNum.ToDouble()) );
}

CSchemaDouble	Lang::Pow(const CSchemaTypeNumber& rNumBase, const CSchemaTypeNumber& rNumExp)
{
	return CSchemaDouble( pow(rNumBase.ToDouble(), rNumExp.ToDouble()) );
}

CSchemaDouble	Lang::Random()
{
	srand( (unsigned)time( NULL ) );
	return CSchemaDouble( (double)rand() / (double)RAND_MAX );
}

CSchemaDouble	Lang::Sqrt(const CSchemaTypeNumber& rNum)
{
	return CSchemaDouble( sqrt(rNum.ToDouble() ) );
}

CSchemaString	Lang::Uppercase(const CSchemaString& rStr)
{
	return CSchemaString( _tcsupr( (TCHAR*)((tstring)rStr).c_str() ) );
}

CSchemaString	Lang::Lowercase(const CSchemaString& rStr)
{
	return CSchemaString( _tcslwr( (TCHAR*)((tstring)rStr).c_str() ) );
}

CSchemaString	Lang::Capitalize(const CSchemaString& rStr)
{
	tstring sResult = rStr;
	int nPos = -1;
	while( true )
	{
		if( nPos < (int)sResult.length() - 1 ) 
			sResult = sResult.substr(0, nPos+1 ) + _tcsupr((TCHAR*)(sResult.substr( nPos + 1, 1).c_str())) + sResult.substr( nPos+2, sResult.length() - nPos - 2);

		nPos = sResult.find_first_of( _T(" \\n\\r\\t"), nPos + 1);
		if( nPos < 0 )
			break;
	}
	return CSchemaString( sResult );
}

CSchemaInt	Lang::CodeFromChar(const CSchemaString& rStr)
{
	return CSchemaInt( ((tstring)rStr)\[0\] );
}

CSchemaString	Lang::CharFromCode(const CSchemaInt& rNum)
{
	tstring sCh( _T(" ") );
	TCHAR ch = (TCHAR)rNum.ToCalcValue();
	sCh\[0\] = ch;
	return CSchemaString( sCh );
}

CSchemaInt	Lang::StringCompare(const CSchemaString& rStr1, const CSchemaString& rStr2)
{
    return CSchemaInt( _tcscmp( ((tstring)rStr1).c_str(), ((tstring)rStr2).c_str() ) );
}

CSchemaInt	Lang::StringCompareIgnoreCase(const CSchemaString& rStr1, const CSchemaString& rStr2)
{
    return CSchemaInt( _tcsicmp( ((tstring)rStr1).c_str(), ((tstring)rStr2).c_str() ) );
}

CSchemaInt	Lang::CountSubstring(const CSchemaString& rStr, const CSchemaString& rSubStr)
{
	int nPosition = ((tstring)rStr).find( (tstring)rSubStr );
	int nResult = 0;
	while( nPosition >= 0 ) 
	{
		nResult++;
		nPosition = ((tstring)rStr).find( (tstring)rSubStr, nPosition+1 );
	}
	
	return CSchemaInt( nResult );
}

CSchemaBoolean	Lang::MatchPattern(const CSchemaString& rStr, const CSchemaString& rPattern)
{
	// !!!!! TODO: to be implemented	
	return CSchemaBoolean(false);
}

CSchemaInt		Lang::FindSubstring(const CSchemaString& rStr, const CSchemaString& rSubStr, const CSchemaTypeNumber& rStartPos)
{
	long nStart = rStartPos.ToLong();
	if( nStart > 0 )
		return CSchemaInt( ((tstring)rStr).find( (tstring)rSubStr, nStart ) + 1 );
	else
		return CSchemaInt( ((tstring)rStr).find( (tstring)rSubStr ) + 1 );
}

CSchemaInt		Lang::ReversefindSubstring(const CSchemaString& rStr, const CSchemaString& rSubStr, const CSchemaTypeNumber& rEndPos)
{
	if( rEndPos.ToLong() < 0 )
		return CSchemaInt( ((tstring)rStr).rfind( (tstring)rSubStr ) + 1 );
	else
		return CSchemaInt( ((tstring)rStr).rfind( (tstring)rSubStr, rEndPos.ToLong() ) + 1 );
}

CSchemaString	Lang::Left(const CSchemaString& rStr, CSchemaTypeNumber& rNum)
{
	return CSchemaString( ((tstring)rStr).substr(0, rNum.ToLong()) );
}

CSchemaString	Lang::LeftTrim(const CSchemaString& rStr)
{
	int nPos = ((tstring)rStr).find_first_not_of(_T(" \\n\\r\\t"));
	int nLen = ((tstring)rStr).length();
	if( nPos< 0  ||  nLen == 0 )
		return CSchemaString( _T("") );
	return CSchemaString( ((tstring)rStr).substr(nPos, nLen-nPos) );
}

CSchemaString	Lang::Right(const CSchemaString& rStr, CSchemaTypeNumber& rNum)
{
	int nLen = ((tstring)rStr).length();
	return CSchemaString( ((tstring)rStr).substr(nLen-rNum.ToLong(), rNum.ToLong()) );
}

CSchemaString	Lang::RightTrim(const CSchemaString& rStr)
{
	int nPos = ((tstring)rStr).find_last_not_of(_T(" \\n\\r\\t"));
	int nLen = ((tstring)rStr).length();
	if( nPos< 0  ||  nLen == 0 )
		return CSchemaString( _T("") );
	return CSchemaString( ((tstring)rStr).substr(0, nPos + 1) );
}


CSchemaString	Lang::Replace(const CSchemaString& rStr, const CSchemaString& rFind, const CSchemaString& rReplace)
{
	tstring sResult = rStr;
	tstring oldstring = rFind;
	tstring newstring = rReplace;
	tstring::size_type	nPos = sResult.find( oldstring );
	while( nPos != tstring::npos )
	{
		sResult.replace( nPos, oldstring.length(), newstring );
		nPos = sResult.find( oldstring, nPos + 1 );
	}

	return CSchemaString( sResult );
}

CSchemaBoolean	Lang::Empty(const CSchemaString& rStr)
{
	return CSchemaBoolean( rStr.IsEmpty() || ((tstring)rStr)==_T("") );
}

CSchemaString Lang::FormatGuidString(const CSchemaString& rGuid)
{
	tstring sGuid = rGuid;
	if( sGuid.length() != 32 )
		return CSchemaString();		// input value is not correct

	tstring sBuffer;
	tstring sResult;

	for( int i=0; i<16; ++i )
	{
		sBuffer = sGuid.substr( i*2, 2 );
		sResult += sBuffer;

		if( i==3 || i==5 || i==7 || i==9 )
			sResult += _T("-");		// format correctly because it is used as string.
	}
	
	return sResult;
}


CSchemaDateTime	Lang::DatetimeAdd(const CSchemaDateTime& rDT, const CSchemaDuration& rDur)
{
	CSchemaDateTime result = rDT + rDur;
	return result;
}

CSchemaDuration	Lang::DatetimeDiff(const CSchemaDateTime& rDT1, const CSchemaDateTime& rDT2)
{
	if( rDT1 >= rDT2 )
		return rDT1 - rDT2;
	CSchemaDuration result = rDT2 - rDT1;
	result.GetValue().bPositive = false;
	return result;
}

CSchemaDateTime	Lang::DatetimeFromParts(	const CSchemaTypeNumber& rYear, const CSchemaTypeNumber& rMonth,	const CSchemaTypeNumber& rDay,
											const CSchemaTypeNumber& rHour,	const CSchemaTypeNumber& rMinute,	const CSchemaTypeNumber& rSecond,
											const CSchemaTypeNumber& rMillisecond, const CSchemaTypeNumber& rTimezone )
{
	CSchemaTypeCalendar::CDateTime	dateTime(	rYear.ToLong(), rMonth.ToLong(), rDay.ToLong(), 
												rHour.ToLong(), rMinute.ToLong(),	
												rSecond.ToDouble() + rMillisecond.ToDouble() / 1000.0 );
	if( rTimezone.ToLong() >= -1440 && rTimezone.ToLong() <= 1440 )
	{
		dateTime.nTZMode = CSchemaTypeCalendar::CDateTimeBase::TZ_Offset;
		dateTime.nOffset = rTimezone.ToLong();
	}

	return CSchemaDateTime( dateTime );
}

CSchemaDateTime	Lang::DatetimeFromDateAndTime( const CSchemaDate& rDate, const CSchemaTime& rTime )
{
	CSchemaDateTime result = rDate;
	result.GetValue().nHour = rTime.GetValue().nHour;
	result.GetValue().nMinute = rTime.GetValue().nMinute;
	result.GetValue().dSecond = rTime.GetValue().dSecond;
	return result;
}

CSchemaDateTime	Lang::Now()
{
	CSchemaTypeCalendar::CDateTime	dt;

	return CSchemaDateTime( dt );
}

CSchemaBoolean	Lang::Leapyear(const CSchemaDateTime& rDT)
{
	int year = rDT.GetValue().nYear;
	return CSchemaBoolean( (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0)) );
}

CSchemaInt		Lang::Timezone(const CSchemaTypeCalendar& rCal)
{
	switch( rCal.CalendarType() )
	{
	case CSchemaType::k_Date:
	case CSchemaType::k_DateTime:
		return CSchemaInt( ((CSchemaDate)rCal).GetValue().nOffset );
	case CSchemaType::k_Time:
		return CSchemaInt( ((CSchemaTime)rCal).GetValue().nOffset );
	}
	return CSchemaInt();	// no timezone-info available --> return empty result
}

CSchemaInt		Lang::Weekday(const CSchemaDate& rDate)
{
	// theoretical concepts and formulars inspired by http://robm.fastmail.fm/date_class.html
	long a = (14-rDate.GetValue().nMonth)/12;
	long m = rDate.GetValue().nMonth + 12*a - 3;
	long y = rDate.GetValue().nYear+4800-a;

	long JD = rDate.GetValue().nDay + (153*m+2)/5 + y*365 + y/4 - y/100 + y/400 - 32045; // julian date
	
	return CSchemaInt( JD % 7 + 1 );
}

CSchemaInt		Lang::Weeknumber(const CSchemaDate& rDate)
{
	long a = (14-rDate.GetValue().nMonth)/12;
	long m = rDate.GetValue().nMonth + 12*a - 3;
	long y = rDate.GetValue().nYear+4800-a;

	long JD = rDate.GetValue().nDay + (153*m+2)/5 + y*365 + y/4 - y/100 + y/400 - 32045; // julian date
	
	long d4 = (JD+31741 - (JD % 7)) % 146097 % 36524 % 1461;
	long L = d4/1460;
	long d1 = ((d4-L) % 365) + L;

	return CSchemaInt( d1/7+1 );
}


CSchemaDuration	Lang::DurationAdd(const CSchemaDuration& rDur1, const CSchemaDuration& rDur2)
{
	return rDur1 + rDur2;
}

CSchemaDuration	Lang::DurationSubtract(const CSchemaDuration& rDur1, const CSchemaDuration& rDur2)
{
	CSchemaDuration tempDur = rDur2;
	tempDur.GetValue().bPositive = !rDur2.GetValue().bPositive;
	return rDur1 + rDur2;
}

CSchemaDuration	Lang::DurationFromParts(	const CSchemaTypeNumber& rYear, const CSchemaTypeNumber& rMonth, const CSchemaTypeNumber& rDay,
											const CSchemaTypeNumber& rHour,	const CSchemaTypeNumber& rMinute, const CSchemaTypeNumber& rSecond,
											const CSchemaTypeNumber& rMillisecond, const CSchemaType& rIsNegative )
{
	CSchemaTypeCalendar::CDuration			duration( !(rIsNegative.ToBool()), rYear.ToLong(), rMonth.ToLong(), 
														rDay.ToLong(),	rHour.ToLong(), rMinute.ToLong(), 
														rSecond.ToDouble() + rMillisecond.ToDouble() / 1000.0 );

	return CSchemaDuration( duration );
}

CSchemaString Lang::CreateGuid()
{
	tstring	sResult;

#ifdef _MFC_VER
	unsigned char		cGUID\[16\];			// stores the 16-byte GUID value
	if( CoCreateGuid( ( GUID* )&cGUID ) != S_OK )
		return CSchemaString();		// there was an error during creation

	for( int i=0; i<16; ++i )
	{
		TCHAR szValue\[3\];
		_sntprintf(szValue, 3, _T("%02X"), cGUID\[i\]);
		sResult += szValue;
	}
#endif // _MFC_VER

	return sResult;
}


CSchemaInt	Lang::AutoNumber( const long nComponentId, const CSchemaInt& rStartAt, const CSchemaInt& rIncrease )
{
	long nActValue = 1;
	TMapLongToLong::iterator it = ms_AutoNumberValues.find( nComponentId );
	if( it == ms_AutoNumberValues.end() )
		nActValue = rStartAt.ToLong();
	else
		nActValue = ms_AutoNumberValues\[ nComponentId \];

	ms_AutoNumberValues\[ nComponentId \] = nActValue + rIncrease.ToLong();
	return nActValue;
}


} // namespace altova
