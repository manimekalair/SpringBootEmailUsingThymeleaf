////////////////////////////////////////////////////////////////////////
//
// Core.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVAFUNCTIONS_CORE_H_INCLUDED
#define ALTOVAFUNCTIONS_CORE_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include <math.h>
#include "AltovaFunctionsAPI.h"

////////////////////////////////////////////////////////////////////////
//
//  utilities
//
////////////////////////////////////////////////////////////////////////

// here follows a necessary hack for VS6.0 compiler 
// to be able to use partial template specialisation
namespace AltovaInternal
{
	template <bool>
	struct SelectImpl
	{
		template <class T, class U>
		struct In
		{
			typedef T Result;
		};
	};

	template <>
	struct SelectImpl<false>
	{
		template <class T, class U>
		struct In
		{
			typedef U Result;
		};
	};
}


namespace altova {

// utilities to do compile-time return-type selection.
template <bool flag, typename T, typename U>
struct SelectType
{
	typedef typename AltovaInternal::SelectImpl<flag>::template In<T, U>::Result Result;
};


template <class A, class B>
struct IsTypeGreater
{
	enum { value = A::TYPE > B::TYPE };
};


////////////////////////////////////////////////////////////////////////
//
//  Core function library
//
////////////////////////////////////////////////////////////////////////


class ALTOVAFUNCTIONS_DECLSPECIFIER Core
{
public:
	Core() {};

	// logical functions
	static CSchemaBoolean	LogicalNot(const CSchemaType& rObj)	
		{ return CSchemaBoolean( !rObj.ToBool() ); }
	static CSchemaBoolean	LogicalOr(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( rObj1.ToBool() || rObj2.ToBool() ); }
	static CSchemaBoolean	LogicalAnd(const CSchemaType& rObj1, const CSchemaType& rObj2)
		{ return CSchemaBoolean( rObj1.ToBool() && rObj2.ToBool() );	}

	// logical functions: comparison
	static CSchemaBoolean	Equal(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareEqual(rObj1, rObj2) ); }
	static CSchemaBoolean	Greater(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareGreater(rObj1, rObj2) ); }
	static CSchemaBoolean	Less(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareLess(rObj1, rObj2) ); }
	static CSchemaBoolean	NotEqual(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareNotEqual(rObj1, rObj2) ); }
	static CSchemaBoolean	EqualOrGreater(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareGreaterEqual(rObj1, rObj2) ); }
	static CSchemaBoolean	EqualOrLess(const CSchemaType& rObj1, const CSchemaType& rObj2)	
		{ return CSchemaBoolean( CSchemaType::CompareLessEqual(rObj1, rObj2) ); }

	// string functions
	static CSchemaString	Concat(const CSchemaString& rObj1, const CSchemaString& rObj2)
		{ return CSchemaString( (tstring)rObj1 + (tstring)rObj2 ); }
	static CSchemaString	NormalizeSpace(const CSchemaString& rObj);
	static CSchemaBoolean	StartsWith(const CSchemaString& rString, const CSchemaString& rSubStr)
		{ return CSchemaBoolean( ((tstring)rString).find( (tstring)rSubStr )==0 );	}
	static CSchemaInt		StringLength(const CSchemaString& rObj)
		{ return CSchemaInt( ((tstring)rObj).length() ); }
	static CSchemaString	Substring(const CSchemaString& rString, const CSchemaTypeNumber& rStart, const CSchemaTypeNumber& rLength);
	static CSchemaString	SubstringAfter(const CSchemaString& rString, const CSchemaString& rSubStr);
	static CSchemaString	SubstringBefore(const CSchemaString& rString, const CSchemaString& rSubStr);
	static CSchemaString	Translate(const CSchemaString& rValue, const CSchemaString& rFrom, const CSchemaString& rTo);
	static CSchemaBoolean	Contains(const CSchemaString& rString, const CSchemaString& rSubStr)
		{ return CSchemaBoolean(  (long)(((tstring)rString).find( (tstring)rSubStr ))>=0 ); }

	// conversion functions
	static CSchemaBoolean ToBoolean(const CSchemaType& rObj1)
		{	return CSchemaBoolean( rObj1 );	}
	static CSchemaDecimal	ToNumber(const CSchemaType& rObj1);
	static CSchemaString	ToString(const CSchemaType& rObj1)
		{	return CSchemaString( rObj1 );	}

////////////////////////////////////////////////////////////////////////
//
//  Mathematical functions
//
////////////////////////////////////////////////////////////////////////

	// Add
	template <class A, class B>
	static typename SelectType< IsTypeGreater<A,B>::value, A, B>::Result Add(const A& a, const B& b)
	{
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = a.ToCalcValue() + b.ToCalcValue();
		return SelectType< IsTypeGreater<A,B>::value, A, B>::Result(result);
	}

	// Subtract
	template <class A, class B>
	static typename SelectType< IsTypeGreater<A,B>::value, A, B>::Result Subtract(const A& a, const B& b)
	{
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = a.ToCalcValue() - b.ToCalcValue();
		return SelectType< IsTypeGreater<A,B>::value, A, B>::Result(result);
	}

	// Multiply
	template <class A, class B>
	static typename SelectType< IsTypeGreater<A,B>::value, A, B>::Result Multiply(const A& a, const B& b)
	{
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = a.ToCalcValue() * b.ToCalcValue();
		return SelectType< IsTypeGreater<A,B>::value, A, B>::Result(result);
	}

	// Divide
	template <class A, class B>
	static typename SelectType< IsTypeGreater<A,B>::value, A, B>::Result Divide(const A& a, const B& b)
	{
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = a.ToCalcValue() / b.ToCalcValue();
		return SelectType< IsTypeGreater<A,B>::value, A, B>::Result(result);
	}

	// Floor
	template <class A>
	static A Floor(const A& a)
	{ 
		return floor( a.ToCalcValue() ); 
	}

	// Ceiling
	template <class A>
	static A Ceiling(const A& a)
	{ 
		return ceil( a.ToCalcValue() );
	}

	// Round
	template <class A>
	static A Round(const A& a)
	{
		return round(a.ToCalcValue(),0);
	}

	// Modulus
	template <class A, class B>
	static typename SelectType< IsTypeGreater<A,B>::value, A, B>::Result Modulus(const A& a, const B& b)
	{
#if _MSC_VER < 1300
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = fmod(a.ToCalcValue(), b.ToCalcValue());
#else
		SelectType< IsTypeGreater<A,B>::value, A, B>::Result::calctype result = (double)fmod((double)a.ToCalcValue(), (double)b.ToCalcValue());
#endif
		return SelectType< IsTypeGreater<A,B>::value, A, B>::Result(result);
	}

protected:
	static double	round(double num, int precision)	{ return (double)floor(num*pow(10.0,precision)+0.5)/pow(10.0,precision); }
};

} // namespace altova

#endif // ALTOVAFUNCTIONS_CORE_H_INCLUDED
