////////////////////////////////////////////////////////////////////////
//
// [=$application.Name].cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$application.Name].h"
[foreach $Mapping in $application.Mappings
	foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
		$AlgorithmGroupClass = $application.Name & $AlgorithmGroup.Name
]#include "[=$AlgorithmGroupClass].h"
[	next
next
]using namespace std;


[if $libtype <> 1 and $domtype = 1]
#import "msxml4.dll" named_guids implementation_only
[endif]

#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE\[\] = __FILE__;
#endif

[if $mfc]
CWinApp theApp;
[endif]

int _tmain(int argc, TCHAR* argv\[\], TCHAR* envp\[\])
{
	tcout << _T("[=$application.Name] Application") << endl;

[if $InputParameterCount > 0
]	std::map< tstring, tstring >	mapArguments;
	if( argc <= 1 )
	{
		tcout << endl << _T(\"WARNING: No parameters given!\") << endl;
		tcout << _T(\"SYNTAX: [=$application.Name].exe [
	foreach $Mapping in $application.Mappings
		foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
			foreach $SourceLibrary in $AlgorithmGroup.SourceLibraryList
				if $SourceLibrary.Kind = 4	' Parameter Library
					if $SourceLibrary.IsOptional ]\[[endif
					]/[=$SourceLibrary.Name] ...[
					if $SourceLibrary.IsOptional ]\][endif
					] [
				endif
			next
		next
	next
		]\") << endl;
		tcout << _T(\"Note: If you want to use spaces as values write them inbetween double quotes.\") << endl << endl;
	}
	else
	{
		for( int i = 1; i < argc; i++ )
		{
			tstring sName = argv\[ i \];
			if( sName\[ 0 \] == _T('/')  &&  ( i + 1 ) < argc )
				mapArguments\[ sName.substr( 1, sName.length() - 1 ) \] = argv\[ ++i \];
		}
	}
[endif
]

[if $mfc
]	if (!AfxWinInit(::GetModuleHandle(NULL), NULL, ::GetCommandLine(), 0))
	{
		cerr << "Fatal Error: MFC initialization failed" << endl;
		return 1;
	}
[endif
]	try
	{
[if $domtype = 2
]		xercesc::XMLPlatformUtils::Initialize();
[endif
if $domtype = 1 or $DBLibraryCount > 0
]		CoInitialize(NULL);
[endif
foreach $Mapping in $application.Mappings
	foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
		$AlgorithmGroupClass = $application.Name & $AlgorithmGroup.Name
		$Args = ""
]		{
			[=$AlgorithmGroupClass] [=$AlgorithmGroupClass]Object;
			[=$AlgorithmGroupClass]Object.Run(
				[
		foreach $SourceLibrary in $AlgorithmGroup.SourceLibraryList
			if $SourceLibrary.Kind = 1 ' XML Library
				]_T("[=$SourceLibrary.InputInstanceName]")[
			endif
			if $SourceLibrary.Kind = 2 ' Database Library
				]_T("[=$SourceLibrary.ADOConnectionString]")[
			endif
			if $SourceLibrary.Kind = 3 ' Text Parser Library
				]_T("[=$SourceLibrary.InputFileName]")[
			endif
			if $SourceLibrary.Kind = 4 ' Parameter Library
				]mapArguments.find( _T(\"[=$SourceLibrary.Name]\") ) != mapArguments.end() ? [=$SourceLibrary.DataType]( mapArguments\[ _T(\"[=$SourceLibrary.Name]\") \].c_str() ) : [=$SourceLibrary.DataType]()[
			endif
			],
				[
		next
		if $AlgorithmGroup.TargetLibrary.Kind = 1 ' XML Library
			]_T("[=$AlgorithmGroup.TargetLibrary.OutputInstanceName]"));
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 2 ' Database Library
			]_T("[=$AlgorithmGroup.TargetLibrary.ADOConnectionString]"));
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 3 ' Text Parser Library
			]_T("[=$AlgorithmGroup.TargetLibrary.OutputFileName]"));
[		endif
]		}
[	next
next
if $domtype = 2
]		xercesc::XMLPlatformUtils::Terminate();
[endif
if $domtype = 1 or $DBLibraryCount > 0
]		CoUninitialize();
[endif
]
		tcout << _T("OK") << endl;
		return 0;
	}
	catch (CAltovaException& e)
	{
		if (e.IsUserException())
			tcerr << _T("User Exception: ");
		else
		tcerr << _T("Error: ");
		tcerr  << e.GetInfo().c_str() << endl;
		return 1;
	}
[if $domtype = 2
]	catch (xercesc::XMLException& e)
	{
		tcerr << _T("Xerces XMLException: ") << e.getSrcFile() << _T("(")
			  << e.getSrcLine() << _T("): ") << e.getMessage() << endl;
		return 1;
	}
	catch (xercesc::DOMException& e)
	{
		tcerr << _T("Xerces DOMException ") << e.code;
		if (e.msg)
			tcerr << _T(": ") << e.msg;
		tcerr << endl;
		return 1;
	}
[endif
if $domtype = 1 or $DBLibraryCount > 0
]	catch (_com_error& e)
	{
		tcerr << _T("COM-Error from ") << (TCHAR*)e.Source() << _T(":") << endl;
		tcerr << (TCHAR*)e.Description() << endl;
		return 1;
	}
[endif
]	catch (std::exception& e)
	{
		cerr << "Exception: " << e.what() << endl;
		return 1;
	}
	catch (...)
	{
		tcerr << _T("Unknown error") << endl;
		return 1;
	}
}
