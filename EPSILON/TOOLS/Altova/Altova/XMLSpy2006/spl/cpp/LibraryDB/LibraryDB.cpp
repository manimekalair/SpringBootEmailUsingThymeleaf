////////////////////////////////////////////////////////////////////////
//
// [=$module].cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$module].h"
[if $libtype <> 1 'if DLL]
#pragma warning(disable: 4146)
// If you get a compiler-error on the line below, add the path to the DLL
// at Tools|Options|Directories|Include Directories.
// Hint: Depending on your installation it might be C:\\Program Files\\Common Files\\System\\ADO
#import "msado15.dll" rename("EOF", "EndOfFile") implementation_only
#pragma warning(default: 4146)
[endif]
#ifdef _DEBUG
	#define new DEBUG_NEW
	#undef THIS_FILE
	static char THIS_FILE\[\] = __FILE__;
#endif

namespace [=$module]
{

////////////////////////////////////////////////////////////////////////
//	[=$module]Database
////////////////////////////////////////////////////////////////////////

[=$module]Database::[=$module]Database(const tstring& sConnectionString) 
: CDatabase(sConnectionString) 
{
[	if $library.OnOpenExecuteSQL <> ""
]	// initilaize database connection
	try
	{
		m_spConnection->Execute( _bstr_t( _T("[=$library.OnOpenExecuteSQL]") ), NULL, ADODB::adCmdText );
	}
	catch( _com_error& e )
	{
		throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Init, sConnectionString, (LPCTSTR)e.Description() );
	}
[	endif
	if $library.IsUseTransaction
]	// transaction handling
	try
	{
		InternalBeginTransaction();
	}
	catch( CAltovaDBExecuteException& e )
	{
		throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Init, sConnectionString, e.GetErrorMessage().c_str() );
	}
	m_nTransactionCounter++;
[	endif
]
}


[=$module]Database::~[=$module]Database() 
{

[	if $library.IsUseTransaction
]	// transaction handling
	if( m_nTransactionCounter > 0 )
	{
		try
		{
			if( !m_bRollbackTransaction )
				InternalCommitTransaction();
			else
				InternalRollbackTransaction();
		}
		catch( CAltovaDBExecuteException& e )
		{
			throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Finalize, _T("finalize transaction"), e.GetErrorMessage().c_str() );
		}
		m_nTransactionCounter--;
	}
[	endif
	if $library.OnCloseExecuteSQL <> ""
]	// finalize database connection
	try
	{
		m_spConnection->Execute( _bstr_t( _T("[=$library.OnCloseExecuteSQL]") ), NULL, ADODB::adCmdText );
	}
	catch( _com_error& e )
	{
		throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Finalize, _T("[=$library.OnCloseExecuteSQL]"), (LPCTSTR)e.Description() );
	}
[	endif
]}


[=$module]Database& [=$module]Database::operator =(const [=$module]Database& rOther)
{
	m_spConnection = rOther.m_spConnection;
	return *this;
}


// transaction handling

void [=$module]Database::InternalBeginTransaction()
{
	try
	{
[		if not $library.IsMainTransactionViaSQL
]		m_spConnection->BeginTrans();
[		else : if $library.SQLBeginTransaction <> ""
]		m_spConnection->Execute( _T("[=$library.SQLBeginTransaction]"), NULL, ADODB::adCmdText );
[		endif : endif
]	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, _T("begin transaction"), (LPCTSTR)e.Description() );
	}
}


void [=$module]Database::InternalCommitTransaction()
{
	try
	{
[		if not $library.IsMainTransactionViaSQL
]		m_spConnection->CommitTrans();
[		else : if $library.SQLCommitTransaction <> ""
]		m_spConnection->Execute( _T("[=$library.SQLCommitTransaction]"), NULL, ADODB::adCmdText );
[		endif : endif
]	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, _T("commit transaction"), (LPCTSTR)e.Description() );
	}
}


void [=$module]Database::InternalRollbackTransaction()
{
	try
	{
[		if not $library.IsMainTransactionViaSQL
]		m_spConnection->RollbackTrans();
[		else : if $library.SQLRollbackTransaction <> ""
]		m_spConnection->Execute( _T("[=$library.SQLRollbackTransaction]"), NULL, ADODB::adCmdText );
[		endif : endif
]	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, _T("rollback transaction"), (LPCTSTR)e.Description() );
	}
}


void [=$module]Database::InternalSetSavepoint( LPCTSTR szTransactionName )
{
[		if $library.SQLSetSavepoint <> "" 
]	tstring sStatement( _T("[=$library.SQLSetSavepoint]") );
	tstring sFind( _T(" %%TRANSACTION_NAME%% ") );
	sStatement.replace( sStatement.find( sFind ), sFind.length(), szTransactionName );
	try
	{
		m_spConnection->Execute( sStatement.c_str(), NULL, ADODB::adCmdText );
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, sStatement, (LPCTSTR)e.Description() );
	}
[		endif
]}


void [=$module]Database::InternalRollbackToSavepoint( LPCTSTR szTransactionName )
{
[		if $library.SQLRollbackToSavepoint <> "" 
]	tstring sStatement( _T("[=$library.SQLRollbackToSavepoint]") );
	tstring sFind( _T(" %%TRANSACTION_NAME%% ") );
	sStatement.replace( sStatement.find( sFind ), sFind.length(), szTransactionName );
	try
	{
		m_spConnection->Execute( sStatement.c_str(), NULL, ADODB::adCmdText );
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, sStatement, (LPCTSTR)e.Description() );
	}
[		endif
]}


[foreach $table in $library.Tables
]
////////////////////////////////////////////////////////////////////////
//	[=$table.Name]Set
////////////////////////////////////////////////////////////////////////

// construction and destruction
[=$table.Name]Set::[=$table.Name]Set() 
: CRecordSet()
{
	Reset();
}


[=$table.Name]Set::[=$table.Name]Set( CDatabase& rDatabase, const CCommand& cmdQuery ) 
: CRecordSet( rDatabase, cmdQuery )
{
	Reset();
}

// accessors
[	foreach $column in $table.Columns
]void [=$table.Name]Set::Set[=$column.Name]([=$column.Type] value)
{ 
	if( m_bReadAccess )
		InternalSetValue(_T(\"[=$column.DBName]\"), value); 
	else
		m_[=$column.Name] = value;
}

[	next]

// override from CRecordSet
void	[=$table.Name]Set::Prepare( bool bReadOnlyAccess )
{
	m_bReadAccess = bReadOnlyAccess;

	Reset();
}

_variant_t	[=$table.Name]Set::GetValueByName(const tstring& sColumn)
{
[	foreach $column in $table.Columns
]	if( sColumn == _T("[=$column.DBName]") ) return m_[=$column.Name];
[	next
]	return _variant_t();
}

void	[=$table.Name]Set::SetValueByName(const tstring& sColumn, const _variant_t& vValue)
{
	if( sColumn == _T("MAPFORCE_DEL_ROWS") )	{ m_MapforceDelRows = vValue; return; }
[	foreach $column in $table.Columns
]	if( sColumn == _T("[=$column.DBName]") ) { m_[=$column.Name] = [=$column.Type]( vValue ); return; }
[	next
]}

// helper functions
void	[=$table.Name]Set::Reset()
{
	// set members for internal buffer to null
[	foreach $column in $table.Columns
]	m_[=$column.Name].SetIsNull( true );
[	next
]}


[next]

}