////////////////////////////////////////////////////////////////////////
//
// SchemaTypeBinary.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypeBinary.h"

#include "SchemaTypeString.h"


namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBinaryBase
//
////////////////////////////////////////////////////////////////////////


CSchemaBinaryBase::CSchemaBinaryBase()
: m_nSize( 0 )
, m_pData( NULL )
[if $DBLibraryCount > 0], m_pSafeArray( NULL )[endif]
{
}


CSchemaBinaryBase::CSchemaBinaryBase( const CSchemaBinaryBase& rOther )
: m_nSize( 0 )
, m_pData( NULL )
[if $DBLibraryCount > 0], m_pSafeArray( NULL )[endif]
{
	Clone( rOther );
}


CSchemaBinaryBase::CSchemaBinaryBase( const unsigned char* pData, size_t nSize )
: m_nSize( 0 )
, m_pData( NULL )
[if $DBLibraryCount > 0], m_pSafeArray( NULL )[endif]
{
	Clone( pData, nSize );
}

[if $DBLibraryCount > 0]
CSchemaBinaryBase::CSchemaBinaryBase( const _variant_t& vValue ) 
: m_nSize( 0 )
, m_pData( NULL )
, m_pSafeArray( NULL )
{
	if( CheckContainsValue( vValue) )
	{
		if( vValue.vt == ( VT_ARRAY | VT_UI1 ) )
		{
			void* pSource = NULL;
			long	nSize = 0;
			SafeArrayGetUBound( vValue.parray, 1, &nSize );
			SafeArrayAccessData( vValue.parray, &pSource );
			SetData( ( const unsigned char* )pSource, nSize );
			SafeArrayUnaccessData( vValue.parray );
		}
		else
			SetIsEmpty( true );
	}
}
[endif]


CSchemaBinaryBase::~CSchemaBinaryBase()
{
	Empty();
}


[if $DBLibraryCount > 0]
CSchemaBinaryBase::operator _variant_t() const
{
	if( IsEmpty() || !m_pSafeArray )
		return _variant_t();

	VARIANT		vValue;
	VariantInit( &vValue );
	vValue.vt = VT_ARRAY | VT_UI1;
	vValue.parray = m_pSafeArray;
	return vValue;
}
[endif]


void CSchemaBinaryBase::SetData( const unsigned char* pData, size_t nSize )
{
	Empty();
	Clone( pData, nSize );
}


bool CSchemaBinaryBase::ToBool() const
{
	if( !CSchemaType::ToBool() )
		return false;

	return !( m_pData == NULL );
}


void CSchemaBinaryBase::Empty()
{
	CSchemaType::Empty();

	if( m_pData )
		delete\[\] m_pData;
	m_pData = NULL;
	m_nSize = 0;
[if $DBLibraryCount > 0]
	if( m_pSafeArray )
		SafeArrayDestroy( m_pSafeArray );
	m_pSafeArray = NULL;
[endif]
}


CSchemaType& CSchemaBinaryBase::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaBinaryBase* pBinType = dynamic_cast<const CSchemaBinaryBase*>( &rOther );
	if( pBinType != NULL )
	{
		SetData( pBinType->GetData(), pBinType->GetSize() );
		SetIsEmpty( pBinType->IsEmpty() );
		SetIsNull( pBinType->IsNull() );
		return *this;
	}

	ThrowIncompatibleTypesError();
	return *this;
}


void CSchemaBinaryBase::Clone( const CSchemaBinaryBase& rOther )
{
	m_nSize = rOther.m_nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		SetIsEmpty( true );
		SetIsNull( rOther.IsNull() );
		return;
	}
	m_pData = new unsigned char\[ m_nSize \];
	memcpy( m_pData, rOther.m_pData, m_nSize );
[if $DBLibraryCount > 0]	RebuildSafeArray();[endif]
	SetIsEmpty( false );
}


void CSchemaBinaryBase::Clone( const unsigned char* pData, size_t nSize )
{
	m_nSize = nSize;
	if (m_nSize == 0)
	{
		m_pData = NULL;
		SetIsEmpty( true );
		if( !pData )
			SetIsNull( true );
		return;
	}
	m_pData = new unsigned char\[ m_nSize \];
	memcpy( m_pData, pData, m_nSize );
	[if $DBLibraryCount > 0]RebuildSafeArray();[endif]
	SetIsEmpty( false );
}


[if $DBLibraryCount > 0]
void CSchemaBinaryBase::RebuildSafeArray()
{
	// delete old SAFEARRAY if existing

	if( m_pSafeArray )
		SafeArrayDestroy( m_pSafeArray );
	m_pSafeArray = NULL;

	// check if element is empty
	if( m_nSize == 0 )
		return ;
	
	// create new SafeArray
	m_pSafeArray = SafeArrayCreateVector( VT_UI1, 0, m_nSize );
	void* pDest;
	SafeArrayAccessData( m_pSafeArray, &pDest );
	memcpy( pDest, m_pData, m_nSize ); // Copy into array
	SafeArrayUnaccessData( m_pSafeArray );     
}
[endif]

////////////////////////////////////////////////////////////////////////
//
//  CSchemaHexBinary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaHexBinary::sm_EncodeArray\[\] =
	_T("0123456789ABCDEF");


const char CSchemaHexBinary::sm_DecodeArray\[\] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	10,	11,	12,	13,	14,	15,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaHexBinary::operator tstring() const
{
	if( IsEmpty()  ||  m_pData == NULL )
		return _T("");

	tstring s;
	s.reserve(m_nSize * 2);
	const unsigned char* pReader = m_pData;
	for (size_t i = 0; i < m_nSize; i++)
	{
		s += sm_EncodeArray\[*pReader >> 4\];
		s += sm_EncodeArray\[*pReader & 0xF\];
		pReader++;
	}
	return s;
}


bool CSchemaHexBinary::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	m_nSize = _tcslen(szValue) / 2;
	if (m_nSize == 0)
	{
		m_pData = NULL;
[if $DBLibraryCount > 0]		RebuildSafeArray();[endif]
		SetIsEmpty( true );
		return false;
	}
	m_pData = new unsigned char\[m_nSize\];

	unsigned char* szDataWriter = m_pData;
	while (*szValue && *(szValue + 1))
	{
		char nDigit1 = sm_DecodeArray\[*szValue++\];
		char nDigit2 = sm_DecodeArray\[*szValue++\];
		if (nDigit1 == -1 ||nDigit2 == -1)
			ThrowFormatError();
		*szDataWriter++ = nDigit1 * 16 + nDigit2;
	}
[if $DBLibraryCount > 0]	RebuildSafeArray();[endif]

	return !IsEmpty();
}


CSchemaType& CSchemaHexBinary::Assign(const CSchemaType& rOther)
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaString* pStrType = dynamic_cast<const CSchemaString*>( &rOther );
	if( pStrType )
	{
		Parse( ((tstring)*pStrType).c_str() );
		return *this;
	}

	return CSchemaBinaryBase::Assign( rOther );
}


////////////////////////////////////////////////////////////////////////
//
//  CSchemaBase64Binary
//
////////////////////////////////////////////////////////////////////////


const TCHAR CSchemaBase64Binary::sm_EncodeArray\[\] =
	_T("ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/");


const char CSchemaBase64Binary::sm_DecodeArray\[\] =
{

	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	62,	-1,	-1,	-1,	63,
	52,	53,	54,	55,	56,	57,	58,	59,	60,	61,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	 0,	 1,	 2,	 3,	 4,	 5,	 6,	 7,	 8,	 9,	10,	11,	12,	13,	14,
	15,	16,	17,	18,	19,	20,	21,	22,	23,	24,	25,	-1,	-1,	-1,	-1,	-1,
	-1,	26,	27,	28,	29,	30,	31,	32,	33,	34,	35,	36,	37,	38,	39,	40,
	41,	42,	43,	44,	45,	46,	47,	48,	49,	50,	51,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,
	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1,	-1
};


CSchemaBase64Binary::CSchemaBase64Binary( const TCHAR* szValue )
{
	Decode( szValue, m_pData, m_nSize );
	SetIsEmpty( false );
}


CSchemaBase64Binary::operator tstring() const
{
	if( IsEmpty() ||  m_pData == NULL )
		return _T("");

	tstring sResult;
	TCHAR* szDst;
	size_t nDstSize;

	Encode( m_pData, m_nSize, szDst, nDstSize );
	sResult = szDst;
	delete\[\] szDst;
	return sResult;
}


bool CSchemaBase64Binary::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	Decode( szValue, m_pData, m_nSize );
[if $DBLibraryCount > 0]	RebuildSafeArray();[endif]

	return !IsEmpty();
}


CSchemaType& CSchemaBase64Binary::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	const CSchemaString* pStrType = dynamic_cast<const CSchemaString*>( &rOther );
	if( pStrType )
	{
		Parse( (( tstring )*pStrType).c_str() );
		return *this;
	}

	return CSchemaBinaryBase::Assign( rOther );
}


void CSchemaBase64Binary::Encode( unsigned char* pSrc, size_t nSrcSize, TCHAR*& rszDst, size_t& rnDstSize, size_t nMaxLineLength ) const
{
	size_t			nTmpSize, nAllocSize, nLineLength, i;
	TCHAR*			szDstWriter;
	unsigned long	bBuf;

	if (nSrcSize == 0)
	{
		rszDst = NULL;
		rnDstSize = 0;
		return;
	}

	nTmpSize	= nSrcSize * 4 / 3;
	nAllocSize	= nTmpSize + 8;
	if (nMaxLineLength > 0)
		nAllocSize += nTmpSize * 2 / nMaxLineLength;
	
	rszDst		= new TCHAR\[nAllocSize\];
	szDstWriter	= rszDst;

	nTmpSize	= nSrcSize / 3 * 3;
	rnDstSize	= 0;
	nLineLength	= 0;

	if (nMaxLineLength > 0)
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray\[(bBuf >> 18) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[(bBuf >> 12) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[(bBuf >>  6) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[ bBuf        & 0x3F\];
			rnDstSize += 4;

			nLineLength += 4;
			if (nMaxLineLength > 0 && nLineLength >= nMaxLineLength)
			{
				*szDstWriter++ = _T('\\r');
				*szDstWriter++ = _T('\\n');
				rnDstSize += 2;
				nLineLength = 0;
			}
		}
	}
	else
	{
		for (i = 0; i < nTmpSize; i += 3)
		{
			bBuf = *(pSrc + i) << 16 | *(pSrc + i + 1) << 8 | *(pSrc + i + 2);
			*szDstWriter++ = sm_EncodeArray\[(bBuf >> 18) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[(bBuf >> 12) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[(bBuf >>  6) & 0x3F\];
			*szDstWriter++ = sm_EncodeArray\[ bBuf        & 0x3F\];
			rnDstSize += 4;
		}
	}

	size_t nRest = nSrcSize - nTmpSize;
	if (nRest == 2)
	{
		bBuf = *(pSrc + i) << 8 | *(pSrc + i + 1);
		*szDstWriter++ = sm_EncodeArray\[(bBuf >> 10) & 0x3F\];
		*szDstWriter++ = sm_EncodeArray\[(bBuf >>  4) & 0x3F\];
		*szDstWriter++ = sm_EncodeArray\[(bBuf <<  2) & 0x3F\];
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}
	else if (nRest == 1)
	{
		bBuf = *(pSrc + i);
		*szDstWriter++ = sm_EncodeArray\[(bBuf >>  2) & 0x3F\];
		*szDstWriter++ = sm_EncodeArray\[(bBuf <<  4) & 0x3F\];
		*szDstWriter++ = _T('=');
		*szDstWriter++ = _T('=');
		rnDstSize += 4;
	}

	*szDstWriter = 0;
}


void CSchemaBase64Binary::Decode(const TCHAR* szSrc, unsigned char*& rpDst, size_t& rnDstSize)
{
	size_t			nSrcSize;
	const TCHAR*	szSrcReader;
	unsigned char*	pDstWriter;
	unsigned long	nBuf;
	int				nCount;

	szSrcReader	= szSrc;
	while (*szSrcReader && sm_DecodeArray\[*szSrcReader\] == -1)
	{
		szSrcReader++;
	}
	nSrcSize = _tcslen(szSrcReader);
	if (nSrcSize == 0)
	{
		rpDst = NULL;
		rnDstSize = 0;
		return;
	}

	rpDst		= new unsigned char\[nSrcSize\];
	pDstWriter	= rpDst;
	rnDstSize	= 0;
	nBuf		= 0;
	nCount		= 0;

	while (*szSrcReader)
	{
		while (sm_DecodeArray\[*szSrcReader\] == -1)
		{
			if (!*++szSrcReader)
				goto finish;
		}

		nBuf |= sm_DecodeArray\[*szSrcReader++\];

		if (++nCount == 4)
		{
			*pDstWriter++ = (unsigned char)(nBuf >> 16);
			*pDstWriter++ = (unsigned char)(nBuf >>  8);
			*pDstWriter++ = (unsigned char) nBuf;
			rnDstSize += 3;
			nBuf = 0;
			nCount = 0;
		}
		else
		{
			nBuf <<= 6;
		}
	}

finish:
	if (nCount == 2)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 10);
		rnDstSize++;
	}
	else if (nCount == 3)
	{
		*pDstWriter++ = (unsigned char)(nBuf >> 16) & 0xFF;
		*pDstWriter++ = (unsigned char)(nBuf >>  8) & 0xFF;
		rnDstSize += 2;
	}
}


 

} // namespace altova
