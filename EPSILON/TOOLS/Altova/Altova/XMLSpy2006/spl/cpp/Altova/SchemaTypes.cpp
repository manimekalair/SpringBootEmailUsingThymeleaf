////////////////////////////////////////////////////////////////////////
//
// SchemaTypes.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypes.h"

#include <math.h>
#include "SchemaTypeNumber.h"
#include "SchemaTypeCalendar.h"
#include "SchemaTypeString.h"
#include "SchemaTypeBinary.h"




namespace altova {



////////////////////////////////////////////////////////////////////////
//
//  CSchemaType
//
////////////////////////////////////////////////////////////////////////
CSchemaType::CSchemaType() 
: m_bIsEmpty( true ) 
, m_bIsNull( false )
{
	Empty();
};


bool CSchemaType::Parse( const TCHAR* szValue )
{
	Empty();
	return !( m_bIsEmpty = ( szValue\[ 0 \] == 0 ) );
}


CSchemaType& CSchemaType::Assign( const CSchemaType& rOther )
{
	Empty();
	m_bIsEmpty = rOther.m_bIsEmpty;
	m_bIsNull = rOther.m_bIsNull;
	return *this;
}


[if $DBLibraryCount > 0]
bool	CSchemaType::CheckContainsValue( const _variant_t vValue )
{
	if( vValue.vt == VT_NULL )
	{
		SetIsNull( true );
		return false;
	}
	else if( vValue.vt == VT_EMPTY )
	{
		SetIsEmpty( true );
		return false;
	}
	SetIsEmpty( false );
	return true;
}
[endif]


const TCHAR*	CSchemaType::SchemaType2String(ETypes eType)
{
	switch( eType )
	{
	case k_bool:			return _T("boolean");
	case k_byte:			return _T("byte");
	case k_unsigned_byte:	return _T("unsigned byte");
	case k_short:			return _T("short");
	case k_unsigned_short:	return _T("unsigned short");
	case k_int:				return _T("int");
	case k_unsigned_int:	return _T("unsigned int");
	case k_long:			return _T("long");
	case k_unsigned_long:	return _T("unsigned long");
	case k_float:			return _T("float");
	case k_double:			return _T("double");
	case k_decimal:			return _T("decimal");
	// calendar types
	case k_Duration:		return _T("duration");
	case k_Time:			return _T("time");
	case k_Day:				return _T("gDay");
	case k_Month:			return _T("gMonth");
	case k_MonthDay:		return _T("gMonthDay");
	case k_Year:			return _T("gYear");
	case k_YearMonth:		return _T("gYearMonth");
	case k_Date:			return _T("date");
	case k_DateTime:		return _T("datetime");
	// else
	case k_String:			return _T("string");
	case k_Base64Binary:	return _T("base64binary");
	case k_HexBinary:		return _T("hexbinary");
	}
	return _T("invalid");
}




////////////////////////////////////////////////////////////////////////
//
//  Operators
//
////////////////////////////////////////////////////////////////////////


// equality / not-equal
bool CSchemaType::CompareEqual(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() != rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;
	
	// try strings first; if at least one of them is string compare them as strings
	const CSchemaString* pStr1 = dynamic_cast<const CSchemaString*>(pObj1);
	const CSchemaString* pStr2 = dynamic_cast<const CSchemaString*>(pObj2);
	if (pStr1 || pStr2)
		return ((tstring) rObj1 == (tstring) rObj2);

	// check numeric types
	try
	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() == pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned __int64)pNum1->ToInt64() == (unsigned __int64)pNum2->ToInt64();
			return pNum1->ToInt64() == pNum2->ToInt64();
		}
	}
	catch(std::exception) {}

	// check calendar-types
	try
	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
			case CSchemaType::k_Duration:
				{
					CSchemaDuration dur1( rObj1 );
					CSchemaDuration dur2( rObj2 );
					return dur1.GetValue().ApproximatedNormalizedSeconds() == dur2.GetValue().ApproximatedNormalizedSeconds();
				}
			case CSchemaType::k_Date:
				{
					CSchemaDate t1( rObj1 );
					CSchemaDate t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone() )
						return t1.GetValue().ApproximatedNormalizedDays() == t2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Time:
				{
					CSchemaTime t1( rObj1 );
					CSchemaTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().NormalizedSeconds() == t2.GetValue().NormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_DateTime:
				{
					CSchemaDateTime t1( rObj1 );
					CSchemaDateTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().ApproximatedNormalizedSeconds() == t2.GetValue().ApproximatedNormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_Year:
				{
					CSchemaYear year1( rObj1 );
					CSchemaYear year2( rObj2 );
					if( year1.GetValue().HasTimezone() == year2.GetValue().HasTimezone() )
						return year1.GetValue().nYear == year2.GetValue().nYear;
					else
						return false;
				}
			case CSchemaType::k_YearMonth:
				{
					CSchemaYearMonth ym1( rObj1 );
					CSchemaYearMonth ym2( rObj2 );
					if( ym1.GetValue().HasTimezone() == ym2.GetValue().HasTimezone() )
						return ym1.GetValue().NormalizedMonths() == ym2.GetValue().NormalizedMonths();
					else
						return false;

				}
			case CSchemaType::k_Month:
				{
					CSchemaMonth mon1( rObj1 );
					CSchemaMonth mon2( rObj2 );
					if( mon1.GetValue().HasTimezone() == mon2.GetValue().HasTimezone() )
						return mon1.GetValue().nMonth == mon2.GetValue().nMonth;
					else
						return false;
				}
			case CSchemaType::k_MonthDay:
				{
					CSchemaMonthDay md1( rObj1 );
					CSchemaMonthDay md2( rObj2 );
					if( md1.GetValue().HasTimezone() == md2.GetValue().HasTimezone() )
						return md1.GetValue().ApproximatedNormalizedDays() == md2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Day:
				{
					CSchemaDay day1( rObj1 );
					CSchemaDay day2( rObj2 );
					if( day1.GetValue().HasTimezone() == day2.GetValue().HasTimezone() )
						return day1.GetValue().nDay == day2.GetValue().nDay;
					else
						return false;
				}
			}

		}
	}
	catch(std::exception) {}

	// check binary-types
	try
	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) == 0;
			return false;
		}
	}
	catch(std::exception) {}

	return (tstring)rObj1 == (tstring)rObj2;
}


// less
bool CSchemaType::CompareLess(const CSchemaType& rObj1, const CSchemaType& rObj2 )
{
	if( rObj1.IsEmpty() && rObj2.IsEmpty() )
		return false;
	if( rObj1.IsEmpty() )
		return true;
	if( rObj2.IsEmpty() )
		return false;

	const CSchemaType* pObj1 = &rObj1;
	const CSchemaType* pObj2 = &rObj2;
	
	// try strings first; if at least one of them is string compare them as strings
	const CSchemaString* pStr1 = dynamic_cast<const CSchemaString*>(pObj1);
	const CSchemaString* pStr2 = dynamic_cast<const CSchemaString*>(pObj2);
	if (pStr1 || pStr2)
		return ((tstring) rObj1 < (tstring) rObj2);

	// check numeric types
	try
	{
		const CSchemaTypeNumber* pNum1 = dynamic_cast<const CSchemaTypeNumber*>(pObj1);
		const CSchemaTypeNumber* pNum2 = dynamic_cast<const CSchemaTypeNumber*>(pObj2);
		if( pNum1 &&  pNum2 && 
			pNum1->NumericType() != CSchemaType::k_unknown  &&
			pNum2->NumericType() != CSchemaType::k_unknown )
		{	// both derived from CSchemaTypeNumber
			CSchemaType::ETypes eType1 = pNum1->NumericType();
			CSchemaType::ETypes eType2 = pNum2->NumericType();
			if( eType1 == CSchemaType::k_float  ||  
				eType1 == CSchemaType::k_double  ||  
				eType1 == CSchemaType::k_decimal ||
				eType2 == CSchemaType::k_float  ||  
				eType2 == CSchemaType::k_double  ||  
				eType2 == CSchemaType::k_decimal )
				return pNum1->ToDouble() < pNum2->ToDouble();
			if( pNum1->NumericType() == CSchemaType::k_unsigned_long  ||
				pNum2->NumericType() == CSchemaType::k_unsigned_long )
				return (unsigned __int64)pNum1->ToInt64() < (unsigned __int64)pNum2->ToInt64();
			return pNum1->ToInt64() < pNum2->ToInt64();
		}
	}
	catch(std::exception) {}

	// check calendar-types
	try
	{
		const CSchemaTypeCalendar* pCal1 = dynamic_cast<const CSchemaTypeCalendar*>(pObj1);
		const CSchemaTypeCalendar* pCal2 = dynamic_cast<const CSchemaTypeCalendar*>(pObj2);
		if( pCal1  &&  pCal2  &&
			pCal1->CalendarType() != CSchemaType::k_unknown  &&
			pCal2->CalendarType() != CSchemaType::k_unknown  )
		{	// both derived from CSchemaCalendar
			switch( pCal1->CalendarType() )
			{
			case CSchemaType::k_Duration:
				{
					CSchemaDuration dur1( rObj1 );
					CSchemaDuration dur2( rObj2 );
					return dur1.GetValue().ApproximatedNormalizedSeconds() < dur2.GetValue().ApproximatedNormalizedSeconds();
				}
			case CSchemaType::k_Date:
				{
					CSchemaDate t1( rObj1 );
					CSchemaDate t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone() )
						return t1.GetValue().ApproximatedNormalizedDays() < t2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Time:
				{
					CSchemaTime t1( rObj1 );
					CSchemaTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().NormalizedSeconds() < t2.GetValue().NormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_DateTime:
				{
					CSchemaDateTime t1( rObj1 );
					CSchemaDateTime t2( rObj2 );
					if (t1.GetValue().HasTimezone() == t2.GetValue().HasTimezone())
						return t1.GetValue().ApproximatedNormalizedSeconds() < t2.GetValue().ApproximatedNormalizedSeconds();
					else
						return false;
				}
			case CSchemaType::k_Year:
				{
					CSchemaYear year1( rObj1 );
					CSchemaYear year2( rObj2 );
					if( year1.GetValue().HasTimezone() == year2.GetValue().HasTimezone() )
						return year1.GetValue().nYear < year2.GetValue().nYear;
					else
						return false;
				}
			case CSchemaType::k_YearMonth:
				{
					CSchemaYearMonth ym1( rObj1 );
					CSchemaYearMonth ym2( rObj2 );
					if( ym1.GetValue().HasTimezone() == ym2.GetValue().HasTimezone() )
						return ym1.GetValue().NormalizedMonths() < ym2.GetValue().NormalizedMonths();
					else
						return false;

				}
			case CSchemaType::k_Month:
				{
					CSchemaMonth mon1( rObj1 );
					CSchemaMonth mon2( rObj2 );
					if( mon1.GetValue().HasTimezone() == mon2.GetValue().HasTimezone() )
						return mon1.GetValue().nMonth < mon2.GetValue().nMonth;
					else
						return false;
				}
			case CSchemaType::k_MonthDay:
				{
					CSchemaMonthDay md1( rObj1 );
					CSchemaMonthDay md2( rObj2 );
					if( md1.GetValue().HasTimezone() == md2.GetValue().HasTimezone() )
						return md1.GetValue().ApproximatedNormalizedDays() < md2.GetValue().ApproximatedNormalizedDays();
					else
						return false;
				}
			case CSchemaType::k_Day:
				{
					CSchemaDay day1( rObj1 );
					CSchemaDay day2( rObj2 );
					if( day1.GetValue().HasTimezone() == day2.GetValue().HasTimezone() )
						return day1.GetValue().nDay < day2.GetValue().nDay;
					else
						return false;
				}
			}

		}
	}
	catch(std::exception) {}

	// check binary-types
	try
	{
		const CSchemaBinaryBase* pBin1 = dynamic_cast<const CSchemaBinaryBase*>(pObj1);
		const CSchemaBinaryBase* pBin2 = dynamic_cast<const CSchemaBinaryBase*>(pObj2);
		if( pBin1  &&  pBin2 )
		{	// binary types
			if( pBin1->m_nSize == pBin2->m_nSize )
				return memcmp(pBin1->m_pData, pBin2->m_pData, pBin1->m_nSize ) < 0;
			return pBin1->m_nSize < pBin2->m_nSize;
		}
	}
	catch(std::exception) {}

	return (tstring)rObj1 < (tstring)rObj2;
}



 



} // namespace altova
