////////////////////////////////////////////////////////////////////////
//
// SchemaTypeString.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "Altova.h"
#include "AltovaException.h"
#include "SchemaTypeString.h"

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  CSchemaString
//
////////////////////////////////////////////////////////////////////////

CSchemaString::CSchemaString( const double nValue )
{	
	m_Value = ( tstring )CSchemaDecimal( nValue );
	SetIsEmpty( false );
}

[if $DBLibraryCount > 0 ]
CSchemaString::CSchemaString( const _variant_t& vValue ) 
{
	if( CheckContainsValue( vValue ) )
		m_Value = ( const TCHAR* )_bstr_t( vValue );
}
[endif]


bool CSchemaString::ToBool() const
{
	if( !CSchemaType::ToBool() )
		return false;

	if( m_Value.size() == 0  ||
		m_Value == _T("0")  ||		// Hack because of confuse boolean-value handling of XPATH 1.0
		m_Value == _T("false") )	//   --,,--
		return false;

	return true;
}


CSchemaString::operator tstring() const
{
	if( IsEmpty() )
		return _T("");
	return m_Value;
}


[if $DBLibraryCount > 0 ]
CSchemaString::operator _variant_t() const
{ 
	if( IsEmpty() )
		return _variant_t();
	return m_Value.c_str(); 
}
[endif]


void CSchemaString::Empty()
{
	CSchemaType::Empty();
	m_Value = _T("");
}


bool CSchemaString::Parse( const TCHAR* szValue )
{
	if( !CSchemaType::Parse( szValue ) )
		return false;

	m_Value = szValue;
	SetIsEmpty( 0==m_Value.size() );

	return !IsEmpty();
}


CSchemaType& CSchemaString::Assign( const CSchemaType& rOther )
{
	if( CSchemaType::Assign( rOther ).IsEmpty() )
		return *this;

	m_Value = ( tstring )rOther;
	SetIsEmpty( 0==m_Value.size() );

	return *this;
}


CSchemaType::ETypes CSchemaString::NumericType() const
{
	if( m_Value.size()==0 )
		return CSchemaType::k_unknown;
	
	TCHAR* szEndPtr;
	const TCHAR* szData = m_Value.c_str();

	// check if boolean
	if( m_Value == _T("true") || m_Value == _T("false") )
		return CSchemaType::k_bool;

	// check if integer 
	__int64 i64 = _ttoi64(szData);
	if( i64 > _I64_MAX )
		return CSchemaType::k_unsigned_long;
	if( i64 < _I32_MIN  ||
		i64 > _UI32_MAX )
		return CSchemaType::k_long;
	long i = _tcstol(szData, &szEndPtr, 10);
	if( *szEndPtr == 0 )
	{	
		if( i < 0 )
		{	// signed
			if( i >= SCHAR_MIN )
				return CSchemaType::k_byte;
			if( i >= SHRT_MIN )
				return CSchemaType::k_short;
			return CSchemaType::k_int;
		}
		else
		{	// unsigned
			if( i <= UCHAR_MAX )
				return CSchemaType::k_unsigned_byte;
			if( i <= USHRT_MAX )
				return CSchemaType::k_unsigned_short;
			return CSchemaType::k_unsigned_int;
		}
	}

	// check floating-point
	double d = _tcstod(szData, &szEndPtr);
	if( *szEndPtr == 0 )
	{
		return CSchemaType::k_double;
		// NOTE: float and decimal are missing here.
	}

	// it is not a number
	return CSchemaType::k_unknown;
}


long CSchemaString::ToLong() const
{
	if( IsEmpty() )
		return (long)CSchemaInt();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (long)CSchemaInt(m_Value.c_str());
}

__int64 CSchemaString::ToInt64() const
{
	if( IsEmpty() )
		return (__int64)CSchemaLong();
	if( m_Value == _T("false") )
		return 0;
	if( m_Value == _T("true") )
		return 1;
	return (__int64)CSchemaLong(m_Value.c_str());
}

float CSchemaString::ToFloat() const
{
	if( IsEmpty() )
		return (float)CSchemaFloat();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (float)CSchemaFloat(m_Value.c_str());
}

double CSchemaString::ToDouble() const
{
	if( IsEmpty() )
		return (double)CSchemaDouble();
	if( m_Value == _T("false") )
		return 0.0;
	if( m_Value == _T("true") )
		return 1.0;
	return (double)CSchemaDouble(m_Value.c_str());
}



CSchemaType::ETypes CSchemaString::CalendarType() const
{
	if( m_Value.size()==0 )
		return CSchemaType::k_unknown;
	
	try
	{
		CSchemaDateTime r = CSchemaDateTime(m_Value.c_str());
		return CSchemaType::k_DateTime;	
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDuration r = CSchemaDuration(m_Value.c_str());
		return CSchemaType::k_Duration;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDate r = CSchemaDate(m_Value.c_str());
		return CSchemaType::k_Date;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaTime r = CSchemaTime(m_Value.c_str());
		return CSchemaType::k_Time;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaYearMonth r = CSchemaYearMonth(m_Value.c_str());
		return CSchemaType::k_YearMonth;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaMonthDay r = CSchemaMonthDay(m_Value.c_str());
		return CSchemaType::k_MonthDay;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaDay r = CSchemaDay(m_Value.c_str());
		return CSchemaType::k_Day;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaMonth r = CSchemaMonth(m_Value.c_str());
		return CSchemaType::k_Month;
	}
	catch( CAltovaException e ) {};

	try
	{
		CSchemaYear r = CSchemaYear(m_Value.c_str());
		return CSchemaType::k_Year;
	}
	catch( CAltovaException e ) {};

	return CSchemaType::k_unknown;
}

CSchemaString::operator CSchemaTypeCalendar::CDate() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDate();
	return CSchemaDate( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDateTime() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDateTime();
	return CSchemaDateTime( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDay() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDay();
	return CSchemaDay( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CDuration() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CDuration();
	return CSchemaDuration( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CMonth() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CMonth();
	return CSchemaMonth( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CMonthDay() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CMonthDay();
	return CSchemaMonthDay( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CTime() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CTime();
	return CSchemaTime( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CYear() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CYear();
	return CSchemaYear( m_Value.c_str() );
}

CSchemaString::operator CSchemaTypeCalendar::CYearMonth() const
{
	if( IsEmpty() )
		return CSchemaTypeCalendar::CYearMonth();
	return CSchemaYearMonth( m_Value.c_str() );
}


[if $DBLibraryCount > 0]
_variant_t CSchemaString::CreateVariantByString(const TCHAR* szValue)
{
	// check if it is boolean
	if( _tcscmp(szValue, _T("false")) == 0 )
		return _variant_t(false);
	if( _tcscmp(szValue, _T("true")) == 0 )
		return _variant_t(true);

	CSchemaString	tmp(szValue);
	// check if it is a number
	switch( tmp.NumericType() )
	{
	case CSchemaType::k_unsigned_byte:	return _variant_t((unsigned char)CSchemaUnsignedByte(szValue));
	case CSchemaType::k_byte:
	case CSchemaType::k_short:			return _variant_t((short)CSchemaShort(szValue), VT_I2);
	case CSchemaType::k_unsigned_short:
	case CSchemaType::k_int:			return _variant_t((long)CSchemaInt(szValue), VT_I4);
	case CSchemaType::k_unsigned_int:
	case CSchemaType::k_unsigned_long:	// signed / unsigned mismatch			// unsigned __int64 only at VC71
	case CSchemaType::k_long:			return _variant_t((long)CSchemaLong(szValue)); // __int64 only at VC71
	case CSchemaType::k_float:			return _variant_t((float)CSchemaFloat(szValue));
	case CSchemaType::k_double:			return _variant_t((double)CSchemaDouble(szValue));
	case CSchemaType::k_unknown:
	default:
		// check if it is a calendar
		switch( tmp.CalendarType() )
		{
		case CSchemaType::k_Date:			return (CSchemaDateTime)CSchemaDate(szValue);
		case CSchemaType::k_DateTime:		return (CSchemaDateTime)CSchemaDateTime(szValue);
		case CSchemaType::k_Day:			return (CSchemaDateTime)CSchemaDay(szValue);
		case CSchemaType::k_Duration:		return (CSchemaDateTime)CSchemaDuration(szValue);
		case CSchemaType::k_Month:			return (CSchemaDateTime)CSchemaMonth(szValue);
		case CSchemaType::k_MonthDay:		return (CSchemaDateTime)CSchemaMonthDay(szValue);
		case CSchemaType::k_Time:			return (CSchemaDateTime)CSchemaTime(szValue);
		case CSchemaType::k_Year:			return (CSchemaDateTime)CSchemaYear(szValue);
		case CSchemaType::k_YearMonth:		return (CSchemaDateTime)CSchemaYearMonth(szValue);
		case CSchemaType::k_unknown:
		default:
			;// TODO - check if it is a binary-datatype
		}
	}
	return _variant_t(szValue);
}
[endif]



} // namespace altova

