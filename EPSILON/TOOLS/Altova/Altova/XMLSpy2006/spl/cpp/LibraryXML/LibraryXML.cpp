[create $BasePath & $module & ".cpp"
]////////////////////////////////////////////////////////////////////////
//
// [=$module].cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$module].h"

[if $domtype = 1 and $libtype <> 1 'if DLL
]#import "msxml4.dll" named_guids implementation_only
[endif
]
namespace [=$module]
{

[if $domtype = 1
]
void C[=$module]Doc::DeclareNamespaces(CNode& rNode)
{
[foreach $namespace in $namespaces
	if $namespace.URI <> ""
]	DeclareNamespace(rNode, _T("[=$namespace.PrefixCpp]"), _T("[=$namespace.URICpp]"));
[	endif
next
]}
[else]
void C[=$module]Doc::DeclareNamespaces(xercesc::DOMElement* pElement)
{
[foreach $namespace in $namespaces
	if $namespace.URI <> ""
]	DeclareNamespace(pElement, _T("[=$namespace.PrefixCpp]"), _T("[=$namespace.URICpp]"));
[	endif
next
]}
[endif]

} // end of namespace [=$module]
[
close

'----------------------------------------------------------------------

foreach $class in $classes : if not $class.IsInternal

	create $BasePath & $module & "_" & $class.Name & ".cpp"
]////////////////////////////////////////////////////////////////////////
//
// [=$module]_[=$class.Name].cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$module]Base.h"
#include "[=$module]_[=$class.Name].h"
[	foreach $member in $class.Members
		if $member.HasTypeObject]#include "[=$module]_[=$member.Type].h"
[		endif
	next
]


namespace [=$module]
{
[	if $class.NamespacePrefix <> ""
]namespace [=$class.NamespacePrefix][if $class.NamespaceURI <> ""] // URI: [=$class.NamespaceURI][endif]
{
[	endif
]////////////////////////////////////////////////////////////////////////
//
// class [=$class.Name]
//
////////////////////////////////////////////////////////////////////////


[
	if $class.IsComplexType
		$BaseIsComplex = $class.HasBaseObject and $class.BaseObject.IsComplexType
		if $class.IsComplexFromSimpleType
			if $class.HasSimpleBaseObject
				if $class.SimpleBaseObject.NamespacePrefix <> ""
					$QualifiedSimpleBase = $class.SimpleBaseObject.NamespacePrefix & "::" & $class.SimpleBaseObject.Name
				else
					$QualifiedSimpleBase = $class.SimpleBaseObject.Name
				endif
			else
				$QualifiedSimpleBase = $class.BuiltInBase
			endif
][=$class.Name]::[=$class.Name]([=$QualifiedSimpleBase] Value)
{
	InternalSetElementValue(Value);
}


[=$class.Name]::[=$class.Name](tstring Value)
{
	InternalSetElementValue(Value);
}


[=$class.Name]& [=$class.Name]::operator=(const [=$QualifiedSimpleBase]& Value)
{
	InternalSetElementValue(Value);
	return *this;
}


void [=$class.Name]::Assign(const [=$QualifiedSimpleBase]& Value)
{
	InternalSetElementValue(Value);
}

[		if $class.HasSimpleBaseObject
]void [=$class.Name]::Assign(const [=$class.SimpleBaseObject.BuiltInBase]& Value)
{
	Assign([=$QualifiedSimpleBase](Value));
}
[		endif
]
void [=$class.Name]::Parse(tstring Value)
{
	InternalSetElementValue(Value);
}


[=$class.Name]::operator tstring()
{
	return InternalGetElementValue();
}


[=$class.Name]::operator [=$QualifiedSimpleBase]()
{
	return [=$QualifiedSimpleBase](InternalGetElementValue().c_str());
}

[		endif
		if $class.IsMixed
]
[=$class.Name]::[=$class.Name](const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

[=$class.Name]& [=$class.Name]::operator=(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
	return *this;
}

void [=$class.Name]::Assign(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

[=$class.Name]::operator CSchemaString()
{
	return InternalGetElementValue();
}

[		endif
        if not $class.IsComplexFromSimpleType
]CNode::EGroupType [=$class.Name]::GetGroupType()
{
[			if $class.IsChoice
]	return eChoice;
[			else : if $class.IsAll
]	return eAll;
[			else
]	return eSequence;
[			endif : endif
]}
[		endif
		if $domtype = 2]
void [=$class.Name]::AdjustPrefix()
{
[			if $class.MemberCount > 0
]	[if $domtype = 1]MSXML2::IXMLDOMNodePtr[else]xercesc::DOMNode*[endif] pDOMNode;
[				foreach $member in $class.Members
					if $member.IsQualified
						$IsQualified = "true"
					else
						$IsQualified = "false"
					endif
					if $member.HasTypeObject
						if $member.TypeObject.NamespacePrefix <> ""
							$QualifiedType = $member.TypeObject.NamespacePrefix & "::" & $member.Type
						else
							$QualifiedType = $member.Type
						endif
					else
						$QualifiedType = $member.Type
					endif
]
	for(	pDOMNode = InternalGetFirstChild( [=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$member.SchemaNameCpp]") );
			pDOMNode != NULL;
			pDOMNode = InternalGetNextChild( [=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$member.SchemaNameCpp]"), pDOMNode ) 
		)
	{
		InternalAdjustPrefix(pDOMNode, [=$IsQualified]);
[					if $member.HasTypeObject and $member.TypeObject.IsComplexType
]		[=$QualifiedType](pDOMNode).AdjustPrefix();
[					endif
]	}
[
				next
			endif
			if $BaseIsComplex]
	[=$class.Base]::AdjustPrefix();
[				
			endif
]}
[		endif
 if $class.IsMixed
]
void [=$class.Name]::AddTextNode(CSchemaString text)
{
	InternalAppend(Text, _T(""), _T("#text"), text);
}

void [=$class.Name]::AddCDataNode(CSchemaString text)
{
	InternalAppend(CData, _T(""), _T("#cdata"), text);
}

void [=$class.Name]::AddComment(CSchemaString text)
{
	InternalAppend(Comment, _T(""), _T("#cdata"), text);
}

void [=$class.Name]::AddProcessingInstruction(CSchemaString name, CSchemaString text)
{
	InternalAppend(ProcessingInstruction, _T(""), name, text);
}
[endif

		foreach $member in $class.Members
			if $domtype = 1
				$QualifiedName = $member.XmlNameCpp
			else
				$QualifiedName = $member.SchemaNameCpp
			endif
			if $member.HasTypeObject
				if $member.TypeObject.NamespacePrefix <> ""
					$QualifiedType = $member.TypeObject.NamespacePrefix & "::" & $member.Type
				else
					$QualifiedType = $member.Type
				endif
			else
				$QualifiedType = $member.Type
			endif
]int [=$class.Name]::Get[=$member.Name]MinCount()
{
	return [=$member.MinOcc];
}


int [=$class.Name]::Get[=$member.Name]MaxCount()
{
	return [if $member.MaxOcc = -1]INT_MAX[else][=$member.MaxOcc][endif];
}


int [=$class.Name]::Get[=$member.Name]Count()
{
	return ChildCountInternal([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"));
}


bool [=$class.Name]::Has[=$member.Name]()
{
	return InternalHasChild([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"));
}


[			if $member.IsSimpleType
]void [=$class.Name]::Add[=$member.Name]([=$QualifiedType] Value)
{
	if( !Value.IsNull() )
		InternalAppend([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), Value);
}


void [=$class.Name]::Insert[=$member.Name]At([=$QualifiedType] Value, int nIndex)
{
	if( !Value.IsNull() )
		InternalInsertAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex, Value);
}


void [=$class.Name]::Replace[=$member.Name]At([=$QualifiedType] Value, int nIndex)
{
	InternalReplaceAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex, Value);
}
[			else
]void [=$class.Name]::Add[=$member.Name]([=$QualifiedType]& Value)
{
	InternalAppendNode(_T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), Value);
}


void [=$class.Name]::Insert[=$member.Name]At([=$QualifiedType]& Value, int nIndex)
{
	InternalInsertNodeAt(_T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex, Value);
}


void [=$class.Name]::Replace[=$member.Name]At([=$QualifiedType]& Value, int nIndex)
{
	InternalReplaceNodeAt(_T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex, Value);
}
[			endif
]

[if $domtype = 1]
[=$QualifiedType] [=$class.Name]::Get[=$member.Name]At(int nIndex)
{
[			if $member.IsSimpleType
]	return (LPCTSTR)InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex)->text;
	//return tstring((LPCTSTR)InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex)->text);
[			else
]	return [=$QualifiedType](*this, InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex));
[			endif
]}
[else]
[=$QualifiedType] [=$class.Name]::Get[=$member.Name]At(int nIndex)
{
[			if $member.IsSimpleType
]	return GetNodeTextValue(InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex)).c_str();
	//return InternalGetNodeValue([=$member.NodeType], InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex));
[			else
]	return [=$QualifiedType](InternalGetAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex));
[			endif
]}
[endif

if $domtype = 1]
MSXML2::IXMLDOMNodePtr [=$class.Name]::GetStarting[=$member.Name]Cursor()
{
	return InternalGetFirstChild([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"));
}

MSXML2::IXMLDOMNodePtr [=$class.Name]::GetAdvanced[=$member.Name]Cursor(MSXML2::IXMLDOMNodePtr pCurNode)
{
	return InternalGetNextChild([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), pCurNode);
}

[=$QualifiedType] [=$class.Name]::Get[=$member.Name]ValueAtCursor(MSXML2::IXMLDOMNodePtr pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else

[		if $member.IsSimpleType
]		return (LPCTSTR)pCurNode->text;
[		else
]		return [=$QualifiedType]( *this, pCurNode );
[	endif
]}
[else]
xercesc::DOMNode* [=$class.Name]::GetStarting[=$member.Name]Cursor()
{
	return InternalGetFirstChild([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"));
}

xercesc::DOMNode* [=$class.Name]::GetAdvanced[=$member.Name]Cursor(xercesc::DOMNode* pCurNode)
{
	return InternalGetNextChild([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), pCurNode);
}

[=$QualifiedType] [=$class.Name]::Get[=$member.Name]ValueAtCursor(xercesc::DOMNode* pCurNode)
{
	if( pCurNode == NULL )
		throw CXmlException(CXmlException::eError1, _T("Index out of range"));
	else
	{
[		if $member.IsSimpleType
]		if(pCurNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
		{
			xercesc::DOMNode* pChildNode = pCurNode->getFirstChild();
			if( !pChildNode )
				return _T("");
			
			if(pChildNode->getNodeValue())
				return XC2TS(pChildNode->getNodeValue());
			else
				return _T("");
		}
		else
		{
			if( pCurNode->getNodeValue() )
				return XC2TS(pCurNode->getNodeValue());
			else
				return _T("");
		}
[		else
]		return [=$QualifiedType](pCurNode);
[	endif
]	}
}
[endif]


[=$QualifiedType] [=$class.Name]::Get[=$member.Name]()
{
	return Get[=$member.Name]At(0);
}


void [=$class.Name]::Remove[=$member.Name]At(int nIndex)
{
	InternalRemoveAt([=$member.NodeType], _T("[=$member.NamespaceURICpp]"), _T("[=$QualifiedName]"), nIndex);
}


void [=$class.Name]::Remove[=$member.Name]()
{
[			if $member.MaxOcc > 1
]	Remove[=$member.Name]At(0);
[			else
]	while (Has[=$member.Name]())
		Remove[=$member.Name]At(0);
[endif
]}

[		next

	else : if $class.IsSimpleType
		if $class.Base = $class.BuiltInBase
			$IsDirectChild = true
		else
			$IsDirectChild = false
		endif
][=$class.Name]::[=$class.Name]() : [=$class.Base]()
{
	Validate();
}


[=$class.Name]::[=$class.Name]([=$class.BuiltInBase]::basetype Value) : [=$class.Base](Value)
{
	Validate();
}


[=$class.Name]::[=$class.Name](const [=$class.BuiltInBase]& Value) : [=$class.Base](Value)
{
	Validate();
}


[=$class.Name]::[=$class.Name](tstring Value) : [=$class.Base](Value.c_str())
{
	Validate();
}

#ifndef [=$class.BuiltInBase]_BASETYPE_LPCTSTR
[=$class.Name]::[=$class.Name](const TCHAR* Value) : [=$class.Base](Value)
{
	Validate();
}
#endif	//[=$class.BuiltInBase]_BASETYPE_LPCTSTR

[=$class.Name]& [=$class.Name]::operator=(const [=$class.BuiltInBase]& Value)
{ 
	Assign( Value ); 
	return *this; 
}

void [=$class.Name]::Validate()
{
	if( IsEmpty() )
		return;
[
		$BuiltInType = $class.BuiltInSchemaBase
		if $BuiltInType = "base64Binary" or $BuiltInType = "hexBinary"
			$InstanceLength = "(size_t) m_nSize"
		else
			$InstanceLength = "m_Value.size()"
		endif
		if $BuiltInType = "time" or $BuiltInType = "date" or $BuiltInType = "dateTime"
			$InstanceValue = "*this"
		else
			$InstanceValue = "m_Value"
		endif
		if $BuiltInType = "duration" or $BuiltInType = "gYear" or $BuiltInType = "gYearMonth" or $BuiltInType = "gMonth" or $BuiltInType = "gMonthDay" or $BuiltInType = "gDay"
			$AllowComparison = false
		else
			$AllowComparison = true
		endif

		foreach $facet in $class.Facets
			if $facet.IsMinLength
]	if ([=$InstanceLength] < GetMinLength())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsMaxLength
]	if ([=$InstanceLength] > GetMaxLength())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsLength
]	if ([=$InstanceLength] != GetLength())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsMinInclusive and $AllowComparison
]	if ([=$InstanceValue] < GetMinInclusive())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsMinExclusive and $AllowComparison
]	if ([=$InstanceValue] <= GetMinExclusive())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsMaxExclusive and $AllowComparison
]	if ([=$InstanceValue] >= GetMaxExclusive())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsMaxInclusive and $AllowComparison
]	if ([=$InstanceValue] > GetMaxInclusive())
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			else:if $facet.IsTotalDigits
			else:if $facet.IsFractionDigits
			else:if $facet.IsWhiteSpace
			else:if $facet.IsPattern
			else:if $facet.IsEnumeration
]	if (!IsValidEnumerationValue([=$class.Base]([=$InstanceValue])))
		throw CXmlException(CXmlException::eError1, _T("Validation error"));
[			endif:endif:endif:endif:endif:endif:endif:endif:endif:endif:endif:endif
		next
]}

[	foreach $facet in $class.Facets : if $facet.IsEnumeration
]
const TCHAR* [=$class.Name]::szEnumValues\[\] = {
[		foreach $enum in $facet.Enumeration
]	_T("[=$enum.ValueCpp]"),
[		next
]};

int [=$class.Name]::GetEnumerationCount()
{
	return EnumValueCount;
}

tstring [=$class.Name]::GetEnumerationValue(int nIndex)
{
	if (nIndex >= 0 && nIndex < EnumValueCount)
		return szEnumValues\[nIndex\];
	else
		return _T("");
}

bool [=$class.Name]::IsValidEnumerationValue(const tstring& sValue)
{
	for (int i = 0; i < EnumValueCount; i++)
	{
		if (sValue == szEnumValues\[i\])
			return true;
	}
	return false;
}
[		else : if $facet.IsPattern
]

const TCHAR* [=$class.Name]::szPatternValues\[\] = {
[		foreach $pattern in $facet.Pattern
]	_T("[=$pattern.ValueCpp]"),
[		next
]};

int [=$class.Name]::GetPatternCount()
{
	return sizeof(szPatternValues) / sizeof(szPatternValues\[0\]);
}

tstring [=$class.Name]::GetPatternValue(int nIndex)
{
	if (nIndex >= 0 && nIndex < GetPatternCount())
		return szPatternValues\[nIndex\];
	else
		return _T("");
}

[		endif : endif : next]
[	endif : endif
	if $class.NamespacePrefix <> ""
]} // end of namespace [=$class.NamespacePrefix]
[	endif
]} // end of namespace [=$module]
[
	close
endif : next
]
