//
// Core.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using Altova.Types;

namespace Altova.Functions
{
	public class Core
	{
		//public const int MAX_SCALE = 18;

		#region logical functions

		/// <summary> 
		/// result = logical-not( value )
		/// Logical bool "NOT" function, if value is true then result is false, otherwise true.
		/// </summary>
		public static SchemaBoolean LogicalNot(ISchemaType val ) 
		{
			return new SchemaBoolean( !val.BoolValue() );
		}

		/// <summary> 
		/// result = logical-or( value1, value2 )
		/// Logical bool "OR" function, if either values are true result is true, otherwise false.
		/// </summary>
		public static SchemaBoolean LogicalOr(ISchemaType value1, ISchemaType value2 ) 
		{
			return new SchemaBoolean( value1.BoolValue() || value2.BoolValue() );
		}

		/// <summary> 
		/// result = logical-and( value1, value2 )
		/// Logical bool "AND" function, if both values are true result is true, otherwise false.
		/// </summary>
		public static SchemaBoolean LogicalAnd(ISchemaType value1, ISchemaType value2 ) 
		{
			return new SchemaBoolean( value1.BoolValue() && value2.BoolValue() );
		}

		/// <summary> 
		/// result = string a Equal string b
		/// Result is true if string a == string b, otherwise false. Note that (null == null) is true
		/// </summary>
		public static SchemaBoolean Equal (SchemaString a, SchemaString b)
		{
			return new SchemaBoolean( a == b);
		}

		/// <summary> 
		/// result = a Equal b
		/// Result is true if a is Equal b, otherwise false.
		 /// </summary>
		public static SchemaBoolean Equal(ISchemaType a, ISchemaType b) 
		{
			if (IsNumber(a, b))
				return new SchemaBoolean(GetCommonNumberInstance(a,b).Equals(GetCommonNumberInstance(b, a)));
			if (Is_oneCalendar_oneString(a, b))
				return new SchemaBoolean(GetCommonCalendarInstance(a,b).Equals(GetCommonCalendarInstance(b, a)));
			return new SchemaBoolean( a.Equals(b) );
		}

		/// <summary> 
        /// result = a > b
        /// Result is true if a is Greater than b, otherwise false.
        /// </summary>
        /// 
        public static SchemaBoolean Greater(SchemaString a, SchemaString b)
        {
            return new SchemaBoolean(a.CompareTo(b) > 0);
        }
		
		/// <summary> 
		/// result = a > b
		/// Result is true if a is Greater than b, otherwise false.
		 /// </summary>
		public static SchemaBoolean Greater(ISchemaType a, ISchemaType b) 
		{
			if( IsNumber(a, b))
				return new SchemaBoolean(GetCommonNumberInstance(a,b).CompareTo(GetCommonNumberInstance(b, a)) > 0);
			if( Is_oneCalendar_oneString(a, b))
				return new SchemaBoolean(GetCommonCalendarInstance(a,b).CompareTo(GetCommonCalendarInstance(b, a)) > 0);
			return new SchemaBoolean( a.CompareTo( b ) > 0 );
		}

		/// <summary> 
		/// result = a < b
		/// Result is true if a is Less than b, otherwise false.
		 /// </summary>
        public static SchemaBoolean Less(SchemaString a, SchemaString b)
        {
            return new SchemaBoolean(a.CompareTo(b) < 0);
        }
		
		/// <summary> 
		/// result = a < b
		/// Result is true if a is Less than b, otherwise false.
		 /// </summary>
		public static SchemaBoolean Less(ISchemaType a, ISchemaType b) 
		{
			if( IsNumber(a, b))
				return new SchemaBoolean(GetCommonNumberInstance(a,b).CompareTo(GetCommonNumberInstance(b, a)) < 0);
			if( Is_oneCalendar_oneString(a, b))
				return new SchemaBoolean(GetCommonCalendarInstance(a,b).CompareTo(GetCommonCalendarInstance(b, a)) < 0);
			return new SchemaBoolean( a.CompareTo( b ) < 0 );
		}

		/// <summary> 
        /// result = logical-not( a Equal b )
        /// Result is true if a is not Equal b, otherwise false.
        /// </summary>
        public static SchemaBoolean NotEqual(SchemaString a, SchemaString b)
        {
            return new SchemaBoolean(!Equal(a, b).BoolValue());
        }
		
		/// <summary> 
		/// result = logical-not( a Equal b )
		/// Result is true if a is not Equal b, otherwise false.
		 /// </summary>
		public static SchemaBoolean NotEqual(ISchemaType a, ISchemaType b) 
		{
			return new SchemaBoolean( !Equal( a, b ).BoolValue() );
		}

		/// <summary> 
        /// result = a >= b
        /// Result is true if a is Equal or Greater than b, otherwise false.
        /// </summary>
        public static SchemaBoolean EqualOrGreater(SchemaString a, SchemaString b)
        {
            return new SchemaBoolean(!Less(a, b).BoolValue());
        }
		
		/// <summary> 
		/// result = a >= b
		/// Result is true if a is Equal or Greater than b, otherwise false.
		 /// </summary>
		public static SchemaBoolean EqualOrGreater(ISchemaType a, ISchemaType b) 
		{
			return new SchemaBoolean( !Less( a, b ).BoolValue() );
		}

		/// <summary> 
        /// result = a <= b
        /// Result is true if a is Equal or Less than b, otherwise false.
        /// </summary>
        public static SchemaBoolean EqualOrLess(SchemaString a, SchemaString b)
        {
            return new SchemaBoolean(!Greater(a, b).BoolValue());
        }
		
		/// <summary> 
		/// result = a <= b
		/// Result is true if a is Equal or Less than b, otherwise false.
		 /// </summary>
		public static SchemaBoolean EqualOrLess(ISchemaType a, ISchemaType b) 
		{
			return new SchemaBoolean( !Greater( a, b ).BoolValue() );
		}
		#endregion

		#region mathematical functions 

		/// <summary> 
		/// result = value1 + value2
		/// Result is the numeric value of adding value1 and value2.
		/// </summary>
		public static ISchemaTypeNumber Add(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() + value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() + value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( value1.DoubleValue() + value2.DoubleValue() );
			}
			return new SchemaDecimal( value1.DecimalValue() + value2.DecimalValue() );
		}

		/// <summary> 
		/// result = value1 - value2
		/// Result is the numeric value of subtracting value2 from value1.
		/// </summary>
		public static ISchemaTypeNumber Subtract(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() - value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() - value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( value1.DoubleValue() - value2.DoubleValue() );
			}
			return new SchemaDecimal(value1.DecimalValue() - value2.DecimalValue());
		}

		/// <summary> 
		/// result = value1 * value2
		/// Result is the numeric value of multiplying value1 with value2.
		/// </summary>
		public static ISchemaTypeNumber Multiply(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() * value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() * value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( value1.DoubleValue() * value2.DoubleValue() );
			}
			return new SchemaDecimal(value1.DecimalValue() * value2.DecimalValue() );
		}

		/// <summary> 
		/// result = floor( value )
		/// Result is the largest integer that is not Greater than the value.
		/// </summary>
		public static ISchemaTypeNumber Floor(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Floor( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Floor( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Floor( val.DoubleValue() ) );
			}
			return new SchemaDecimal( Decimal.Floor( val.DecimalValue() ) );
		}

		/// <summary> 
		/// result = ceiling( value )
		/// Result is the smallest integer that is not Less than the val.
		/// </summary>
		public static ISchemaTypeNumber Ceiling(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Ceiling( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Ceiling( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Ceiling( val.DoubleValue() ) );
			}
			return new SchemaDecimal( Decimal.Floor( val.DecimalValue()+1.0M ) );
		}

		/// <summary> 
		/// result = round( value )
		/// Result is the rounding of the value to the nearest integer.
		/// </summary>
		public static ISchemaTypeNumber Round(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Round( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Round( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Round( val.DoubleValue() ) );
			}
			return new SchemaDecimal( Decimal.Round( val.DecimalValue(), 0) );
		}

		/// <summary> 
		/// result = value1 / value2
		/// Result is the numeric value of dividing value1 with value2.
		/// </summary>
		public static ISchemaTypeNumber Divide(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() / value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() / value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( value1.DoubleValue() / value2.DoubleValue() );
			}
			SchemaDecimal result = new SchemaDecimal( value1.DecimalValue() /  value2.DecimalValue() );
//			result.reduceScale();
			return result;
		}

		/// <summary> 
		/// result = value1 div value2
		/// Result is the numeric value of integer dividing value1 with value2.
		/// </summary>
		public static ISchemaTypeNumber DivideInteger(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() / value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() / value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( (long)value1.DoubleValue() / value2.DoubleValue() );
			}
			return new SchemaDecimal((decimal)(long)(value1.DecimalValue() / value2.DecimalValue()) );
		}

		/// <summary> 
		/// result = value1 mod value2
		/// Result is the numeric value of modulus value1 with value2.
		/// </summary>
		public static ISchemaTypeNumber Modulus(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() % value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() % value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( value1.DoubleValue() % value2.DoubleValue() );
			}
			return Subtract( value1, Multiply( DivideInteger( value1, value2 ) , new SchemaDecimal( value2.DecimalValue() )) );
		}
		#endregion

		#region string functions

		/// <summary> 
		/// result = concat( string1, string2 )
		/// Returns the concatenation of string1 and string2.
		/// </summary>
		public static SchemaString Concat(SchemaString string1, SchemaString string2 ) 
		{
			return new SchemaString( string1.Value + string2.Value );
		}

		/// <summary> 
		/// result = normalize-space( string )
		/// Removes leading and trailing spaces from the string.
		/// </summary>
		public static SchemaString NormalizeSpace(SchemaString str ) 
		{
			return new SchemaString( str.Value.Trim() );
		}

		/// <summary> 
		/// result = starts-with( string, substr )
		/// Returns true if the string starts with the substr, otherwise it returns false.
		/// </summary>
		public static SchemaBoolean StartsWith(SchemaString str, SchemaString substr ) 
		{
			return new SchemaBoolean( str.Value.StartsWith( substr.Value ) );
		}

		/// <summary> 
		/// result = string-length( string )
		/// Returns the number of characters in the string.
		/// </summary>
		public static ISchemaTypeNumber StringLength(SchemaString str ) 
		{
			return new SchemaInt( str.Value.Length );
		}

		/// <summary> 
		/// result = substring( string, start \[,length\] )
		/// Returns part of the string, beginning at start with the length number of characters.
		/// </summary>
		public static SchemaString Substring(SchemaString str, ISchemaTypeNumber start, ISchemaTypeNumber length ) 
		{
			try 
			{
				int nStart = start.IntValue() - 1;
				int nLength = length.IntValue();
				if( nStart + nLength >= 0 )
				{
					if( nLength > 0 )
						return new SchemaString(str.Value.Substring(nStart, Math.Min(nLength, str.Value.Length - nStart)));
					else
						return new SchemaString(str.Value.Substring(nStart));
				}
				else
					return new SchemaString();
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString();
			}
		}

		/// <summary> 
		/// result = substring-after( string, substr )
		/// Returns the part of the string that occurs after the substr.
		/// </summary>
		public static SchemaString SubstringAfter(SchemaString str, SchemaString substr ) 
		{
			int position = str.Value.IndexOf( substr.Value );
			if( position >= 0 )
				return new SchemaString(str.Value.Substring(position +	substr.Value.Length));
			else
				return new SchemaString("");
		}

		/// <summary> 
		/// result = substring-before( string, substr )
		/// Returns the part of the string that occurs before the substr.
		/// </summary>
		public static SchemaString SubstringBefore(SchemaString str, SchemaString substr ) 
		{
			int position = str.Value.IndexOf( substr.Value );
			if( position >= 0 )
				return new SchemaString(str.Value.Substring(0, position));
			else
				return new SchemaString("");
		}

		/// <summary> 
		/// result = translate( value, string1, string2 )
		/// Performs a character by character replacement. It looks in the value for characters contained in string1, and replaces each character for the one in the same position in the string2.
		/// </summary>
		public static SchemaString Translate(SchemaString val, SchemaString string1, SchemaString string2 ) 
		{
			string sResult = "";
			try 
			{
				for (int nPosition = 0; nPosition < val.Value.Length; nPosition++) 
				{
					string sActChar = val.Value.Substring(nPosition, 1);
					int nFindChar = string1.Value.IndexOf(sActChar);
					if (nFindChar < 0) 
					{
						sResult = sResult + sActChar;
					}
					else 
					{
						if (nFindChar < string2.Value.Length) 
						{
							sResult = sResult +
								string2.Value.Substring(nFindChar, 1);
						}
					}
				}
				return new SchemaString(sResult);
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString();
			}
		}

		/// <summary> 
		/// result = contains( value, substring )
		/// Returns true if the first argument string contains the second argument string; otherwise returns false.
		/// </summary>
		public static SchemaBoolean Contains(SchemaString val, SchemaString substr ) 
		{
			return new SchemaBoolean( val.Value.IndexOf( substr.Value ) >= 0 );
		}
		#endregion

		#region conversion functions

		/// <summary> 
		/// result = boolean( arg )
		/// Converts the value of arg to a boolean value.
		/// </summary>
		public static SchemaBoolean ToBoolean(ISchemaType a) 
		{
			return new SchemaBoolean( a );
		}

		/// <summary> 
		/// result = number( arg )
		/// Converts the value of arg to a number.
		/// </summary>
		public static ISchemaTypeNumber ToNumber(ISchemaType a) 
		{
			return new SchemaDecimal( a );
		}

		/// <summary> 
		/// result = string( arg )
		/// Converts the value of arg to a string.
		/// </summary>
		public static SchemaString ToString(ISchemaType a) 
		{
			return new SchemaString( a );
		}
		#endregion

		#region helpers
		protected static bool IsNumber(ISchemaType a) 
		{
			if( a is SchemaString )
				return ((SchemaString)a).IsValueNumeric();
			return( a is ISchemaTypeNumber );
		}

		protected static bool IsNumber(ISchemaType a, ISchemaType b) 
		{
			return( IsNumber(a) && IsNumber(b) );
		}

		protected static ISchemaTypeNumber GetCommonNumberInstance(int numericType, ISchemaTypeNumber a_value) 
		{
			switch( (ENumericTypes)numericType ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( a_value.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( a_value.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( a_value.DoubleValue() );
				case ENumericTypes.ValueDecimal:
					return new SchemaDecimal( a_value.DecimalValue() );
			}
			return null;
		}

		protected static ISchemaType GetCommonNumberInstance(ISchemaType a_value, ISchemaType b) 
		{
			ISchemaTypeNumber aNum = (ISchemaTypeNumber)a_value;
			ISchemaTypeNumber bNum = (ISchemaTypeNumber)b;
			return (ISchemaType)GetCommonNumberInstance( Math.Max( (int)aNum.NumericType(), (int)(bNum.NumericType())), aNum );
		}

		protected static bool IsCalendar(ISchemaType a) 
		{
			if(a is SchemaCalendarBase)
				return true;
			if(a is SchemaDuration)
				return true;
			return false;
		}

		protected static bool Is_oneCalendar_oneString(ISchemaType a, ISchemaType b) 
		{
			return (IsCalendar(a) && b is SchemaString) ||
				(IsCalendar(b) && a is SchemaString);
		}

		protected static ISchemaType GetCommonCalendarInstance(ISchemaType a_value, ISchemaType b) 
		{
			switch ((ECalendarTypes)Math.Max( (int)( (ISchemaTypeCalendar) a_value).CalendarType(),(int)( (ISchemaTypeCalendar) b).CalendarType())) 
			{
				case ECalendarTypes.Duration:
					return new SchemaDuration( ( (ISchemaTypeCalendar) a_value).DurationValue());
				case ECalendarTypes.DateTime:
					return new SchemaDateTime( ( (ISchemaTypeCalendar) a_value).DateTimeValue());
				case ECalendarTypes.Date:
					return new SchemaDate( ( (ISchemaTypeCalendar) a_value).DateValue());
				case ECalendarTypes.Time:
					return new SchemaTime( ( (ISchemaTypeCalendar) a_value).TimeValue());
			}
			throw new ValuesNotConvertableException(a_value, b);
		}
		#endregion
	}
}