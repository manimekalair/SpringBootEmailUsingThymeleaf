//
// Lang.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using System.Globalization;
using System.Collections;
using System.Text.RegularExpressions;
using Altova.Types;

namespace Altova.Functions 
{
	public class Lang
	{
		private static Hashtable _s_InstanceIDs = new Hashtable();

		#region logical functions
		/// <summary>
		/// result = logical-xor( value1, value2 )
		/// Logical bool "XOR" function, if values are different then result is true, otherwise false.
		/// </summary>
		public static SchemaBoolean LogicalXor(ISchemaType value1, ISchemaType value2 ) 
		{
			return new SchemaBoolean( value1.BoolValue() ^ value2.BoolValue() );
		}

		/// <summary> 
		/// result = value >= 0
		/// Result is true if value is positive (greater or equal zero), otherwise false.
		/// </summary>
		public static SchemaBoolean Positive(ISchemaTypeNumber val ) 
		{
			ISchemaType n0 = new SchemaInt( 0 );
			return new SchemaBoolean(GetCommonNumberInstance((ISchemaType)val,n0).CompareTo(GetCommonNumberInstance(n0, (ISchemaType)val)) >= 0);
		}

		/// <summary> 
		/// result = value < 0
		/// Result is true if value is negative (less than zero), otherwise false.
		/// </summary>
		public static SchemaBoolean Negative(ISchemaTypeNumber val ) 
		{
			return new SchemaBoolean( !Positive( val ).BoolValue() );
		}

		/// <summary> 
		/// result = numeric( value )
		/// Returns true if the given value is a number, otherwise false.
		/// </summary>
		public static SchemaBoolean Numeric(ISchemaType val ) 
		{
			return new SchemaBoolean( IsNumber(val) );
		}
		#endregion

		#region mathematical functions 
		/// <summary> 
		/// result = value1 div value2
		/// Result is the numeric value of integer dividing value1 with value2.
		/// </summary>
		public static ISchemaTypeNumber DivideInteger(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( value1.IntValue() / value2.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( value1.LongValue() / value2.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( (long)value1.DoubleValue() / value2.DoubleValue() );
			}
			return new SchemaDecimal((decimal)(long)(value1.DecimalValue() / value2.DecimalValue()) );
		}

		/// <summary> 
		/// result = -value
		/// Result is the numeric value of -value.
		/// </summary>
		public static ISchemaTypeNumber UnaryMinus(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( -val.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( -val.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( -val.DoubleValue() );
			}
			return new SchemaDecimal( -val.DecimalValue() );
		}

		/// <summary> 
		/// result = max( value1, value2 )
		/// Result is the numeric value of the largest value.
		/// </summary>
		public static ISchemaTypeNumber Max(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( Math.Max(value1.IntValue(), value2.IntValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( Math.Max(value1.LongValue(), value2.LongValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Max(value1.DoubleValue(), value2.DoubleValue() ) );
			}
			if( value1.DecimalValue() > value2.DecimalValue() )
				return new SchemaDecimal( value1.DecimalValue() );
			else
				return new SchemaDecimal( value2.DecimalValue() );
		}

		/// <summary> 
		/// result = min( value1, value2 )
		/// Result is the numeric value of the smallest value.
		/// </summary>
		public static ISchemaTypeNumber Min(ISchemaTypeNumber value1, ISchemaTypeNumber value2 ) 
		{
			switch( (ENumericTypes)Math.Max( (int)value1.NumericType(), (int)value2.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( Math.Min(value1.IntValue(), value2.IntValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( Math.Min(value1.LongValue(), value2.LongValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Min(value1.DoubleValue(), value2.DoubleValue() ) );
			}
			if( value1.DecimalValue() < value2.DecimalValue() )
				return new SchemaDecimal( value1.DecimalValue() );
			else
				return new SchemaDecimal( value2.DecimalValue() );
		}

		/// <summary> 
		/// result = pi()
		/// </summary>
		public static ISchemaTypeNumber Pi() 
		{
			return new SchemaDecimal( Math.PI );
		}

		/// <summary> 
		/// result = sin(value)
		/// Result is the trigonometric sine of the angle given by value. The unit of value is radian.
		/// </summary>
		public static ISchemaTypeNumber Sin(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Sin( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Sin( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Sin(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Sin( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = cos(value)
		/// Result is the trigonometric cosine of the angle given by value. The unit of value is radian.
		/// </summary>
		public static ISchemaTypeNumber Cos(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Cos( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Cos( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Cos(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Cos( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = tan(value)
		/// Result is the trigonometric tangent of the angle given by value. The unit of value is radian.
		/// </summary>
		public static ISchemaTypeNumber Tan(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Tan( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Tan( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Tan(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Tan( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = asin(value)
		/// Returns the arc sine of an angle, in the range of -pi/2 through pi/2.
		/// </summary>
		public static ISchemaTypeNumber Asin(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Asin( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Asin( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Asin(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Asin( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = acos(value)
		/// Returns the arc cosine of an angle, in the range of -pi/2 through pi/2.
		/// </summary>
		public static ISchemaTypeNumber Acos(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Acos( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Acos( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Acos(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Acos( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = atan(value)
		/// Returns the arc tangent of an angle, in the range of -pi/2 through pi/2.
		/// </summary>
		public static ISchemaTypeNumber Atan(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Atan( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Atan( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Atan(val.DoubleValue() ) );
			}
			return new SchemaDecimal( Math.Atan( val.DoubleValue() ) );
		}

		/// <summary> 
		/// result = radians(value)
		/// Converts an angle measured in degrees to an approximately equivalent angle measured in radians.
		/// </summary>
		public static ISchemaTypeNumber Radians(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)(val.DoubleValue()/180.0*Math.PI) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)(val.DoubleValue()/180.0*Math.PI) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( val.DoubleValue()/180.0*Math.PI );
			}
			return new SchemaDecimal( (val.DoubleValue()/180.0*Math.PI) );
		}

		/// <summary> 
		/// result = degrees(value)
		/// Converts an angle measured in radians to an approximately equivalent angle measured in degrees.
		/// </summary>
		public static ISchemaTypeNumber Degrees(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)( val.DoubleValue()/Math.PI*180.0 ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)( val.DoubleValue()/Math.PI*180.0 ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( val.DoubleValue()/Math.PI*180.0 );
			}
			return new SchemaDecimal(val.DoubleValue()/Math.PI*180.0);
		}

		/// <summary> 
		/// result = abs(value)
		/// Returns the absolute value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned.
		/// </summary>
		public static ISchemaTypeNumber Abs(ISchemaTypeNumber val ) 
		{
			if( Negative( val ).BoolValue() )
				return UnaryMinus( val );
			return GetCommonNumberInstance( (int)val.NumericType(), val );
		}

		/// <summary> 
		/// result = exp(value)
		/// Returns Euler's number e raised to the power of the value.
		/// </summary>
		public static ISchemaTypeNumber Exp(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Exp( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Exp( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Exp(val.DoubleValue() ) );
			}
			return new SchemaDecimal(Math.Exp( val.DoubleValue() ));
		}

		/// <summary> 
		/// result = log(value)
		/// Returns the natural logarithm (base e) of a value
		/// </summary>
		public static ISchemaTypeNumber Log(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Log( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Log( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Log(val.DoubleValue() ) );
			}
			return new SchemaDecimal(Math.Log( val.DoubleValue() ));
		}

		/// <summary> 
		/// result = log10(value)
		/// Returns the decimal logarithm (base 10) of a value.
		/// </summary>
		public static ISchemaTypeNumber Log10(ISchemaTypeNumber val ) 
		{
			switch (val.NumericType()) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Log10(val.DoubleValue()) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Log10(val.DoubleValue()) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Log10(val.DoubleValue() ) );
			}
			return new SchemaDecimal(Math.Log10(val.DoubleValue()) );
		}

		/// <summary> 
		/// result = a ^ b
		/// Returns the value of a raised to the power of b.
		/// </summary>
		public static ISchemaTypeNumber Pow(ISchemaTypeNumber a, ISchemaTypeNumber b ) 
		{
			switch( (ENumericTypes)Math.Max( (int)a.NumericType(), (int)b.NumericType()) ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Pow(a.DoubleValue(), b.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Pow(a.DoubleValue(), b.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Pow(a.DoubleValue(), b.DoubleValue() ) );
			}
			return new SchemaDecimal(Math.Pow( a.DoubleValue(), b.DoubleValue() ));
		}

		/// <summary> 
		/// result = random()
		/// Returns a value with a positive sign, greater than or equal to 0.0 and less than 1.0.
		/// Returned values are chosen pseudorandomly with (approximately) uniform distribution from that range.
		/// </summary>
		public static ISchemaTypeNumber Random() 
		{
			return new SchemaDecimal(new Random().NextDouble() );
		}

		/// <summary> 
		/// result = sqrt(value)
		/// Returns the correctly rounded positive square root of a value.
		/// </summary>
		public static ISchemaTypeNumber Sqrt(ISchemaTypeNumber val ) 
		{
			switch( val.NumericType() ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( (int)Math.Sqrt( val.DoubleValue() ) );
				case ENumericTypes.ValueLong:
					return new SchemaLong( (long)Math.Sqrt( val.DoubleValue() ) );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( Math.Sqrt(val.DoubleValue() ) );
			}
			return new SchemaDecimal(Math.Sqrt( val.DoubleValue()) );
		}

		#endregion 

		#region string functions

		/// <summary> 
		/// result = uppercase( string )
		/// Result is the uppercase version of all the characters in the string.
		/// </summary>
		public static SchemaString Uppercase(SchemaString str ) 
		{
			return new SchemaString( str.Value.ToUpper() );
		}

		/// <summary> 
		/// result = lowercase( string )
		/// Result is the lowercase version of all the characters in the string.
		/// </summary>
		public static SchemaString Lowercase(SchemaString str ) 
		{
			return new SchemaString( str.Value.ToLower() );
		}

		/// <summary> 
		/// result = capitalize( value )
		/// Turns every first character of a word into upper-case letters.
		/// </summary>
		public static SchemaString Capitalize(SchemaString val ) 
		{
			string sResult = val.Value;
			int nPos = -1;
			while( true )
			{
				if( nPos < sResult.Length-1 ) 
				{
					sResult = sResult.Substring( 0, nPos+1 ) + sResult.Substring( nPos + 1, 1).ToUpper() + sResult.Substring( nPos+2, sResult.Length - nPos - 2);
				}
				nPos = sResult.IndexOf( " ", nPos + 1);
				if( nPos < 0 )
					break;
			}
			return new SchemaString( sResult );
		}

		/// <summary> 
		/// result = char-from-code( val )
		/// Returns a string with the character given by the numeric code.
		/// </summary>
		public static SchemaString CharFromCode(ISchemaTypeNumber val ) 
		{
			Char c = (char)val.IntValue();
			return new SchemaString( c.ToString() );
		}

		/// <summary> 
		/// result = code-from-char( val )
		/// Returns the numeric code of the first character given by the string val.
		/// </summary>
		public static ISchemaTypeNumber CodeFromChar(SchemaString val ) 
		{
			return new SchemaInt( (int)val.Value.ToCharArray(0,1)\[0\] );
		}

		/// <summary> 
		/// result = string-compare( string1, string2 )
		/// Performes a string comparation considering case of characters. Returns 0 if strings are equal. Returns -1 if string1 < string2. Returns +1 if string1 > string2.
		/// </summary>
		public static ISchemaTypeNumber StringCompare(SchemaString string1, SchemaString string2 ) 
		{
			return new SchemaInt( string1.Value.CompareTo( string2.Value) );
		}

		/// <summary> 
		/// result = string-compare-ignore-case( string1, string2 )
		/// Performes a string comparation ignoring the case of characters. Returns 0 if strings are equal. Returns -1 if string1 < string2. Returns +1 if string1 > string2.
		/// </summary>
		public static ISchemaTypeNumber StringCompareIgnoreCase(SchemaString string1, SchemaString string2 ) 
		{
			return new SchemaInt( string1.Value.ToUpper().CompareTo( string2.Value.ToUpper() ) );
		}

		/// <summary> 
		/// result = count-substring( string, substr )
		/// Returns the numer of times substr is contained inside string.
		/// </summary>
		public static ISchemaTypeNumber CountSubstring(SchemaString str, SchemaString substr ) 
		{
			int nPosition = str.Value.IndexOf( substr.Value );
			int nResult = 0;
			while( nPosition >= 0 ) 
			{
				nResult++;
				nPosition = str.Value.IndexOf( substr.Value, nPosition+1 );
			}
			return new SchemaInt( nResult );
		}

		/// <summary> 
		/// result = match-pattern( string, substr )
		/// Tells whether or not this string matches the given regular expression.
		/// </summary>
		public static SchemaBoolean MatchPattern(SchemaString str, SchemaString pattern ) 
		{
			try 
			{
				Regex regEx = new Regex( pattern.Value );
				return new SchemaBoolean( regEx.IsMatch( str.Value ) );
			}
			catch( ArgumentException )
			{
				return new SchemaBoolean( false );
			}
		}

		/// <summary> 
		/// result = find-substring( string, substr \[,startindex\] )
		/// Returns the index within the string of the first occurrence of the specified substring, starting at the specified index. The first character has index=1. If the substring was not found 0 is returned.
		/// </summary>
		public static ISchemaTypeNumber FindSubstring(SchemaString str, SchemaString substr, ISchemaTypeNumber startindex ) 
		{
			int nStart = startindex.IntValue();
			if( nStart > 0 )
				return new SchemaInt( str.Value.IndexOf( substr.Value, nStart-1)+1 );
			else
				return new SchemaInt( str.Value.IndexOf( substr.Value)+1 );
		}

		/// <summary> 
		/// result = reversefind-substring( string, substr \[,endindex\] )
		/// Returns the index within this string of the rightmost occurrence of the specified substring, starting at the specified index. The first character has index=0. If the substring was not found -1 is returned.
		/// </summary>
		public static ISchemaTypeNumber ReversefindSubstring(SchemaString str, SchemaString substr, ISchemaTypeNumber endindex ) 
		{
			int nLastPosition = -1;
			int nActPosition = str.Value.IndexOf( substr.Value );
			int nEndIndex = endindex.IntValue();
			if( nEndIndex < 0 )
				nEndIndex = str.ToString().Length;
			while( nActPosition > -1  &&  nActPosition < nEndIndex ) 
			{ // note: endindex is 1 based
				nLastPosition = nActPosition;
				nActPosition = str.Value.IndexOf( substr.Value, nActPosition+1 );
			}
			return new SchemaInt( nLastPosition+1 );
		}

		/// <summary> 
		/// result = left( string, number)
		/// Returns a string with the given number of characters on the left of the given string.
		/// </summary>
		public static SchemaString Left(SchemaString str, ISchemaTypeNumber number ) 
		{
			try 
			{
				return new SchemaString(str.Value.Substring(0, number.IntValue()));
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString( str );
			}
		}

		/// <summary> 
		/// result = left-trim( string )
		/// Removes whitespaces on the left end of the given string.
		/// </summary>
		public static SchemaString LeftTrim(SchemaString str ) 
		{
			String s = str.Value;
			int nPosition = 0;
			while( nPosition < s.Length && Char.IsWhiteSpace(s\[nPosition\] ) ) 
			{
				nPosition++;
			}
			try 
			{
				return new SchemaString(str.Value.Substring(nPosition, str.Value.Length - nPosition));
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString(str);
			}
		}

		/// <summary> 
		/// result = right( string, number)
		/// Returns a string with the given number of characters on the right side of the given string.
		/// </summary>
		public static SchemaString Right(SchemaString str, ISchemaTypeNumber number ) 
		{
			string s = str.Value;
			try 
			{
				return new SchemaString(s.Substring(s.Length - number.IntValue(),number.IntValue() ));
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString( str );
			}
		}

		/// <summary> 
		/// result = right-trim( string )
		/// Removes whitespaces on the right end of the given string.
		/// </summary>
		public static SchemaString RightTrim(SchemaString str ) 
		{
			String s = str.Value;
			int nPosition = s.Length;
			while( nPosition > 0 && Char.IsWhiteSpace(s\[nPosition-1\] ) )
			{
				nPosition--;
			}
			try 
			{
				return new SchemaString(s.Substring(0, nPosition));
			} 
			catch( ArgumentOutOfRangeException ) 
			{
				return new SchemaString( str );
			}
		}

		/// <summary> 
		/// result = replace( value, oldstring, newstring )
		/// Replaces each substring of this string that matches the given oldstring with the given newstring.
		/// </summary>
		public static SchemaString Replace(SchemaString val, SchemaString oldstring, SchemaString newstring ) 
		{
			string sResult = val.Value;
			int nPos = sResult.IndexOf( oldstring.Value );
			while( nPos >= 0 ) 
			{
				sResult = sResult.Substring( 0, nPos ) + newstring.Value + sResult.Substring( nPos+oldstring.Value.Length, sResult.Length - nPos - oldstring.Value.Length );
				nPos = sResult.IndexOf( oldstring.Value, nPos+newstring.Value.Length );
			}
			return new SchemaString( sResult );
		}

		/// <summary> 
		/// result = empty( value )
		/// Returns true if the string value is empty. Otherwise false is returned.
		/// </summary>
		public static SchemaBoolean Empty(SchemaString val) 
		{
			return new SchemaBoolean( val.Value.Length==0 );
		}

		/// <summary> 
		/// formated_guid = format-guid-string( unformated_guid )
		/// Formats a GUID correctly to use it in databases.
		/// </summary>
		public static SchemaString FormatGuidString(SchemaString val) 
		{
			string sGuid = val.ToString();
			if( sGuid.Length != 32 )
				return new SchemaString();		// input value is not correct

			string sBuffer;
			string sResult = "";
			for( int i=0; i<16; ++i )
			{
				sBuffer = sGuid.Substring( i*2, 2 );
				sResult += sBuffer;

				if( i==3 || i==5 || i==7 || i==9 )
					sResult += "-";		// format correctly because it is used as string.
			}

			return new SchemaString( sResult );
		}


		#endregion 

		#region datetime functions
		/// <summary> 
		/// result = datetime + duration
		/// Performs a addition of dates, times and durations.
		/// </summary>
		public static SchemaDateTime DatetimeAdd(SchemaDateTime datetime, SchemaDuration duration ) 
		{
			DateTime dt1 = datetime.Value;
			SchemaCalendarBase.ETZ eTZ = datetime.HasTimezone; // backup TZ settings because Calendar would overwrite it
			int offsetTZ = datetime.TimezoneOffset;
			dt1 = dt1.AddMilliseconds(duration.Value.Milliseconds );
			dt1 = dt1.AddSeconds(duration.Value.Seconds);
			dt1 = dt1.AddMinutes(duration.Value.Minutes);
			dt1 = dt1.AddHours(duration.Value.Hours);
			dt1 = dt1.AddDays(duration.Value.Days);
			dt1 = dt1.AddMonths(duration.Months);
			dt1 = dt1.AddYears(duration.Years);
			SchemaDateTime result = new SchemaDateTime(dt1);
			result.HasTimezone = eTZ;
			if( eTZ == SchemaCalendarBase.ETZ.Offset )
                result.TimezoneOffset = offsetTZ; // restore TZ settings
			return result;
		}

		/// <summary> 
		/// result = datetime1 - datetime2
		/// Result is the datetime value of subtracting datetime2 from datetime1.
		/// </summary>
		public static SchemaDuration DatetimeDiff(SchemaDateTime datetime1, SchemaDateTime datetime2 ) 
		{
			TimeSpan ts = datetime1.Value - datetime2.Value;
			SchemaDuration dur = new SchemaDuration( ts );
			return dur;
		}

		/// <summary> 
		/// result = datetime-from-parts( year, month, day \[, hour \[, minute \[, second \[, millisecond \[, timezone \]\]\]\]\])
		/// The result is the datetime value consisting of the parts given by year, month, day, hour, minute and second.
		/// </summary>
		public static SchemaDateTime DatetimeFromParts(ISchemaTypeNumber year, ISchemaTypeNumber month, ISchemaTypeNumber day, ISchemaTypeNumber hour /* optional */, ISchemaTypeNumber minute /* optional */, ISchemaTypeNumber second /* optional */, ISchemaTypeNumber millisecond /* optional */, ISchemaTypeNumber timezone /* optional */ ) 
		{
			SchemaDateTime result = new SchemaDateTime( year.IntValue(), month.IntValue(), day.IntValue(), hour.IntValue(), minute.IntValue(), second.IntValue(), millisecond.DoubleValue()/1000.0 );
			if( timezone.IntValue() >= -1440  &&  timezone.IntValue() <= 1440 )
			{
				result.TimezoneOffset = timezone.IntValue();
				result.HasTimezone = SchemaCalendarBase.ETZ.Offset;
			}
			return result;
		}

		/// <summary> 
		/// result = datetime-from-date-and-time( datevalue \[,timevalue\] )
		/// The result is the datetime value built of datevalue and timevalue.
		/// </summary>
		public static SchemaDateTime DatetimeFromDateAndTime(SchemaDate datevalue, SchemaTime timevalue /* optional */) 
		{
			if( timevalue.HasTimezone == SchemaCalendarBase.ETZ.Offset )
				return new SchemaDateTime( datevalue.Value.Year, datevalue.Value.Month, datevalue.Value.Day, timevalue.Value.Hour, timevalue.Value.Minute, timevalue.Value.Second, (double)timevalue.Value.Millisecond/1000.0 , timevalue.TimezoneOffset );

			SchemaDateTime result = new SchemaDateTime( datevalue.Value.Year, datevalue.Value.Month, datevalue.Value.Day, timevalue.Value.Hour, timevalue.Value.Minute, timevalue.Value.Second, (double)timevalue.Value.Millisecond/1000.0 );
			result.HasTimezone = timevalue.HasTimezone;

			return result;
		}

		/// <summary> 
		/// result = date-from-datetime( value )
		/// Returns the date-part of the given datetime value.
		/// </summary>
		public static SchemaDate DateFromDatetime( SchemaDateTime val ) 
		{
			return val.DateValue();
		}

		/// <summary> 
		/// result = time-from-datetime( value )
		/// Returns the time-part of the given datetime value.
		/// </summary>
		public static SchemaTime TimeFromDatetime( SchemaDateTime val ) 
		{
			return val.TimeValue();
		}

		/// <summary> 
		/// result = day( value )
		/// Returns the day of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber DayFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Day );
		}

		/// <summary> 
		/// result = now()
		/// Returns the actual date and time.
		/// </summary>
		public static SchemaDateTime Now() 
		{
			return SchemaDateTime.Now;
		}

		/// <summary> 
		/// result = hours( value )
		/// Returns the hours of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber HourFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Hour );
		}

		/// <summary> 
		/// result = holiday( value )
		/// Returns true if the given date is a holiday.
		/// </summary>
		public static SchemaBoolean Holiday(SchemaDateTime val ) 	// !!!!! implementation
		{
			return new SchemaBoolean( false );
		}

		/// <summary> 
		/// result = leapyear( value )
		/// Returns true if the given year of the date is a leapyear.
		/// </summary>
		public static SchemaBoolean Leapyear(SchemaDateTime val ) 
		{
			GregorianCalendar cal = new GregorianCalendar();
			return new SchemaBoolean( cal.IsLeapYear( val.Value.Year ) );
		}

		/// <summary> 
		/// result = milliseconds( value )
		/// Returns the milliseconds of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MillisecondFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Millisecond  );
		}

		/// <summary> 
		/// result = minutes( value )
		/// Returns the minutes of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MinuteFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Minute );
		}

		/// <summary> 
		/// result = month( value )
		/// Returns the month of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MonthFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Month );
		}

		/// <summary> 
		/// result = seconds( value )
		/// Returns the seconds of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber SecondFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Second );
		}

		/// <summary> 
		/// result = timezone( value )
		/// Returns the timezone of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber Timezone(SchemaDateTime val ) 
		{
			return new SchemaInt( val.TimezoneOffset );
		}

		/// <summary> 
		/// result = weekday( value )
		/// Returns the day of week of the given datetime value. Sunday=1, Monday=2,...
		/// </summary>
		public static ISchemaTypeNumber Weekday(SchemaDateTime val ) 
		{
			long a = (14-val.Value.Month)/12;
			long m = val.Value.Month + 12*a - 3;
			long y = val.Value.Year + 4800 - a;

			long JD = val.Value.Day + (153*m+2)/5 + y*365 + y/4 - y/100 + y/400 - 32045; // julian date
	
			return new SchemaInt( (int)(JD % 7 + 1) );
		}

		/// <summary> 
		/// result = weeknumber( value )
		/// Returns the number of the week within the year of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber Weeknumber(SchemaDateTime val ) 
		{
			long a = ( 14 - val.Value.Month ) / 12;
			long m = val.Value.Month + 12 * a - 3;
			long y = val.Value.Year + 4800 - a;

			long JD = val.Value.Day + (153 * m + 2) / 5 + y*365 + y/4 - y/100 + y/400 - 32045;
	
			long d4 = (JD+31741 - ( JD % 7 ) ) % 146097 % 36524 % 1461;
			long L = d4/1460;
			long d1 = ((d4-L) % 365) + L;

			return new SchemaInt( (int)(d1/7+1) );
		}

		/// <summary> 
		/// result = year( value )
		/// Returns the year of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber YearFromDatetime(SchemaDateTime val ) 
		{
			return new SchemaInt( val.Value.Year );
		}

		/// <summary> 
		/// result = duration1 + duration2
		/// Returns the addition of two durations.
		/// </summary>
		public static SchemaDuration DurationAdd(SchemaDuration duration1, SchemaDuration duration2) 
		{
			SchemaDuration dur = new SchemaDuration(duration1);
			dur.Years += duration2.Years;
			dur.Months += duration2.Months;
			dur.Value = dur.Value.Add( duration2.Value );
			if( dur.Value.Days > 31 )
			{
				dur.Years += dur.Value.Days / 31 / 12;
				dur.Months += (dur.Value.Days / 31) % 12;
				dur.Value = new TimeSpan(dur.Value.Days % 31, dur.Value.Hours, dur.Value.Minutes, dur.Value.Seconds, dur.Value.Milliseconds);
			}
			return dur;
		}

		/// <summary> 
		/// result = duration1 - duration2
		/// Returns the subtraction of two durations.
		/// </summary>
		public static SchemaDuration DurationSubtract(SchemaDuration duration1, SchemaDuration duration2) 
		{
			SchemaDuration dur = new SchemaDuration(duration1);
			dur.Years -= duration2.Years;
			dur.Months -= duration2.Months;
			dur.Value = dur.Value.Subtract( duration2.Value );
			return dur;
		}

		/// <summary> 
		/// result = duration-from-parts( year, month, day \[, hour \[, minute \[, second \[, millisecond\]\]\]\])
		/// The result is the datetime value consisting of the parts given by year, month, day, hour, minute and second.
		/// </summary>
		public static SchemaDuration DurationFromParts(ISchemaTypeNumber year, ISchemaTypeNumber month, ISchemaTypeNumber day, ISchemaTypeNumber hour /* optional */, ISchemaTypeNumber minute /* optional */, ISchemaTypeNumber second /* optional */, ISchemaTypeNumber millisecond /* optional */, SchemaBoolean negative /* optional */) 
		{
			SchemaDuration result = new SchemaDuration( year.IntValue(), month.IntValue(), day.IntValue(), hour.IntValue(), minute.IntValue(), second.IntValue(), millisecond.DoubleValue()/1000.0, negative.BoolValue() );
			return result;
		}

		/// <summary> 
		/// result = day( value )
		/// Returns the day of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber DayFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Value.Days );
		}

		/// <summary> 
		/// result = hours( value )
		/// Returns the hours of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber HourFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Value.Hours );
		}

		/// <summary> 
		/// result = milliseconds( value )
		/// Returns the milliseconds of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MillisecondFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Value.Milliseconds );
		}

		/// <summary> 
		/// result = minutes( value )
		/// Returns the minutes of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MinuteFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Value.Minutes );
		}

		/// <summary> 
		/// result = month( value )
		/// Returns the month of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber MonthFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt(  val.Months );
		}

		/// <summary> 
		/// result = seconds( value )
		/// Returns the seconds of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber SecondFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Value.Seconds );
		}

		/// <summary> 
		/// result = year( value )
		/// Returns the year of the given datetime value.
		/// </summary>
		public static ISchemaTypeNumber YearFromDuration(SchemaDuration val ) 
		{
			return new SchemaInt( val.Years );
		}

		#endregion 

		#region generator functions
		/// <summary> 
		/// result = auto-number( start_at, increase )
		/// Generates numbers automatically. On every call of this function it returns the actual-counter-value (starting at 'start_at') increased by the 'increase' value.
		///  'start_at' (default = 1) and 'increase' (default = 1) are optional.
		/// </summary>
		public static ISchemaTypeNumber AutoNumber( int nInstanceId, ISchemaTypeNumber startAt, ISchemaTypeNumber increase )
		{
			int nActNumber = startAt.IntValue();
			try
			{
				nActNumber = (int)_s_InstanceIDs\[nInstanceId\];
			}
			catch
			{ 
				_s_InstanceIDs.Add( nInstanceId, nActNumber );
			}
			_s_InstanceIDs\[nInstanceId\] = nActNumber + increase.IntValue();
			return new SchemaInt( nActNumber );
		}

		/// <summary>
		/// result = create-guid()
		/// Creates a global-unique-identifier as hexadecimal-encoded string.
		/// </summary>
		public static SchemaString CreateGuid()
		{
			return new SchemaString( Guid.NewGuid().ToString().Replace( "-", "" ) );
		}

		#endregion


		#region helpers
		protected static bool IsNumber(ISchemaType a) 
		{
			if( a is SchemaString )
				return ((SchemaString)a).IsValueNumeric();
			return( a is ISchemaTypeNumber );
		}

		protected static bool IsNumber(ISchemaType a, ISchemaType b) 
		{
			return( IsNumber(a) && IsNumber(b) );
		}

		protected static ISchemaTypeNumber GetCommonNumberInstance(int numericType, ISchemaTypeNumber a_value) 
		{
			switch( (ENumericTypes)numericType ) 
			{
				case ENumericTypes.ValueInt:
					return new SchemaInt( a_value.IntValue() );
				case ENumericTypes.ValueLong:
					return new SchemaLong( a_value.LongValue() );
				case ENumericTypes.ValueDouble:
					return new SchemaDouble( a_value.DoubleValue() );
				case ENumericTypes.ValueDecimal:
					return new SchemaDecimal( a_value.DecimalValue() );
			}
			return null;
		}

		protected static ISchemaType GetCommonNumberInstance(ISchemaType a_value, ISchemaType b) 
		{
			ISchemaTypeNumber aNum = (ISchemaTypeNumber)a_value;
			ISchemaTypeNumber bNum = (ISchemaTypeNumber)b;
			return (ISchemaType)GetCommonNumberInstance( Math.Max( (int)aNum.NumericType(), (int)(bNum.NumericType())), aNum );
		}

		protected static bool IsCalendar(ISchemaType a) 
		{
			if(a is SchemaCalendarBase)
				return true;
			if(a is SchemaDuration)
				return true;
			return false;
		}

		protected static bool Is_oneCalendar_oneString(ISchemaType a, ISchemaType b) 
		{
			return (IsCalendar(a) && b is SchemaString) ||
				(IsCalendar(b) && a is SchemaString);
		}

		protected static ISchemaType GetCommonCalendarInstance(ISchemaType a_value, ISchemaType b) 
		{
			switch ((ECalendarTypes)Math.Max( (int)( (ISchemaTypeCalendar) a_value).CalendarType(),(int)( (ISchemaTypeCalendar) b).CalendarType())) 
			{
				case ECalendarTypes.Duration:
					return new SchemaDuration( ( (ISchemaTypeCalendar) a_value).DurationValue());
				case ECalendarTypes.DateTime:
					return new SchemaDateTime( ( (ISchemaTypeCalendar) a_value).DateTimeValue());
				case ECalendarTypes.Date:
					return new SchemaDate( ( (ISchemaTypeCalendar) a_value).DateValue());
				case ECalendarTypes.Time:
					return new SchemaTime( ( (ISchemaTypeCalendar) a_value).TimeValue());
			}
			throw new ValuesNotConvertableException(a_value, b);
		}

		#endregion

	}
}