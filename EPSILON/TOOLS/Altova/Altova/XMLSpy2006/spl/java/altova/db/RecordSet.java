/**
 * RecordSet.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */


package com.altova.db;

import com.altova.types.*;
import java.util.Vector;


public abstract class RecordSet {
	protected java.sql.Connection connection;
	protected java.sql.ResultSet resultSet;
	protected java.sql.PreparedStatement statement;

	protected boolean	isReadAccess;
	protected Vector	commands;
	protected SchemaInt	mapforceDelRows;

	// construction and destruction
	public RecordSet(java.sql.Connection connection, boolean isReadAccess ) {
		this.connection = connection;
		this.resultSet = null;
		this.statement = null;

		this.isReadAccess = isReadAccess;
		this.commands = new Vector();
		this.mapforceDelRows = new SchemaInt( 0 );
	}

	public void close() {
		clearResultSet();
	}
	
	protected void finalize() {
		clearResultSet();
	}

	// accessors
	public java.sql.Connection getConnection() {
		return connection;
	}

	public Vector getCommands() {
		return commands;
	}

	public void setCommands( Vector commands ) {
		this.commands = commands;
	}

	public boolean hasResultSet() {
		return resultSet != null;
	}

	public int numberOfRowsToDelete() {
		return mapforceDelRows.intValue();
	}

	// overridables
	public abstract boolean next( boolean bClearIfEmpty ) throws java.sql.SQLException;

	public abstract void prepare( boolean bReadOnlyAccess );

	public abstract SchemaType getValueByName( String column );

	// operations
	public int execute( Vector commands ) throws DbExecuteException {
		if( commands != null  &&  commands.size() > 0 )
			this.commands = commands;
		int nRecordsAffected = 0;

		for( int index = 0; index < this.commands.size(); index++ )	{
			clearResultSet();

			// Prepare statement
			Command cmd = (Command)this.commands.elementAt( index );
			try {
				statement = connection.prepareStatement(
					 cmd.getStatement(),
					 java.sql.ResultSet.TYPE_FORWARD_ONLY,
					 java.sql.ResultSet.CONCUR_READ_ONLY );
			}
			catch( java.sql.SQLException e ) {
				throw new DbExecuteException( DbExecuteException.PREPARE_COMMAND, cmd.getStatement(), e.getMessage() );
			}

			// add parameters
			try {
				for( int paramIndex = 0; paramIndex < cmd.parameters.size(); paramIndex++ )	{
					FieldValue param = (FieldValue)cmd.parameters.elementAt( paramIndex );
					if( param.isAutoUpdate ) {
						SchemaType val = getValueByName( param.value.toString() );
						val.prepareStatement( statement, paramIndex+1 );
					}
					else
						param.value.prepareStatement( statement, paramIndex+1 );
				}
			}
			catch( java.sql.SQLException e ) {
				throw new DbExecuteException( DbExecuteException.PREPARE_PARAMS, cmd.getStatement(), e.getMessage() );
			}

			// execute command and assign resultSet
			try {
				statement.execute();
				resultSet = statement.getResultSet();
			}
			catch( java.sql.SQLException e ) {
				throw new DbExecuteException( DbExecuteException.EXECUTE, cmd.getStatement(), e.getMessage() );
			}

			// calculate affected rows
			try {
				if( !isReadAccess )	{
					int nActRecordsAffected = ( next( false ) ? -1 : 0);
					if( statement.getUpdateCount()>0 && nActRecordsAffected <= 0 )
						nActRecordsAffected = statement.getUpdateCount();
					if( nActRecordsAffected == -1  ||  nRecordsAffected == -1 )
						nRecordsAffected = -1;
					else
						nRecordsAffected += nActRecordsAffected;

					if( cmd.isAutoReadFieldsIntoBuffer() )
						while( nextResultSet() )
							next( false );
				}
			}
			catch( java.sql.SQLException e ) {
				throw new DbExecuteException( DbExecuteException.GET_AFFECTED, cmd.getStatement(), e.getMessage() );
			}
		}
		return nRecordsAffected;
	}

	public boolean next() throws DbExecuteException {
		try {
			return next( true );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "get next result", e.getMessage() );
		}
	}

	public boolean nextResultSet() throws DbExecuteException {
		if( statement == null )
			return false;
		try {
			if( statement.getMoreResults() ) {
				resultSet = statement.getResultSet();
				return true;
			}
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.READ_NEXT_RESULT, "get next resultset", e.getMessage() );
		}
		clearResultSet();
		return false;
	}

	// internals
	protected void clearResultSet() {
		if( resultSet != null ) {
			try {
				resultSet.close();
			}
			catch ( java.sql.SQLException e ) {
			}
			resultSet = null;
		}

		if( this.statement != null )
		{
			try {
				this.statement.close();
			}
			catch( java.sql.SQLException e ) {
			}
			statement = null;
		}
	}

	protected SchemaString internalGetString(String name) throws DbExecuteException {
		try {
			return new SchemaString(resultSet.getString(name));
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.GET_COLUMN, name, e.getMessage() );
		}
	}
}
