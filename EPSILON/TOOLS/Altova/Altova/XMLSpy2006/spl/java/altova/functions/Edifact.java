/**
 * Edifact.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */
package com.altova.functions;

import java.math.BigDecimal;
import java.lang.String;
import java.lang.Character;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.GregorianCalendar;
import java.util.Hashtable;

import com.altova.types.*;
import com.altova.types.SchemaDate;

public class Edifact 
{

  // ---------- date / time functions ----------

  // result = autoformat( format, source )
  /* The result is the date / time / datetime value extracted from the coded source using the given format code.
   */
  public static SchemaString autoformat( SchemaString sValue, SchemaString sFormat ) {

	  SchemaTime time = Edifact.toTime( sValue, sFormat );
	  if( time != null ) return new SchemaString( time.toString() );

	  SchemaDate date = Edifact.toDate( sValue, sFormat );
	  if( date != null ) return new SchemaString( date.toString() );

	  SchemaDuration duration = Edifact.toDuration( sValue, sFormat );
	  if( duration != null ) return new SchemaString( duration.toString() );

	  SchemaDateTime datetime = Edifact.toDatetime( sValue, sFormat );
	  if( datetime != null ) return new SchemaString( datetime.toString() );

	  SchemaString result = null;

	  int i = 0;
	  char\[\] arrValue = sValue.toString().toCharArray();

	  switch( sFormat.intValue() )
	  {
			  // DDD
			  // Day's number within a specific year: D = Day.
		  case 107:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // WW
			  // Week's number within a specific year: W = Week.
		  case 108:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // MM
			  // Month's number within a specific year: M = Month.
		  case 109:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // DD
			  // Day's number within is a specific month: D = Day.
		  case 110:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // CC
			  // Century.
		  case 600:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // YY
			  // Calendar year: Y = Year.
		  case 601:
		  {
			  SchemaLong number = new SchemaLong( Y2KConvert.Year( Integer.parseInt( sValue.getValue() ) ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // CCYY
			  // Calendar year including century: C = Century; Y = Year.
		  case 602:
		  {
			  int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaLong number = new SchemaLong( Y2KConvert.Year( cc, yy ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // YYS
			  // Semester in a calendar year: Y = Year; S = Semester.
		  case 603:
		  {
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int s  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  // TODO: convert semester value
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( yy ), 6 * s, 1 );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // CCYYS
			  // Semester in a calendar year: C = Century; Y = Year; S = Semester.
		  case 604:
		  {
			  int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int s  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  // TODO: convert semester value
			  SchemaLong tdate = new SchemaLong( Y2KConvert.Year( cc, yy ) );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // CCYYQ
			  // Quarter in a calendar year: C = Century; Y = Year; Q = Quarter.
		  case 608:
		  {
			  int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int q  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( cc, yy ), 4 * q, 1 );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // YYMM
			  // Month within a calendar year: Y = Year; M = Month.
		  case 609:
		  {
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( yy ), mm, 1 );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // CCYYMM
			  // Month within a calendar year: CC = Century; Y = Year; M = Month.
		  case 610:
		  {
			  int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( cc, yy ), mm, 1 );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // YYMMA
			  // To specifiy a ten-day period within a month of a year (A = ten day period).
		  case 613:
		  {
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int a  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( yy ), mm, 10 * a );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // CCYYMMA
			  // To specifiy a ten-day period within a month of a year, including century  (A = ten day period).
		  case 614:
		  {
			  int cc = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int yy = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int mm = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int a  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  SchemaDate tdate = new SchemaDate( Y2KConvert.Year( cc, yy ), mm, 10 * a );
			  result = new SchemaString( tdate.toString() );
		  }
			  break;

			  // Day of the week
			  // Numeric representation of the day (Monday = 1).
		  case 813:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

			  // Working days
			  // Number of working days.
		  case 814:
		  {
			  SchemaLong number = new SchemaLong( Integer.parseInt( sValue.getValue() ) );
			  result = new SchemaString( number.toString() );
		  }
			  break;

		  default:
		  {
			  result = new SchemaString( sValue );
		  }
			  break;
	  }

	  return result;
  }

  // result = toTime( format, source )
  /* The result is the time value extracted from the coded source using the given format code.
   */
  public static SchemaTime toTime( SchemaString sValue, SchemaString sFormat ) {

	  SchemaTime result = null;

	  int hour = 0;
	  int minute = 0;
	  int seconds = 0;
	  int i = 0;

	  char\[\] arrValue = sValue.toString().toCharArray();

	  switch( sFormat.intValue() )
	  {
		  // HHMM
		  // Time without seconds: H = Hour; m = Minute.
		  case 401:
		  {
			  hour	 = Integer.parseInt( new String( arrValue, i, 2 ) ); i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaTime( hour, minute, 0, 0.0 );
		  }
		  break;

		  // HHMMSS
		  // Time with seconds: H = Hour; m = Minute; s = Seconds.
		  case 402:
		  {
			  hour	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result 	= new SchemaTime( hour, minute, seconds, 0.0 );
		  }
			  break;

		  // HHMMSSZZZ
		  // See 402 plus Z=Time zone.
		  case 404:
		  {
			  String tz;
			  hour		= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  tz		= new String( arrValue, i, arrValue.length - i );
			  result	= new SchemaTime( hour, minute, seconds, 0.0, TZConvert.Timezone(tz) );
		  }
		  break;

		  // MMMMSS
		  // Time without hours: m=minutes, s=seconds.
		  case 405:
		  {
			  minute	= Integer.parseInt( new String( arrValue, i, 4 ) );	i += 4;
			  seconds	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result 	= new SchemaTime( minute / 60, minute % 60, seconds, 0.0 );
		  }
		  break;

		  default:
		  {
		  }
		  break;
	  }

	  return result;
  }

  // result = toDate( format, source )
  /* The result is the date value extracted from the coded source using the given format code.
   */
  public static SchemaDate toDate( SchemaString sValue, SchemaString sFormat ) {

	  SchemaDate result = null;

	  int century = 0;
	  int year = 0;
	  int month = 0;
	  int week = 0;
	  int day = 0;
	  int i = 0;

	  char\[\] arrValue = sValue.toString().toCharArray();

	  switch( sFormat.intValue() )
	  {

			  // DDMMYY
		  case 2:
		  {
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result  = new SchemaDate( Y2KConvert.Year( year ), month, day );
		  }
			  break;

			  // MMDDYY
		  case 3:
		  {
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result  = new SchemaDate( Y2KConvert.Year( year ), month, day );
		  }
			  break;

			  // DDMMCCYY
		  case 4:
		  {
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result  = new SchemaDate( Y2KConvert.Year( century, year ), month, day );
		  }
			  break;


			  // CCYYMMB
			  // B=1:first half month, B=2:second half month.
		  case 6:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int B   = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  SchemaDate date = new SchemaDate( Y2KConvert.Year( century, year ), month, 1 );
			  SchemaDuration offset = new SchemaDuration( 0, 0, 15, 0, 0, 0, 0.0, false );
			  if( B == 2 ) date = Lang.datetimeAdd( date.dateTimeValue(), offset ).dateValue();
			  result = new SchemaDate( date );
		  }
			  break;

			  // CCYYMMW
			  // W=1-5 first week to fifth week in a month.
		  case 7:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  week    = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  SchemaDate baseDate = new SchemaDate( Y2KConvert.Year( century, year), month, 1 );
			  SchemaDuration days = new SchemaDuration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
			  result = new SchemaDate( Lang.datetimeAdd( baseDate.dateTimeValue(), days ).dateValue() );
		  }
			  break;

			  // CCYYMMDDS
			  // Shift within a calendar day: CC=century YY=year MM=month DD=day S=1-9 shift in a day.
		  case 8:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int s   = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  result  = new SchemaDate( Y2KConvert.Year( century, year ), month, day );
		  }
			  break;

			  // CCYYMMDDPP
			  // Time period within a calendar day: CC=century YY=year MM=month DD=day PP=00-99 time period.
		  case 9:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int pp  = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result  = new SchemaDate( Y2KConvert.Year( century, year ), month, day );
		  }
			  break;


			  // YYMMDD
			  // Calendar date: Y = Year; M = Month; D = Day.
		  case 101:
		  {
			  year   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month  = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDate( Y2KConvert.Year( year ), month, day );
		  }
			  break;

			  // CCYYMMDD
			  // Calendar date: C = Century ; Y = Year ; M = Month ; D = Day.
		  case 102:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year    = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month   = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day     = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result  = new SchemaDate( Y2KConvert.Year( century, year ), month, day );
		  }
			  break;

			  // YYWWD
			  // Calendar week day: Y = Year ; W = Week ; D = Day
			  // Week number 01 is always first week of January
			  // Day number 1 is always Monday.
		  case 103:
		  {
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  week = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day  = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;

			  SchemaDate baseDate = new SchemaDate( Y2KConvert.Year( year ), 1, 1 ); // 1st Jan.
			  SchemaDuration days = new SchemaDuration( 0, 0, (week-1) * 7, 0, 0, 0, 0.0, false );
			  SchemaDate date = new SchemaDate( Lang.datetimeAdd( baseDate.dateTimeValue(), days ).dateValue() );
			  SchemaDuration oneWeek = new SchemaDuration ( 0, 0, 7, 0, 0, 0, 0.0, false );
			  int weekNumber = 0;
			  do
			  {
				  weekNumber = Lang.weeknumber( date.dateTimeValue() ).intValue();
				  if( weekNumber < week )
				  {
					  date = Lang.datetimeAdd( date.dateTimeValue(), oneWeek ).dateValue();
				  }
			  }
			  while( weekNumber < week );

			  SchemaDuration dayOffset = new SchemaDuration( 0, 0, 0, 0, 0, 0, 0.0, false );
			  int weekDay = Lang.weekday( date.dateTimeValue() ).intValue();
			  date = Lang.datetimeAdd( date.dateTimeValue(), (new SchemaDuration( 0, 0, -1 * (weekDay-1), 0, 0, 0, 0.0, true ) ) ).dateValue();
			  date = Lang.datetimeAdd( date.dateTimeValue(), (new SchemaDuration( 0, 0, day-1, 0, 0, 0, 0.0, false ) ) ).dateValue();
			  result	= new SchemaDate( date );
		  }
			  break;

			  // YYDDD
			  // Calendar day: Y = Year ; D = Day
			  // January the first = Day 001
			  // Always start numbering the days of the year from January 1st through December 31st.
		  case 105:
		  {
			  year	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day		= Integer.parseInt( new String( arrValue, i, 3 ) );	i += 3;
			  SchemaDate baseDate = new SchemaDate( Y2KConvert.Year( year ), 1, 1 ); // January 1st
			  SchemaDuration days = new SchemaDuration( 0, 0, day-1, 0, 0, 0, 0.0, false );
			  result = new SchemaDate( Lang.datetimeAdd( baseDate.dateTimeValue(), days ).dateValue() );
		  }
			  break;

			  // MMDD
			  // Day of a month: M = Month; D = Day.
		  case 106:
		  {
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day		= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDate( 1, month, day );
		  }
			  break;

		  default:
		  {
		  }
			  break;
	  }
	  return result;
  }

  // result = toDatetime( format, source )
  /* The result is the datetime value extracted from the coded source using the given format code.
   */
  public static SchemaDateTime toDatetime( SchemaString sValue, SchemaString sFormat ) {

	  SchemaDateTime result = null;

	  int century = 0;
	  int year = 0;
	  int month = 0;
	  int day = 0;
	  int hour = 0;
	  int minute = 0;
	  int seconds = 0;
	  int i = 0;

	  char\[\] arrValue = sValue.toString().toCharArray();

	  switch( sFormat.intValue() )
	  {
			  // DDMMCCYYHHMM
		  case 5:
		  {
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		  }
		  break;

			  // CCYYMMDDTHHMM
			  // Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; T=Time designator; H=Hour; M=Minutes.
			  // The character \[T\] shall be used as time designator to indicate the start of the representation of the time.
			  // For example: 20010912T1433.
		  case 10:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  char T = arrValue\[ i\];	i += 1;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		  }
		  break;

			  // YYMMDDHHMM
			  // Calendar date including time without seconds: Y = Year; M = Month; D = Day; H = Hour; M = Minute.
		  case 201:
		  {
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( year), month, day, hour, minute, 0, 0.0 );
		  }
			  break;

			  // YYMMDDHHMMSS
			  // Calendar date including time with seconds: Y = Year; M = Month; D = Day; H = Hour; m = Minutes = Seconds.
		  case 202:
		  {
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( year), month, day, hour, minute, seconds, 0.0 );
		  }
			  break;

			  // CCYYMMDDHHMM
			  // Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; H=Hour; M=Minutes.
		  case 203:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0 );
		  }
			  break;

			  // CCYYMMDDHHMMSS
			  // Calendar date including time with seconds: C=Century;Y=Year; M=Month;D=Day;H=Hour;M=Minute;S=Second.
		  case 204:
		  {
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, seconds, 0.0 );
		  }
			  break;

			  // CCYYMMDDHHMMZHHMM
			  // Calendar date including time and time zone expressed in hours and minutes.
			  // ZHHMM = time zone given as offset from Coordinated Universal Time (UTC).
		  case 205:
		  {
			  int offsetH = 0;
			  int offsetM = 0;

			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  char s = arrValue\[ i \];	i += 1;
			  offsetH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  offsetM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int tz = ( offsetH * 60 + offsetM ) * ((s == '-') ? -1 : +1);
			  result = new SchemaDateTime( Y2KConvert.Year( century, year ), month, day, hour, minute, 0, 0.0, tz );
		  }
			  break;

			  // YYMMDDHHMMZZZ
			  // See 201 + Z = Time zone.
		  case 301:
		  {
			  String zone;
			  year	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  zone = new String( arrValue, i, arrValue.length - i );
			  result = new SchemaDateTime( Y2KConvert.Year( year), month, day, hour, minute, 0, 0.0, TZConvert.Timezone(zone) );
		  }
			  break;

			  // YYMMDDHHMMSSZZZ
			  // See 202 + Z = Time zone.
		  case 302:
		  {
			  String zone;
			  year	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  zone = new String( arrValue, i, arrValue.length - i );
			  result = new SchemaDateTime( Y2KConvert.Year( year), month, day, hour, minute, seconds, 0.0, TZConvert.Timezone(zone) );
		  }
			  break;

			  // CCYYMMDDHHMMZZZ
			  // See 203 plus Z=Time zone.
		  case 303:
		  {
			  String zone;
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  zone = new String( arrValue, i, arrValue.length - i );
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, 0, 0.0, TZConvert.Timezone(zone) );
		  }
			  break;

			  // CCYYMMDDHHMMSSZZZ
			  // See 204 plus Z=Time zone.
		  case 304:
		  {
			  String zone;
			  century = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  year = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  month	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  seconds = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  zone = new String( arrValue, i, arrValue.length - i );
			  result = new SchemaDateTime( Y2KConvert.Year( century, year), month, day, hour, minute, seconds, 0.0, TZConvert.Timezone(zone) );
		  }
			  break;

		  default:
		  {
		  }
		  break;
	  }
	  return result;
  }

  // result = toDuration( format, source )
  /* The result is the Duration value extracted from the coded source using the given format code.
   */
  public static SchemaDuration toDuration( SchemaString sValue, SchemaString sFormat ) {

	  SchemaDuration result = null;

	  int year = 0;
	  int month = 0;
	  int week = 0;
	  int day = 0;
	  int hour = 0;
	  int minute = 0;
	  int seconds = 0;
	  int i = 0;

	  char\[\] arrValue = sValue.toString().toCharArray();

	  switch( sFormat.intValue() )
	  {
			  // MMDDHHMM
			  // Month, day, hours, minutes; M = Month; D = Day; H = Hour; M = Minute.
		  case 305:
		  {
			  month = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDuration( 0, month, day, hour, minute, 0, 0.0, false );
		  }
			  break;

			  // DDHHMM
			  // Day, hours, minutes; D = Day; H = Hour; M = Minute.
		  case 306:
		  {
			  day = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDuration( 0, 0, day, hour, minute, 0, 0.0, false );
		  }
			  break;

			  // ZHHMM
			  // Offset from Coordinated Universal Time (UTC) where Z is plus (+) or minus (-).
		  case 406:
		  {
			  char s = arrValue\[ i \];	i += 1;
			  hour = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  minute = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  result = new SchemaDuration( 0, 0, 0, hour, minute, 0, 0.0, s == '-' );
		  }
			  break;

			  // HHMMHHMM
			  // Time span without seconds: H = Hour; m = Minute;.
		  case 501:
		  {
			  int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( 1, 1, 1, fromH, fromM, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( 1, 1, 1, toH, toM, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // HHMMSS-HHMMSS
			  // A period of time specified by giving the start time
			  // followed by the end time (both expressed by hours
			  // minutes and seconds). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 502:
		  {
			  int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromS	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toS = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( 1, 1, 1, fromH, fromM, fromS, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( 1, 1, 1, toH, toM, toS, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // HHMMSSZZZ-HHMMSSZZZ
			  // A period of time specified by giving the start time
			  // followed by the end time (both expressed by hours
			  // minutes, seconds and time zone). Data is to be
			  // transmitted as consecutive characters without hyphen.
		  case 503:
		  {
			  String fromZ, toZ;

			  int fromH	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromS	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  fromZ	= new String( arrValue, i, 3 );	i += 3;
			  int toH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toS = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  toZ = new String( arrValue, i, 3 );	i += 3;
			  SchemaDateTime from = new SchemaDateTime( 1, 1, 1, fromH, fromM, fromS, 0.0, TZConvert.Timezone(fromZ) );
			  SchemaDateTime to	= new SchemaDateTime( 1, 1, 1, toH, toM, toS, 0.0, TZConvert.Timezone(toZ) );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // YY-YY
			  // A period of time specified by giving the start year
			  // followed by the end year (both without century). Data is
			  // to be transmitted as consecutive characters without
			  // hyphen.
		  case 701:
		  {
			  int fromY	= Y2KConvert.Year( Integer.parseInt( new String( arrValue, i, 2 ) ) );	i += 2;
			  int toY = Y2KConvert.Year( Integer.parseInt( new String( arrValue, i, 2 ) ) );	i += 2;
			  result = new SchemaDuration( fromY < toY ? toY-fromY : fromY-toY, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // CCYY-CCYY
			  // A period of time specified by giving the start year
			  // followed by the end year (both including century). Data
			  // is to be transmitted as consecutive characters without hyphen.
		  case 702:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2  ) );	i += 2;
			  int from = Y2KConvert.Year( fromC, fromY );
			  int to = Y2KConvert.Year( toC, toY );
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // YYS-YYS
			  // A period of time specified by giving the start semester
			  // of a year followed by the end semester of a year (both
			  // not including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 703:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromS	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toS = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromY );
			  int to = Y2KConvert.Year( toY );
			  // TODO: calculate semester value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // CCYYS-CCYYS
			  // A period of time specified by giving the start semester
			  // of a year followed by the end semester of a year (both
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 704:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromS	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toS = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromC, fromY );
			  int to = Y2KConvert.Year( toC, toY );
			  // TODO: calculate semester value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // YYPYYP
			  // Format of period to be given without hyphen (P = period of 4 months).
		  case 705:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromP	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toP = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromY );
			  int to = Y2KConvert.Year( toY );
			  // TODO: calculate period value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // CCYYP-CCYYP
			  // Format of period to be given without hyphen (P = period of 4 months).
		  case 706:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromP	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toP = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromC, fromY );
			  int to = Y2KConvert.Year( toC, toY );
			  // TODO: calculate period value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // YYQ-YYQ
			  // A period of time specified by giving the start quarter
			  // of a year followed by the end quarter of year (both not
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 707:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromQ	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toQ = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromY );
			  int to = Y2KConvert.Year( toY );
			  // TODO: calculate quarter value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // CCYYQ-CCYYQ
			  // A period of time specified by giving the start quarter
			  // of a year followed by the end quarter of year (both
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 708:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromQ	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toQ = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int from = Y2KConvert.Year( fromC, fromY );
			  int to = Y2KConvert.Year( toC, toY );
			  // TODO: calculate quarter value
			  result = new SchemaDuration( from < to ? to-from : from-to, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // YYMM-YYMM
			  // A period of time specified by giving the start month of
			  // a year followed by the end month of a year (both not
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 709:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromY ), fromM, 1, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toY ), toM, 1, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // CCYYMM-CCYYMM
			  // A period of time specified by giving the start month of
			  // a year followed by the end month of a year (both
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 710:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromC, fromY ), fromM, 1, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toC, toY ), toM, 1, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // CCYYMMDD-CCYYMMDD
			  // Format of period to be given in actual message without
			  // hyphen.
			  // Note:
			  // 1. This code value will be removed effective with
			  // directory D.03B.
		  case 711:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // YYMMDDHHMM-YYMMDDHHMM
			  // A period of time specified by giving the start time
			  // followed by the end time (format year, month, day, hour
			  // and minute). Data is to be transmitted as consecutive
			  // characters without hyphen.
		  case 713:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromY ), fromM, fromD, fromTH, fromTM, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toY ), toM, toD, toTH, toTM, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // YYWW-YYWW
			  // A period of time specified by giving the start week of a
			  // year followed by the end week of year (both not
			  // including century). Data is to be transmitted as
			  // consecutive characters without hyphen.
		  case 715:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromW	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toW = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromY ), 1, 7 * fromW, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toY ), 1, 7 * toW, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // CCYYWW-CCYYWW
			  // A period of time specified by giving the start week of a
			  // year followed by the end week of year (both including
			  // century). Data is to be transmitted as consecutive
			  // characters without hyphen.
		  case 716:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromW	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toW = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromC, fromY ), 1, 7 * fromW, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toC, toY ), 1, 7 * toW, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // YYMMDD-YYMMDD
			  // A period of time specified by giving the start date
			  // followed by the end date (both not including century).
			  // Data is to be transmitted as consecutive characters
			  // without hyphen.
		  case 717:
		  {
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toY ), toM, toD, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // CCYYMMDD-CCYYMMDD
			  // A period of time specified by giving the start date
			  // followed by the end date (both including century). Data
			  // is to be transmitted as consecutive characters without
			  // hyphen.
		  case 718:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from	= new SchemaDateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, 0, 0, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toC, toY ), toM, toD, 0, 0, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // CCYYMMDDHHMM-CCYYMMDDHHMM
			  // A period of time which includes the century, year,
			  // month, day, hour and minute. Format of period to be
			  // given in actual message without hyphen.
		  case 719:
		  {
			  int fromC	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromY	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromM	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromD	= Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toC = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toY = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toD = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  SchemaDateTime from = new SchemaDateTime( Y2KConvert.Year( fromC, fromY ), fromM, fromD, fromTH, fromTM, 0, 0.0 );
			  SchemaDateTime to	= new SchemaDateTime( Y2KConvert.Year( toC, toY ), toM, toD, toTH, toTM, 0, 0.0 );
			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // DHHMM-DHHMM
			  // Format of period to be given without hyphen (D=day of
			  // the week, 1=Monday; 2=Tuesday; ... 7=Sunday).
		  case 720:
		  {
			  int fromDOW = Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int fromTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int fromTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toDOW	= Integer.parseInt( new String( arrValue, i, 1 ) );	i += 1;
			  int toTH = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;
			  int toTM = Integer.parseInt( new String( arrValue, i, 2 ) );	i += 2;

			  fromDOW = ( fromDOW % 7 ) + 1;
			  toDOW	= ( toDOW % 7 ) + 1;

			  SchemaDateTime from = new SchemaDateTime(1, 1, 1, fromTH, fromTM, 0, 0.0 );
			  SchemaDuration oneday = new SchemaDuration( 0, 0, 1, 0, 0, 0, 0.0, false );
			  while( Lang.weekday( from ).intValue() != fromDOW )
				  from = Lang.datetimeAdd( from, oneday );

			  SchemaDateTime to = new SchemaDateTime( from.getYear(), from.getMonth(), from.getDay(), toTH, toTM, 0, 0.0 );
			  while( Lang.weekday( to ).intValue() != toDOW )
				  to = Lang.datetimeAdd( to, oneday );

			  result = Lang.datetimeDiff( to, from );
		  }
			  break;

			  // Year
			  // To indicate a quantity of years.
		  case 801:
		  {
			  year = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( year, 0, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Month
			  // To indicate a quantity of months.
		  case 802:
		  {
			  month = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, month, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Week
			  // To indicate a quantity of weeks.
		  case 803:
		  {
			  week = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, week * 7, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Day
			  // To indicate a quantity of days.
		  case 804:
		  {
			  day = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, day, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Hour
			  // To indicate a quantity of hours.
		  case 805:
		  {
			  hour = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, 0, hour, 0, 0, 0.0, false );
		  }
			  break;

			  // Minute
			  // To indicate a quantity of minutes.
		  case 806:
		  {
			  minute = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, 0, 0, minute, 0, 0.0, false );
		  }
			  break;

			  // Second
			  // To indicate a quantity of seconds.
		  case 807:
		  {
			  seconds = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, 0, 0, 0, seconds, 0.0, false );
		  }
			  break;

			  // Semester
			  // To indicate a quantity of semesters (six months).
		  case 808:
		  {
			  int semester = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, semester * 6, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Four months period
			  // To indicate a quantity of four months periods.
		  case 809:
		  {
			  int fourMonth = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, fourMonth * 4, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Trimester
			  // To indicate a quantity of trimesters (three months).
		  case 810:
		  {
			  int trimester = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, trimester * 3, 0, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Half month
			  // To indicate a quantity of half months.
		  case 811:
		  {
			  int halfMonth = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, halfMonth * 15, 0, 0, 0, 0.0, false );
		  }
			  break;

			  // Ten days
			  // To indicate a quantity of ten days periods.
		  case 812:
		  {
			  int tenDays = Integer.parseInt( sValue.getValue() );
			  result = new SchemaDuration( 0, 0, tenDays * 10, 0, 0, 0, 0.0, false );
		  }
			  break;

		  default:
		  {
		  }
			  break;
	  }

	  return result;
  }

	static class Y2KConvert
	{
		public static final int Year( int nYear )					{ return nYear > 50 ? 1900 + nYear : 2000 + nYear; }
		public static final int Year( int nCentury, int nYear )		{ return (nCentury * 100) + nYear; }
	};

	static class TZConvert
	{
		static class TimeZoneData
		{
			public String	sName;
			public float	dOffset;

			public TimeZoneData( String name, float offset )
			{
				sName = name;
				dOffset = offset;
			}
		}

		static TimeZoneData\[\] arrAbb =
			{
				new TimeZoneData("NST",+12.0f),	/* Pacific/Auckland */
				new TimeZoneData("SST",+11.0f),	/* Pacific/Guadalcanal */
				new TimeZoneData("AET",+10.0f),	/* Australia/Sydney */
				new TimeZoneData("ACT", +9.5f),	/* Australia/Darwin */
				new TimeZoneData("JST", +9.0f),	/* Asia/Tokyo */
				new TimeZoneData("CTT", +8.0f),	/* Asia/Shanghai */
				new TimeZoneData("VST", +7.0f),	/* Asia/Saigon */
				new TimeZoneData("BST", +6.0f),	/* Asia/Dacca */
				new TimeZoneData("IST", +5.5f),	/* Asia/Calcutta */
				new TimeZoneData("PLT", +5.0f),	/* Asia/Karachi */
				new TimeZoneData("NET", +4.0f),	/* Asia/Yerevan */
				new TimeZoneData("MET", +3.5f),	/* Asia/Tehran */
				new TimeZoneData("EAT", +3.0f),	/* Africa/Addis_Ababa */
				new TimeZoneData("EET", +2.0f),	/* Europe/Istanbul */
				new TimeZoneData("ART", +2.0f),	/* Africa/Cairo */
				new TimeZoneData("CAT", +2.0f),	/* Africa/Harare */
				new TimeZoneData("ECT", +1.0f),	/* Europe/Paris */
				new TimeZoneData("CET", +1.0f),	/* Europe/Paris */
				new TimeZoneData("GMT",  0.0f),	/* GMT */
				new TimeZoneData("UT",   0.0f),	/* GMT */
				new TimeZoneData("UTC",  0.0f),	/* GMT */
				new TimeZoneData("BET", -3.0f),	/* America/Sao_Paulo */
				new TimeZoneData("AGT", -3.0f),	/* America/Buenos_Aires */
				new TimeZoneData("CNT", -3.5f),	/* America/St_Johns */
				new TimeZoneData("PRT", -5.0f),	/* America/Puerto_Rico */
				new TimeZoneData("EST", -5.0f),	/* America/New_York */
				new TimeZoneData("IET", -5.0f),	/* America/Indianapolis */
				new TimeZoneData("CST", -6.0f),	/* America/Chicago */
				new TimeZoneData("MST", -7.0f),	/* America/Denver */
				new TimeZoneData("PNT", -7.0f),	/* America/Phoenix */
				new TimeZoneData("PST", -8.0f),	/* America/Los_Angeles */
				new TimeZoneData("MDT", -8.0f),	/* America/Boise */			/* Mountain Standard Time */
				new TimeZoneData("AST", -9.0f),	/* America/Anchorage */
				new TimeZoneData("PDT", -9.0f),	/* America/Dawson */		/* Pacific Standard Time */
				new TimeZoneData("HST",-10.0f),	/* Pacific/Honolulu */
				new TimeZoneData("TKT",-10.0f),	/* Pacific/Fakaofo */		/* Tokelau Time */
				new TimeZoneData("CKT",-10.0f),	/* Pacific/Rarotonga */		/* Cook Is. Time */
				new TimeZoneData("MIT",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("WST",-11.0f),	/* Pacific/Apia */
				new TimeZoneData("SST",-11.0f),	/* Pacific/Midway */		/* Samoa Standard Time */
				new TimeZoneData("NUT",-11.0f),	/* Pacific/Niue */			/* Niue Time */
			};

		public static TimeZoneData\[\] arrMil = new TimeZoneData\[\]
			{
				new TimeZoneData("Z", 0.0f), // Zulu Time ( UTC )
				new TimeZoneData("A", +1.0f), new TimeZoneData("B", +2.0f), new TimeZoneData("C", +3.0f), new TimeZoneData("D", +4.0f), new TimeZoneData("E", +5.0f), new TimeZoneData("F", +6.0f), new TimeZoneData("G", +7.0f), new TimeZoneData("H", +8.0f), new TimeZoneData("I", +9.0f), new TimeZoneData("K", +10.0f), new TimeZoneData("L", +11.0f), new TimeZoneData("M", +12.0f),
				new TimeZoneData("N", -1.0f), new TimeZoneData("O", -2.0f), new TimeZoneData("P", -3.0f), new TimeZoneData("Q", -4.0f), new TimeZoneData("R", -5.0f), new TimeZoneData("S", -6.0f), new TimeZoneData("T", -7.0f), new TimeZoneData("U", -8.0f), new TimeZoneData("V", -9.0f), new TimeZoneData("W", -10.0f), new TimeZoneData("X", -11.0f), new TimeZoneData("Y", -12.0f),
			};

		public static int Timezone( String sTimezone )
		{
			// Input Parameter:
			// coded tz value like "GMT", "Z" or "+10"
			// Return Value:
			// the corresponding timezone offset in MINUTES!
			// when the tz couldn't be found the return value is 0.
			// Possible formats for Timezone resolution:
			// - Hour offset from GMT (+/-HH)
			// - Three letter timezone code
			// - One letter millitary code (Z=UTC)

			// Pass 1:
			// check the length of the input string.
			// For single letter lookup the timezone offset from the tzMil array.
			if( sTimezone.length() == 1 )
			{
				for( int i=0; i < arrMil.length; ++i )
					if( sTimezone.compareToIgnoreCase( arrMil\[i\].sName ) == 0 )
						return (int)( 60 * arrMil\[i\].dOffset );
			}
			else
			{
				// Pass 2:
				// lookup the timezone offset from tzAbb array
				// all standard timezones and the offsets are recorded
				for( int i=0; i < arrAbb.length; ++i )
					if( sTimezone.compareToIgnoreCase( arrAbb\[i\].sName ) == 0 )
						return (int)( 60 * arrAbb\[i\].dOffset );

				try
				{
					int offset = Integer.parseInt(sTimezone);
					return offset * 60;
				}
				catch( NumberFormatException ex )
				{
					System.err.println("ERROR: cannot convert the given value (" + sTimezone + ") to a timezone offset");
				}
			}
			return 0;
		}
	}
}
