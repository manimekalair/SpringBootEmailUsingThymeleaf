/**
 * [=$node.Name]Type.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */


package [=$FullPackageName];

import com.altova.types.*;

[if $library.IsTree]
import com.altova.text.BaseType;
import com.altova.text.TextNode;
import com.altova.text.NullTextNode;
import com.altova.text.ITextNode;

// [=$node.Description]
[if $node.HasValueType
]public class [=$node.Name]Type extends [=$node.ValueType]
[else
]public class [=$node.Name]Type extends BaseType
[endif]{
[if $node.HasValueType]	ITextNode m_Node;
	public ITextNode getNode()
	{
		return m_Node;
	}

	public [=$node.Name]Type(ITextNode node) {
		[if $node.ValueType = "SchemaDecimal"]
		super(BaseType.MakeDecimal(node));
		[else]
		super( node.getValue());
		[endif]
		m_Node = node;
[call GenerateJavaNodePropertySetter($node)]
	}

	public [=$node.Name]Type([=$node.ValueType] value) {
		super(value);
		m_Node = new TextNode(NullTextNode.getInstance(), "[=$node.Name]");
		m_Node.setValue(value.isEmpty() ? "" : value.toString());
[call GenerateJavaNodePropertySetter($node)]
	}

[else
]	public [=$node.Name]Type(ITextNode node) {
		super(node);
[call GenerateJavaNodePropertySetter($node)]
	}
	public [=$node.Name]Type() {
		super(new TextNode(NullTextNode.getInstance(), "[=$node.Name]"));
[call GenerateJavaNodePropertySetter($node)]
	}
[endif
]

[	foreach $child in $node.Children
	$bFound= 0
	call NodeContainedInLibraryNodes($child, $bFound)
	if $bFound = 1]
	public boolean has[=$child.Name]() {
		return get[=$child.Name]Count() > 0;
	}

	public int get[=$child.Name]Count()	{
		[if $child.NameIndex = -1]
		return m_Node.getChildren().filterByName("[=$child.UserFriendlyName]").size();
		[else]
		if ([=$child.NameIndex]>m_Node.getChildren().filterByName("[=$child.NativeName]").size()) return 0;
		else return 1;
		[endif]
	}

	public [=$child.Name]Type get[=$child.Name]() {
		[if $child.NameIndex = -1]
		return get[=$child.Name]At( 0 );
		[else
		 $lNameIndex = $child.NameIndex - 1
		]
		return new [=$child.Name]Type(m_Node.getChildren().filterByName("[=$child.NativeName]").getAt([=$lNameIndex]));
		[endif]
	}

	public [=$child.Name]Type get[=$child.Name]At(int nIndex) {
		[if $child.NameIndex = -1]
		return new [=$child.Name]Type(m_Node.getChildren().filterByName("[=$child.UserFriendlyName]").getAt(nIndex));
		[else]
		return get[=$child.Name]();
		[endif]
	}

	[if $child.HasValueType]
	public void add[=$child.Name]([=$child.ValueType] rhs) {
		[=$child.Name]Type [=$child.Name] = new [=$child.Name]Type(rhs);
		m_Node.getChildren().add([=$child.Name].getNode());
	}
	[else 'child.HasValueType]
	public void add[=$child.Name]([=$child.Name]Type rhs) {
		m_Node.getChildren().add(rhs.getNode());
	}
	[endif
	endif 'bFound = 1
	next ' child
	
	if $library.ParseMode = 0 'EDI
]
	public static TextNode createStructureNode([if $node.Name<>$library.RootName]TextNode father[endif]) {
			[if $node.Name=$library.RootName]
			TextNode result= new TextNode(NullTextNode.getInstance(), "[=$node.Name]");
			[else]
			TextNode result= new TextNode(father, "[=$node.Name]");
			[endif
			foreach $child in $node.Children
			$bFound = 0
			call NodeContainedInLibraryNodes($child, $bFound)
			if $bFound = 1]
			TextNode kid[=$child.Name]= [=$child.Name]Type.createStructureNode(result);
			kid[=$child.Name].setPrecedingSeparators("[=$child.PrecedingSeparators]");
			kid[=$child.Name].setFollowingSeparators("[=$child.FollowingSeparators]");
			kid[=$child.Name].setPositionInFather([=$child.PositionInFather]);
			[endif '$bFound
			next 'child]
			return result;
	}
[endif
]}
[else '$library.IsTable
if $node.HasValueType]
public class [=$node.Name]Type extends [=$node.ValueType]
{
	public [=$node.Name]Type() {}
	public [=$node.Name]Type([=$node.ValueType] rhs) {
		super(rhs);
	}
	public [=$node.Name]Type(String rhs) {
		super(rhs);
	}
}
[else 'HasValueType]
import com.altova.text.tablelike.Record;
import com.altova.types.*;

[$kids= $node.Children]
public class [=$node.Name]Type extends Record
{
	public [=$node.Name]Type() {
		super([=$kids.Length]);
	}
	public [=$node.Name]Type(Record record)	{
		super(record);
	}
	[foreach $kid in $kids]
	public boolean has[=$kid.Name]() {
		return (null!=super.getAt([=$kid.Index]));
	}
	public int get[=$kid.Name]Count() {
		return (null!=super.getAt([=$kid.Index])) ? 1 : 0;
	}
	public [=$kid.Name]Type get[=$kid.Name]()	{
		return new [=$kid.Name]Type(super.getAt([=$kid.Index]));
	}
	public [=$kid.Name]Type get[=$kid.Name]At(int nIndex)	{
		return this.get[=$kid.Name]();
	}
	public void add[=$kid.Name]([=$kid.ValueType] rhs) {
		super.setAt([=$kid.Index], rhs.toString());
	}
	[next 'kid]
}
[endif 'HasValueType
endif ' Tree/Table]