/**
 * [=$library.UniqueName]Database.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */


package [=$FullPackageName];

import com.altova.types.*;
import com.altova.db.*;


public class [=$library.UniqueName]Database extends com.altova.db.Database {

	// construction
	public [=$library.UniqueName]Database(java.sql.Connection connection)  throws DbConnectionException {
		super(connection);
[if $library.HasAnyTransactions 
]		// Prepare for transaction processing
		try {
			conn.setTransactionIsolation( java.sql.Connection.TRANSACTION_READ_UNCOMMITTED ); // necessary to readback column values generated by DB
		}
		catch( java.sql.SQLException e ) {
			// some drivers may not provide this optional feature (f.e. Access) - go on and try without TRANSACTION_READ_UNCOMMITTED setting.
		}
		try {
			conn.setAutoCommit( false );
		}
		catch( java.sql.SQLException e ) {
			throw new DbConnectionException( DbConnectionException.OPEN, "database connection", e.getMessage() );
		}
[endif
if $library.OnOpenExecuteSQL <> ""
]		// database connection initialisation
		try {
			executeCommand( "[=$library.OnOpenExecuteSQL]" );
		}
		catch( java.sql.SQLException e ) {
			throw new DbConnectionException( DbConnectionException.INIT, "database connection", e.getMessage() );
		}
[endif
if $library.IsUseTransaction 
]		// transaction handling
		try {
			internalBeginTransaction();
			transactionCount++;
		}
		catch( DbExecuteException e ) {
			throw new DbConnectionException( DbConnectionException.INIT, "database connection", e.getMessage() );
		}
[endif
]	}

	// operations
	public void close()	 throws DbConnectionException {
[	if $library.IsUseTransaction
]		// transaction handling
		try	{
			if( !bRollbackTransaction )
				internalCommitTransaction();
			else
				internalRollbackTransaction();
			transactionCount--;
		}
		catch( DbExecuteException e )	{
			throw new DbConnectionException( DbConnectionException.FINALIZE, "database connection", e.getMessage() );
		}
[	endif
if $library.OnCloseExecuteSQL <> ""
]		// database connection finalisation
		try {
			executeCommand( "[=$library.OnCloseExecuteSQL]" );
		}
		catch( java.sql.SQLException e )	{
			throw new DbConnectionException( DbConnectionException.FINALIZE, "database connection", e.getMessage() );
		}
[endif
]
		try {
[if $library.HasAnyTransactions
]			conn.commit();
			conn.setAutoCommit( true );
[endif
]			conn.close();
		}
		catch( java.sql.SQLException e )	{
			throw new DbConnectionException( DbConnectionException.CLOSE, "database connection", e.getMessage() );
		}
	}

	// transaction handling
	protected void	internalBeginTransaction() throws DbExecuteException {
[	if not $library.IsMainTransactionViaSQL
]		try	{
			conn.commit();	// to start a new transaction commit all old statements
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "begin transaction", e.getMessage() );
		}
[	else : if $library.SQLBeginTransaction <> ""
]		try	{
			executeCommand( "[=$library.SQLBeginTransaction]" );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "begin transaction", e.getMessage() );
		}
[	endif : endif
]	}

	protected void	internalCommitTransaction() throws DbExecuteException {
[	if not $library.IsMainTransactionViaSQL
]		try	{
			conn.commit();
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "commit transaction", e.getMessage() );
		}
[	else : if $library.SQLCommitTransaction <> ""
]		try	{
			executeCommand( "[=$library.SQLCommitTransaction]" );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "commit transaction", e.getMessage() );
		}
[	endif : endif
]	}

	protected void	internalRollbackTransaction() throws DbExecuteException	{
[	if not $library.IsMainTransactionViaSQL
]		try	{
			conn.rollback();
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "rollback transaction", e.getMessage() );
		}
[	else : if $library.SQLRollbackTransaction <> ""
]		try	{
			executeCommand( "[=$library.SQLRollbackTransaction]" );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, "rollback transaction", e.getMessage() );
		}
[	endif : endif
]	}

	protected void	internalSetSavepoint( String sTransactionName ) throws DbExecuteException {
[	if $library.SQLSetSavepoint <> "" 
]		String sStatement = "[=$library.SQLSetSavepoint]";
		sStatement = sStatement.replaceFirst( " %%TRANSACTION_NAME%% ", sTransactionName );
		try	{
			executeCommand( sStatement );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, sStatement, e.getMessage() );
		}
[	endif
]	}

	protected void	internalRollbackToSavepoint( String sTransactionName ) throws DbExecuteException {
[	if $library.SQLRollbackToSavepoint <> "" 
]		String sStatement = "[=$library.SQLRollbackToSavepoint]";
		sStatement = sStatement.replaceFirst( " %%TRANSACTION_NAME%% ", sTransactionName );
		try	{
			executeCommand( sStatement );
		}
		catch( java.sql.SQLException e ) {
			throw new DbExecuteException( DbExecuteException.EXECUTE, sStatement, e.getMessage() );
		}
[	endif
]	}

	// queries
[foreach $table in $library.Tables]
	public [=$table.Name]Set get[=$table.Name]Table() throws java.sql.SQLException {
		return new [=$table.Name]Set(conn, internalGet("[=$table.DBLongEscapedName]"));
	}

	public [=$table.Name]Set get[=$table.Name]Table(String param) throws java.sql.SQLException {
		return new [=$table.Name]Set(conn, internalGet("[=$table.DBLongEscapedName]", param));
	}
[next
]}
