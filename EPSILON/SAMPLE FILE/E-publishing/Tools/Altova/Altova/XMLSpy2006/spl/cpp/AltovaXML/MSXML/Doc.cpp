////////////////////////////////////////////////////////////////////////
//
// Doc.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "../Altova/Altova.h"
#include "../Altova/SchemaTypes.h"
#include "XmlException.h"
#include "Doc.h"
#include "Node.h"
#import "msxml4.dll" named_guids implementation_only

namespace altova {


MSXML2::IXMLDOMDocument2Ptr			CDoc::m_spDocument			= NULL;
MSXML2::IXMLDOMDocumentFragmentPtr	CDoc::m_spFragment			= NULL;
int									CDoc::m_nTmpNameCounter	= 0;


MSXML2::IXMLDOMDocument2Ptr CDoc::GetDocument()
{
	if (m_spDocument == NULL)
	{
		m_spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument40));
		m_spDocument->async = VARIANT_FALSE;
		m_spDocument->setProperty(L"NewParser", true);
		m_spDocument->preserveWhiteSpace = VARIANT_TRUE;
	}
	return m_spDocument;
}


MSXML2::IXMLDOMNodePtr CDoc::CreateFragment()
{
	TCHAR szNumber\[32\] = _T("tmp");
	
	if (m_spFragment == NULL)
	{
		m_spFragment = GetDocument()->createDocumentFragment();
	}
	MSXML2::IXMLDOMNodePtr spNode = GetDocument()->createElement(szNumber);
	m_spFragment->appendChild( spNode );
	return spNode;
}


void CDoc::CheckDocumentCounter()
{
	if (m_spDocument)
	{
		m_spDocument->AddRef();
		if (m_spDocument->Release() == 1)
		{
			m_spFragment.Release();
			m_spDocument.Release();
		}
	}
}


MSXML2::IXMLDOMDocument2Ptr CDoc::Load(const tstring& sFilename)
{
	MSXML2::IXMLDOMDocument2Ptr spDocument;

	spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument40));
	spDocument->async = VARIANT_FALSE;
	spDocument->validateOnParse = VARIANT_FALSE;
	spDocument->preserveWhiteSpace = VARIANT_TRUE;
	spDocument->setProperty(L"NewParser", true);

	if (!spDocument->load(_variant_t(sFilename.c_str())))
	{
		MSXML2::IXMLDOMParseErrorPtr spError = spDocument->parseError;
		throw CXmlException(CXmlException::eError1, tstring(_T("Failed to load ")) + sFilename + _T(": ") + (LPCTSTR)spError->reason);
	}
	return spDocument;
}


MSXML2::IXMLDOMDocument2Ptr CDoc::LoadFromString(const tstring& sXml)
{
	MSXML2::IXMLDOMDocument2Ptr spDocument;

	spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument40));
	spDocument->async = VARIANT_FALSE;
	spDocument->validateOnParse = VARIANT_FALSE;
	spDocument->preserveWhiteSpace = VARIANT_TRUE;
	spDocument->setProperty(L"NewParser", true);

	if (!spDocument->loadXML(_bstr_t(sXml.c_str())))
	{
		MSXML2::IXMLDOMParseErrorPtr spError = spDocument->parseError;
		throw CXmlException(CXmlException::eError1, (LPCTSTR)spError->reason);
	}
	return spDocument;
}


void CDoc::SetEncoding(const tstring& sEncoding)
{
	m_sEncoding = sEncoding;
}


void CDoc::SetRootElementName(tstring sNamespaceURI, tstring sName)
{
	m_sName = sName;
	m_sNamespaceURI = sNamespaceURI;
}


void CDoc::SetSchemaLocation(const tstring& sSchemaLocation)
{
	m_sSchemaLocation = sSchemaLocation;
}

void CDoc::SetDTDLocation(const tstring& sDTDLocation)
{
	m_sDTDLocation = sDTDLocation;
}

void CDoc::Save(const tstring& sFilename, CNode& rNode)
{
	if (rNode.m_spNode->parentNode == NULL || rNode.m_spNode->parentNode->nodeTypeString == _bstr_t(L"documentfragment"))
	{
		FinalizeRootElement(rNode);
	}
	InternalSetSchemaLocation(rNode);

	rNode.m_spDocument->save(_variant_t(sFilename.c_str()));
}


tstring CDoc::SaveToString(CNode& rNode)
{
	if (rNode.m_spNode->parentNode == NULL || rNode.m_spNode->parentNode->nodeTypeString == _bstr_t(L"documentfragment"))
	{
		FinalizeRootElement(rNode);
	}
	InternalSetSchemaLocation(rNode);

	return (LPCTSTR)rNode.m_spDocument->xml;
}


void CDoc::Validate(CNode& rNode)
{

	if (rNode.m_spNode->parentNode->nodeTypeString == _bstr_t(L"documentfragment"))
	{
		FinalizeRootElement(rNode);
	}
	InternalSetSchemaLocation(rNode);

	MSXML2::IXMLDOMParseErrorPtr spError = rNode.m_spDocument->validate();
	if (spError->errorCode)
	{
		throw CXmlException(CXmlException::eError1, (LPCTSTR)spError->reason);
	}
}


void CDoc::FinalizeRootElement(CNode& rNode)
{
	if (m_sName.empty())
	{
		throw CXmlException(CXmlException::eError1, _T("Call SetRootElementName first"));
	}

	rNode.m_spDocument.CreateInstance(__uuidof(MSXML2::DOMDocument40));
	rNode.m_spDocument->async = VARIANT_FALSE;
	rNode.m_spDocument->preserveWhiteSpace = VARIANT_TRUE;
	rNode.m_spDocument->setProperty(L"NewParser", true);

	_bstr_t bsData = L"version='1.0' encoding='";
	if (m_sEncoding.empty())
		bsData += L"UTF-8";
	else
		bsData += m_sEncoding.c_str();
	bsData += L"'";
	rNode.m_spDocument->appendChild(rNode.m_spDocument->createProcessingInstruction(L"xml", bsData));

	rNode.m_spNode = rNode.InternalAppendNode(m_sNamespaceURI, m_sName, rNode, rNode.m_spDocument);
	MSXML2::IXMLDOMElementPtr spRootElement = rNode.m_spNode;

	spRootElement->setAttribute(L"xmlns:xsi", L"http://www.w3.org/2001/XMLSchema-instance");

	if (m_sNamespaceURI.empty())
	{
		if (!m_sSchemaLocation.empty())
			spRootElement->setAttribute(L"xsi:noNamespaceSchemaLocation", m_sSchemaLocation.c_str());
	}
	else
	{
		if (!m_sSchemaLocation.empty())
			spRootElement->setAttribute(L"xsi:schemaLocation", (m_sNamespaceURI + _T(" ") + m_sSchemaLocation).c_str());
	}

	DeclareNamespaces(rNode);
}


void CDoc::InternalSetSchemaLocation(CNode& rNode)
{
	MSXML2::IXMLDOMElementPtr spRootElement = rNode.m_spNode;

	if (m_sNamespaceURI.empty())
	{
		if (!m_sSchemaLocation.empty() && spRootElement->getAttributeNode(L"xsi:noNamespaceSchemaLocation") == NULL)
			spRootElement->setAttribute(L"xsi:noNamespaceSchemaLocation", m_sSchemaLocation.c_str());
	}
	else
	{
		if (!m_sSchemaLocation.empty() && spRootElement->getAttributeNode(L"xsi:schemaLocation") == NULL)
			spRootElement->setAttribute(L"xsi:schemaLocation", (m_sNamespaceURI + _T(" ") + m_sSchemaLocation).c_str());
	}
}


void CDoc::DeclareNamespace(CNode& rNode, const tstring& sPrefix, const tstring& sURI)
{
	rNode.DeclareNamespace(sPrefix, sURI);
}


} // namespace altova
