////////////////////////////////////////////////////////////////////////
//
// [=$module]Types.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef [=$module]Types_H_INCLUDED
#define [=$module]Types_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include "[=$module]API.h"
#include "../Altova/SchemaTypeString.h"
[if $library.IsTree]
#include "../AltovaText/BaseNode.h"

using namespace altova::text;
[else]
#include "../AltovaText/Record.h"

using namespace altova::text::tablelike;
using namespace altova;
[endif]

using namespace altova;

namespace [=$module]
{

//////////////////////////////////////////////////////////////////////////

[foreach $node in $library.Nodes]class C[=$node.Name]Type;
[next]

//////////////////////////////////////////////////////////////////////////
[foreach $node in $library.Nodes]

[if $library.IsTree
]
// [=$node.Description]
class [=$module]_DECLSPECIFIER C[=$node.Name]Type : public CBaseType[if $node.HasValueType], public [=$node.ValueType][endif]
{
public:
	// construction and destruction
	C[=$node.Name]Type();
	C[=$node.Name]Type(CTextNode& rhs);
	virtual ~C[=$node.Name]Type();

[if $node.HasValueType]
	C[=$node.Name]Type([=$node.ValueType] rhs);

[endif]
[foreach $child in $node.Children
 $bFound= 0
 call NodeContainedInLibraryNodes($child, $bFound)
 if $bFound = 1]
	bool Has[=$child.Name]() const;
	int Get[=$child.Name]Count() const;
	C[=$child.Name]Type Get[=$child.Name]() const;
	C[=$child.Name]Type Get[=$child.Name]At(int index) const;
	[if $child.HasValueType]
	void Add[=$child.Name]([=$child.ValueType] rhs);
	[else]
	void Add[=$child.Name](C[=$child.Name]Type& rhs);
	[endif
 endif '$bFound = 1
next

if $library.ParseMode = 0 ' EDI
]
	static CTextNode* CreateStructureNode(CTextNode& parent);
[endif]
};
[else ' $library.IsTable
if $node.HasValueType]
class [=$module]_DECLSPECIFIER C[=$node.Name]Type : public [=$node.ValueType]
{
public:
	C[=$node.Name]Type();
	C[=$node.Name]Type(const [=$node.ValueType]& rhs);
};
[else]
class [=$module]_DECLSPECIFIER C[=$node.Name]Type : public CRecord
{
public:
	C[=$node.Name]Type();
	C[=$node.Name]Type(const CRecord& rhs);
	C[=$node.Name]Type& operator= (const C[=$node.Name]Type& rhs);

[foreach $child in $node.Children]
	bool Has[=$child.Name]() const;
	int Get[=$child.Name]Count() const;
	void Add[=$child.Name](const C[=$child.Name]Type&);
	C[=$child.Name]Type Get[=$child.Name]();
	C[=$child.Name]Type Get[=$child.Name]At(int);
[next]
};
[endif ' HasValueType
endif ' Tree/Table
next ' node
]
} // namespace [=$module]


#endif // [=$module]Types_H_INCLUDED
