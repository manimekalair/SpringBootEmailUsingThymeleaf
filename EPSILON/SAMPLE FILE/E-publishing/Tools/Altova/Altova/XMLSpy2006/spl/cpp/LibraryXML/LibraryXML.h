[create $BasePath & $module & "Base.h"
]////////////////////////////////////////////////////////////////////////
//
// [=$module]Base.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef [=$module]Base_H_INCLUDED
#define [=$module]Base_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000


#ifndef _USRDLL
	#define [=$module]_DECLSPECIFIER
#else
	#ifdef [=$module]_EXPORTS
		#define [=$module]_DECLSPECIFIER __declspec(dllexport)
	#else
		#define [=$module]_DECLSPECIFIER __declspec(dllimport)
	#endif
#endif

// there's a #define small char somewhere in Microsoft's headers
#undef small

namespace [=$module]
{

class C[=$module]Doc;
/*
[
foreach $namespace in $namespaces
	if $namespace.ContainsPublicClasses and $namespace.Prefix <> ""
]
namespace [=$namespace.Prefix]
{
[	endif
	foreach $class in $namespace.Classes
		if not $class.IsInternal
]class [=$class.Name];
[
		endif
	next
	if $namespace.ContainsPublicClasses and $namespace.Prefix <> ""
]}
[
	endif
next
]
*/
[
foreach $class in $classes : if not $class.IsInternal
	if $class.NamespacePrefix <> ""
]namespace [=$class.NamespacePrefix][if $class.NamespaceURI <> ""] // URI: [=$class.NamespaceURI][endif]
{
[	endif
]class [=$class.Name];
[	if $class.NamespacePrefix <> ""
]}
[	endif
endif : next
]

////////////////////////////////////////////////////////////////////////

class [=$module]_DECLSPECIFIER C[=$module]Doc : public CDoc
{
protected:
	virtual void DeclareNamespaces([if $domtype = 1]CNode& rNode[else]xercesc::DOMElement* pElement[endif]);
};

} // end of namespace [=$module]

#endif // [=$module]Base_H_INCLUDED
[
close

'----------------------------------------------------------------------

create $BasePath & $module & ".h"

]////////////////////////////////////////////////////////////////////////
//
// [=$module].h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef [=$module]_H_INCLUDED
#define [=$module]_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

#include "[=$module]Base.h"

[
foreach $class in $classes : if not $class.IsInternal
]#include "[=$module]_[=$class.Name].h"
[
endif:next

if $HostShort <> "MapForce"
]
using namespace [=$module];
[
endif]
#endif // [=$module]_H_INCLUDED
[

close

'----------------------------------------------------------------------

foreach $class in $classes : if not $class.IsInternal

create $BasePath & $module & "_" & $class.Name & ".h"
]////////////////////////////////////////////////////////////////////////
//
// [=$module]_[=$class.Name].h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef [=$module]_[=$class.Name]_H_INCLUDED
#define [=$module]_[=$class.Name]_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

[
	call GenerateBaseClassIncludes($class)
]

namespace [=$module]
{
[
	if $class.NamespacePrefix <> ""
]
namespace [=$class.NamespacePrefix][if $class.NamespaceURI <> ""] // URI: [=$class.NamespaceURI][endif]
{
[
	endif
	if $class.IsComplexType
		$BaseIsComplex = $class.HasBaseObject and $class.BaseObject.IsComplexType

		if $BaseIsComplex
			if $class.BaseObject.NamespacePrefix <> ""
				$QualifiedBase = $class.BaseObject.NamespacePrefix & "::" & $class.Base
			else
				$QualifiedBase = $class.Base
			endif
		else
			$QualifiedBase = "CNode"
		endif
]

class [=$module]_DECLSPECIFIER [=$class.Name] : public [=$QualifiedBase]
{
public:
[		if $domtype = 1
]	[=$class.Name]() : [=$QualifiedBase]() {}
	[=$class.Name](CNode& rParentNode, MSXML2::IXMLDOMNodePtr spThisNode) : [=$QualifiedBase](rParentNode, spThisNode) {}
	[=$class.Name](MSXML2::IXMLDOMDocument2Ptr spDoc) : [=$QualifiedBase](spDoc) {}
[		else
]	[=$class.Name]() : [=$QualifiedBase]() {}
	[=$class.Name](xercesc::DOMNode* pThisNode) : [=$QualifiedBase](pThisNode) {}
	[=$class.Name](xercesc::DOMDocument* pDoc) : [=$QualifiedBase](pDoc) {}
	virtual ~[=$class.Name]() {}
[		endif
		if $class.IsComplexFromSimpleType
			if $class.HasSimpleBaseObject
				if $class.SimpleBaseObject.NamespacePrefix <> ""
					$QualifiedSimpleBase = $class.SimpleBaseObject.NamespacePrefix & "::" & $class.SimpleBaseObject.Name
				else
					$QualifiedSimpleBase = $class.SimpleBaseObject.Name
				endif
			else
				$QualifiedSimpleBase = $class.BuiltInBase
			endif
]
	[=$class.Name]([=$QualifiedSimpleBase] Value);
	[=$class.Name](tstring Value);
	[=$class.Name]& operator =(const [=$QualifiedSimpleBase]& Value);
	void Assign(const [=$QualifiedSimpleBase]& Value);
[			if $class.HasSimpleBaseObject
]	void Assign(const [=$class.SimpleBaseObject.BuiltInBase]& Value);
[			endif
]	virtual void Parse(tstring Value);
	virtual operator tstring();
	virtual operator [=$QualifiedSimpleBase]();
[		endif
		if $class.IsMixed
]
	[=$class.Name](const CSchemaString &Value);
	[=$class.Name]& operator =(const CSchemaString& Value);
	void Assign(const CSchemaString& Value);
	virtual operator CSchemaString();
[
		endif
        if not $class.IsComplexFromSimpleType
]	static EGroupType GetGroupType();
[
		endif
		if $domtype = 2
]	void AdjustPrefix();
[		endif
		foreach $member in $class.Members
			if $member.HasTypeObject
				if $member.TypeObject.NamespacePrefix <> ""
					$QualifiedType = $member.TypeObject.NamespacePrefix & "::" & $member.Type
				else
					$QualifiedType = $member.Type
				endif
			else
				$QualifiedType = $member.Type
			endif
]
	//
	// [=$member.SchemaType] [=$member.SchemaName][if $member.IsReference] reference[endif] ([=$member.MinOcc]...[if $member.MaxOcc = -1]unbounded[else][=$member.MaxOcc][endif])
	//
	static int Get[=$member.Name]MinCount();
	static int Get[=$member.Name]MaxCount();
	int Get[=$member.Name]Count();
	bool Has[=$member.Name]();
[			if $member.IsSimpleType
]	void Add[=$member.Name]([=$QualifiedType] [=$member.Name]);
	void Insert[=$member.Name]At([=$QualifiedType] [=$member.Name], int nIndex);
	void Replace[=$member.Name]At([=$QualifiedType] [=$member.Name], int nIndex);
[			else
]	void Add[=$member.Name]([=$QualifiedType]& [=$member.Name]);
	void Insert[=$member.Name]At([=$QualifiedType]& [=$member.Name], int nIndex);
	void Replace[=$member.Name]At([=$QualifiedType]& [=$member.Name], int nIndex);
[			endif
]	[=$QualifiedType] Get[=$member.Name]At(int nIndex);
	[=$QualifiedType] Get[=$member.Name]();
[if $domtype = 1 
]	MSXML2::IXMLDOMNodePtr GetStarting[=$member.Name]Cursor();
	MSXML2::IXMLDOMNodePtr GetAdvanced[=$member.Name]Cursor(MSXML2::IXMLDOMNodePtr pCurNode);
	[=$QualifiedType] Get[=$member.Name]ValueAtCursor(MSXML2::IXMLDOMNodePtr pCurNode);
[else
]	xercesc::DOMNode* GetStarting[=$member.Name]Cursor();
	xercesc::DOMNode* GetAdvanced[=$member.Name]Cursor(xercesc::DOMNode* pCurNode);
	[=$QualifiedType] Get[=$member.Name]ValueAtCursor(xercesc::DOMNode* pCurNode);
[endif
]
	void Remove[=$member.Name]At(int nIndex);
	void Remove[=$member.Name]();
[		next
 if $class.IsMixed
]	

	void AddTextNode(CSchemaString text);
	void AddCDataNode(CSchemaString text);
	void AddComment(CSchemaString text);
	void AddProcessingInstruction(CSchemaString name, CSchemaString text);
[endif
]};
[
	else : if $class.IsSimpleType
		$QualifiedBase = $class.Base
		if $class.Base = $class.BuiltInBase
			$IsDirectChild = true
		else
			$IsDirectChild = false
			if $class.HasBaseObject and $class.BaseObject.NamespacePrefix <> ""
				$QualifiedBase = $class.BaseObject.NamespacePrefix & "::" & $class.Base
			endif
		endif
]

class [=$module]_DECLSPECIFIER [=$class.Name] : public [=$QualifiedBase]
{
public:
	[=$class.Name]();
	[=$class.Name]([=$class.BuiltInBase]::basetype Value);
	[=$class.Name](const [=$class.BuiltInBase]& Value);
	[=$class.Name](tstring Value);
#ifndef [=$class.BuiltInBase]_BASETYPE_LPCTSTR
	[=$class.Name](const TCHAR* Value);
#endif	//[=$class.BuiltInBase]_BASETYPE_LPCTSTR
	/*virtual*/ [=$class.Name]& operator=(const [=$class.BuiltInBase]& Value);
	void Validate();
[		foreach $facet in $class.Facets
			if $facet.IsMinLength
]	virtual size_t GetMinLength() { return [=$facet.Constraint]; }
[			else : if $facet.IsMaxLength
]	virtual size_t GetMaxLength() { return [=$facet.Constraint]; }
[			else : if $facet.IsLength
]	virtual size_t GetLength() { return [=$facet.Constraint]; }
[			else : if $facet.IsMinInclusive
]	virtual [=$class.BuiltInBase] GetMinInclusive() { return _T("[=$facet.Constraint]"); }
[			else : if $facet.IsMinExclusive
]	virtual [=$class.BuiltInBase] GetMinExclusive() { return _T("[=$facet.Constraint]"); }
[			else : if $facet.IsMaxExclusive
]	virtual [=$class.BuiltInBase] GetMaxExclusive() { return _T("[=$facet.Constraint]"); }
[			else : if $facet.IsMaxInclusive
]	virtual [=$class.BuiltInBase] GetMaxInclusive() { return _T("[=$facet.Constraint]"); }
[			else : if $facet.IsTotalDigits
]	virtual int GetTotalDigits() { return [=$facet.Constraint]; }
[			else : if $facet.IsFractionDigits
]	virtual int GetFractionDigits() { return [=$facet.Constraint]; }
[			else : if $facet.IsWhiteSpace
				if $facet.Constraint = "preserve"
					$WhiteSpaceMode = "CSchemaType::WHITESPACE_PRESERVE"
				else : if $facet.Constraint = "replace"
					$WhiteSpaceMode = "CSchemaType::WHITESPACE_REPLACE"
				else
					$WhiteSpaceMode = "CSchemaType::WHITESPACE_COLLAPSE"
				endif : endif
]	int GetWhiteSpaceMode() { return [=$WhiteSpaceMode]; }
[			else : if $facet.IsPattern
]
	static const TCHAR* szPatternValues\[\];
	static int GetPatternCount();
	static tstring GetPatternValue(int nIndex);
[			else : if $facet.IsEnumeration
]
	static const TCHAR* szEnumValues\[\];
	typedef enum {
[				foreach $enum in $facet.Enumeration
]		[=$enum.Name] = [=$enum.Index], /* [=$enum.Value] */
[				next
]		EnumValueCount
	} EnumValues;

	static int GetEnumerationCount();
	static tstring GetEnumerationValue(int nIndex);
	static bool IsValidEnumerationValue(const tstring& sValue);
[			endif:endif:endif:endif:endif:endif:endif:endif:endif:endif:endif:endif
		next
]};
[	endif : endif
	if $class.NamespacePrefix <> ""
]

} // end of namespace [=$class.NamespacePrefix]
[	endif
]
} // end of namespace [=$module]

#endif // [=$module]_[=$class.Name]_H_INCLUDED
[
	close
endif : next
]