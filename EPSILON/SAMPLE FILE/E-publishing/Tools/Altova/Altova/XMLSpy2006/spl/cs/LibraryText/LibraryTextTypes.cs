//
// [=$module]Types.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using System.Collections;
using Altova.Types;

using Altova.TextParser;

[if $library.ParseMode = 0
	]using Altova.TextParser.EDIFACT;
[endif

if $library.ParseMode = 1]
using Altova.TextParser.TableLike;
using Altova.TextParser.TableLike.CSV;
[endif

if $library.ParseMode = 2]
using Altova.TextParser.TableLike;
using Altova.TextParser.TableLike.FLF;
[endif

if $library.ParseMode = 3
	]using Altova.TextParser.Flex;
[endif]

namespace [=$module]
{

[foreach $node in $library.Nodes]

[if $library.IsTree]
	// [=$node.Description]
	public class [=$node.Name]Type : BaseType
	{
		public [=$node.Name]Type(ITextNode node) : base(node)
		{
[call GenerateCSharpNodePropertySetter($node)]
		}
		public [=$node.Name]Type(IDataElement rhs) : base((rhs as BaseType).Node)
		{
[call GenerateCSharpNodePropertySetter($node)]
		}
		public [=$node.Name]Type() : base(new TextNode(NullTextNode.Instance, "[=$node.Name]"))
		{
[call GenerateCSharpNodePropertySetter($node)]
		}
		[if $node.HasValueType]	
		public [=$node.Name]Type([=$node.ValueType] rhs) : base(new TextNode(NullTextNode.Instance, "[=$node.Name]"))
		{
			Node.Value = rhs.ToString();
[call GenerateCSharpNodePropertySetter($node)]
		}
		public static implicit operator [=$node.ValueType]([=$node.Name]Type node) 
		{
			[if $node.ValueType = "SchemaDecimal"]
			return new [=$node.ValueType](BaseType.MakeDecimal(node.Node));
			[else]
			return new [=$node.ValueType](node.Node.Value);
			[endif]
		}
		[endif ' has value type]
		[foreach $child in $node.Children
		$bFound= 0
		call NodeContainedInLibraryNodes($child, $bFound)
		if $bFound = 1]
		public bool Has[=$child.Name]()
		{
			return Get[=$child.Name]Count() > 0;
		}

		public int Get[=$child.Name]Count()
		{
			[if $child.NameIndex = -1]
			return base.Node.Children.FilterByName("[=$child.UserFriendlyName]").Length;
			[else]
			if ([=$child.NameIndex]>base.Node.Children.FilterByName("[=$child.NativeName]").Length) return 0;
			else return 1;
			[endif]
		}

		public [=$child.Name]Type Get[=$child.Name]()
		{
			[if $child.NameIndex = -1]
			return Get[=$child.Name]At(0);
			[else
			 $lNameIndex = $child.NameIndex - 1
			]
			return new [=$child.Name]Type(base.Node.Children.FilterByName("[=$child.NativeName]")\[[=$lNameIndex]\]);
			[endif]
		}

		public [=$child.Name]Type Get[=$child.Name]At (int index)
		{
			[if $child.NameIndex = -1]
			return new [=$child.Name]Type( base.Node.Children.FilterByName("[=$child.UserFriendlyName]")\[index\] );
			[else]
			return Get[=$child.Name]();
			[endif]
		}
[if $CompatibilityMode <= "2005"    ' the property is not needed by MapForce but often collides with other names
]		public [=$child.Name]Type [=$child.Name]
		{
			get 
			{
				return Get[=$child.Name]();
			}
		}
[endif]
		[if $child.HasValueType]
		public void Add[=$child.Name]([=$child.ValueType] rhs) 
		{
			[=$child.Name]Type [=$child.Name] = new [=$child.Name]Type(rhs);
			Node.Children.Add([=$child.Name].Node);
		}
		[else 'child.HasValueType]
		public void Add[=$child.Name]([=$child.Name]Type rhs) 
		{
			Node.Children.Add(rhs.Node);
		}
		[endif
		endif 'bFound = 1
		next ' child
	if $library.ParseMode = 0]
		public static TextNode CreateStructureNode([if $node.Name<>$library.RootName]TextNode father[endif])
		{
			[if $node.Name=$library.RootName]
			TextNode result= new TextNode(NullTextNode.Instance, "[=$node.Name]");
			[else]		
			TextNode result= new TextNode(father, "[=$node.Name]");
			[endif
			foreach $child in $node.Children
			$bFound = 0
			call NodeContainedInLibraryNodes($child, $bFound)
			if $bFound = 1]
			TextNode kid[=$child.Name]= [=$child.Name]Type.CreateStructureNode(result);
			kid[=$child.Name].PrecedingSeparators= "[=$child.PrecedingSeparators]";
			kid[=$child.Name].FollowingSeparators= "[=$child.FollowingSeparators]";
			kid[=$child.Name].PositionInFather= [=$child.PositionInFather];
			[endif '$bFound
			next 'child]
			return result;
		}
[endif]	
	}
[else 'IsTable]
[if $node.HasValueType]
	public class [=$node.Name]Type : [=$node.ValueType]
	{
		public [=$node.Name]Type() {}
		public [=$node.Name]Type([=$node.ValueType] rhs) : base(rhs) {}
		public [=$node.Name]Type(string rhs) : base(rhs) {}
		public [=$node.Name]Type(IDataElement rhs) : base(rhs.Value) {}
	}
[else 'library IsTable]
	public class [=$node.Name]Type : Record
	{
		[$kids= $node.Children]
		public [=$node.Name]Type() : base([=$kids.Length]) {}
		public [=$node.Name]Type(Record record) : base(record) {}
		public [=$node.Name]Type(IDataElement rhs) : base(rhs) {}
		[foreach $child in $kids]
		public bool Has[=$child.Name]()
		{
			return (null!=base\[[=$child.Index]\]);
		}
		public int Get[=$child.Name]Count()
		{
			return (this.Has[=$child.Name]()) ? 1 : 0;
		}
		public [=$child.Name]Type Get[=$child.Name]()
		{
			return new [=$child.Name]Type(base\[[=$child.Index]\]);
		}
		public [=$child.Name]Type Get[=$child.Name]At(int index)
		{
			return this.Get[=$child.Name]();
		}
[if $CompatibilityMode <= "2005"    ' the property is not needed by MapForce but often collides with other names
]		public [=$child.Name]Type [=$child.Name]
		{
			get 
			{
				return Get[=$child.Name]();
			}
		}
[endif]
		public void Add[=$child.Name]([=$child.ValueType] rhs)
		{
			base\[[=$child.Index]\]= rhs.ToString();
		}
		[next 'child]
	}
[endif 'HasValueType]
[endif 'Tree/Table]
[next ' node]

} // namespace [=$module]
