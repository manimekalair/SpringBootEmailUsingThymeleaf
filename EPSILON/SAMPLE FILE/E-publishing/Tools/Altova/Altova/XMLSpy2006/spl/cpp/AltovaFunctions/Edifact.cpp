////////////////////////////////////////////////////////////////////////
//
// Edifact.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////

#include "StdAfx.h"
#include <Altova.h>
#include <SchemaTypes.h>
#include <AltovaException.h>
#include <SchemaTypeCalendar.h>
#include <SchemaTypeNumber.h>
#include <SchemaTypeString.h>
#include <SchemaTypeBinary.h>
#include "Edifact.h"
#include "Lang.h"	// datetime handling utility-functions
#include <math.h>
#include <time.h>

namespace altova {

//////////////////////////////////////////////////////////////////////////
namespace Convert
{
	int Year( int nYear )
	{
		return nYear > 50 ? 1900 + nYear : 2000 + nYear;
	}
	
	int Year( int nCentury, int nYear )
	{
		return (nCentury * 100) + nYear;
	}
	
	int Timezone( const TCHAR* szTimezone )
	{
		// Input Parameter:
		// coded tz value like "GMT", "Z" or "+10"
		// Return Value:
		// the corresponding timezone offset in MINUTES!
		// when the tz couldn't be found the return value is 0.
		// Possible formats for Timezone resolution:
		// - Hour offset from GMT (+/-HH)
		// - Three letter timezone code
		// - One letter millitary code (Z=UTC)

		struct TimeZoneData
		{
			TCHAR*	sName;
			float	dOffset;
		};

		static TimeZoneData tzAbb\[\] = 
		{
			{_T("NST"),+12.0},	/* Pacific/Auckland */
			{_T("SST"),+11.0},	/* Pacific/Guadalcanal */
			{_T("AET"),+10.0},	/* Australia/Sydney */
			{_T("ACT"), +9.5},	/* Australia/Darwin */
			{_T("JST"), +9.0},	/* Asia/Tokyo */
			{_T("CTT"), +8.0},	/* Asia/Shanghai */
			{_T("VST"), +7.0},	/* Asia/Saigon */
			{_T("BST"), +6.0},	/* Asia/Dacca */
			{_T("IST"), +5.5},	/* Asia/Calcutta */
			{_T("PLT"), +5.0},	/* Asia/Karachi */
			{_T("NET"), +4.0},	/* Asia/Yerevan */
			{_T("MET"), +3.5},	/* Asia/Tehran */
			{_T("EAT"), +3.0},	/* Africa/Addis_Ababa */
			{_T("EET"), +2.0},	/* Europe/Istanbul */
			{_T("ART"), +2.0},	/* Africa/Cairo */
			{_T("CAT"), +2.0},	/* Africa/Harare */
			{_T("ECT"), +1.0},	/* Europe/Paris */
			{_T("CET"), +1.0},	/* Europe/Paris */
			{_T("GMT"),  0.0},	/* GMT */
			{_T("UT"),   0.0},	/* GMT */
			{_T("UTC"),  0.0},	/* GMT */
			{_T("BET"), -3.0},	/* America/Sao_Paulo */
			{_T("AGT"), -3.0},	/* America/Buenos_Aires */
			{_T("CNT"), -3.5},	/* America/St_Johns */
			{_T("PRT"), -5.0},	/* America/Puerto_Rico */
			{_T("EST"), -5.0},	/* America/New_York */
			{_T("IET"), -5.0},	/* America/Indianapolis */
			{_T("CST"), -6.0},	/* America/Chicago */
			{_T("MST"), -7.0},	/* America/Denver */
			{_T("PNT"), -7.0},	/* America/Phoenix */
			{_T("PST"), -8.0},	/* America/Los_Angeles */
			{_T("MDT"), -8.0},	/* America/Boise */			/* Mountain Standard Time */
			{_T("AST"), -9.0},	/* America/Anchorage */
			{_T("PDT"), -9.0},	/* America/Dawson */		/* Pacific Standard Time */
			{_T("HST"),-10.0},	/* Pacific/Honolulu */
			{_T("TKT"),-10.0},	/* Pacific/Fakaofo */		/* Tokelau Time */
			{_T("CKT"),-10.0},	/* Pacific/Rarotonga */		/* Cook Is. Time */
			{_T("MIT"),-11.0},	/* Pacific/Apia */
			{_T("WST"),-11.0},	/* Pacific/Apia */
			{_T("SST"),-11.0},	/* Pacific/Midway */		/* Samoa Standard Time */
			{_T("NUT"),-11.0},	/* Pacific/Niue */			/* Niue Time */
		};
		static unsigned nAbb = sizeof(tzAbb) / sizeof(TimeZoneData);

		static TimeZoneData tzMil\[\] = 
		{
			{_T("Z"), 0.0}, // Zulu Time ( UTC )
			{_T("A"), +1.0}, {_T("B"), +2.0}, {_T("C"), +3.0}, {_T("D"), +4.0}, {_T("E"), +5.0}, {_T("F"), +6.0}, {_T("G"), +7.0}, {_T("H"), +8.0}, {_T("I"), +9.0}, {_T("K"), +10.0}, {_T("L"), +11.0}, {_T("M"), +12.0},
			{_T("N"), -1.0}, {_T("O"), -2.0}, {_T("P"), -3.0}, {_T("Q"), -4.0}, {_T("R"), -5.0}, {_T("S"), -6.0}, {_T("T"), -7.0}, {_T("U"), -8.0}, {_T("V"), -9.0}, {_T("W"), -10.0}, {_T("X"), -11.0}, {_T("Y"), -12.0}, 
		};
		static unsigned nMil = sizeof(tzMil) / sizeof(TimeZoneData);


		// Pass 1: 
		// check the length of the input string.
		// For single letter lookup the timezone offset from the tzMil array.
		if( _tcslen( szTimezone ) == 1 )
		{
			for( unsigned i=0; i<nMil; ++i )
				if( _tcscmp( szTimezone, tzMil\[i\].sName ) == 0 )
					return (int)(60.0 * tzMil\[i\].dOffset);
		}
		else		
		{
			// Pass 2: 
			// lookup the timezone offset from tzAbb array
			// all standard timezones and the offsets are recorded
			{
				for( unsigned i=0; i<nAbb; ++i )
					if( _tcscmp( szTimezone, tzAbb\[i\].sName ) == 0 )
						return (int)(60.0 * tzAbb\[i\].dOffset);
			}

			// Pass 3: 
			// try to extract the +/-HH format
			{
				int nHours = _ttoi( (const TCHAR*)(szTimezone) );
				return 60 * nHours;
			}
		}
		return 0;
	}
};
////////////////////////////////////////////////////////////////////////// 
	
CSchemaDate Edifact::ToDate(const CSchemaString& rValue, const CSchemaString& rFormat)
{
	int nCentury = 0L;
	int nYear = 0L;
	int nMonth = 0L;
	int nWeek = 0L;
	int nDay = 0L;

	tstring sValue = (tstring)(rValue);
	const TCHAR* szValue = sValue.c_str();
	
	switch( rFormat.ToLong() )
	{
	// DDMMYY
	case 2:
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nDay, &nMonth, &nYear );
			return CSchemaTypeCalendar::CDate( Convert::Year( nYear ), nMonth, nDay );
		}
		break;
		
		// MMDDYY
	case 3:
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nMonth, &nDay, &nYear );
			return CSchemaTypeCalendar::CDate( Convert::Year( nYear ), nMonth, nDay );
		}
		break;
		
		// DDMMCCYY
	case 4:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nDay, &nMonth, &nCentury, &nYear );
			return CSchemaTypeCalendar::CDate( Convert::Year( nCentury, nYear ), nMonth, nDay );
		}
		break;
		
		// CCYYMMB
		// B=1:first half month, B=2:second half month.
	case 6:
		{
			int nB = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%1d"), &nCentury, &nYear, &nMonth, &nB );
			CSchemaTypeCalendar::CDate date( Convert::Year( nCentury, nYear ), nMonth, 1 );
			CSchemaTypeCalendar::CDuration offset( true, 0, 0, 15, 0, 0, 0.0 );
			if( nB == 2 ) date = date + offset;
			return CSchemaTypeCalendar::CDate( date );
		}
		break;
		
	// CCYYMMW
	// W=1-5 first week to fifth week in a month.
	case 7:
		{
			_stscanf( szValue, _T("%2d%2d%2d%1d"), &nCentury, &nYear, &nMonth, &nWeek );
			CSchemaTypeCalendar::CDate base( Convert::Year( nCentury, nYear), nMonth, 1L );
			CSchemaTypeCalendar::CDuration days( true, 0L, 0L, (nWeek-1) * 7, 0L, 0L, 0.0 );
			return CSchemaTypeCalendar::CDate( base + days );
		}
		break;
		
	// CCYYMMDDS
	// Shift within a calendar day: CC=century YY=year MM=month DD=day S=1-9 shift in a day.
	case 8:
		{
			int nShift = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%1d"), &nCentury, &nYear, &nMonth, &nDay, &nShift);
			return CSchemaTypeCalendar::CDate( Convert::Year( nCentury, nYear ), nMonth, nDay );
		}
		break;

	// CCYYMMDDPP
	// Time period within a calendar day: CC=century YY=year MM=month DD=day PP=00-99 time period.
	case 9:
		{
			int nPeriod = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d"), &nCentury, &nYear, &nMonth, &nDay, &nPeriod);
			return CSchemaTypeCalendar::CDate( Convert::Year( nCentury, nYear ), nMonth, nDay );
		}
		break;
		
	// YYMMDD
	// Calendar date: Y = Year; M = Month; D = Day.
	case 101:
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nYear, &nMonth, &nDay );
			return CSchemaTypeCalendar::CDate( Convert::Year( nYear ), nMonth, nDay );
		}
		break;
		
	// CCYYMMDD
	// Calendar date: C = Century ; Y = Year ; M = Month ; D = Day.
	case 102:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nCentury, &nYear, &nMonth, &nDay );
			return CSchemaTypeCalendar::CDate( Convert::Year( nCentury, nYear ), nMonth, nDay );
		}
		break;
		
	// YYWWD
	// Calendar week day: Y = Year ; W = Week ; D = Day 
	// Week number 01 is always first week of January 
	// Day number 1 is always Monday.
	case 103:
		{
			_stscanf( szValue, _T("%2d%2d%1d"), &nYear, &nWeek, &nDay );
			
			CSchemaTypeCalendar::CDate base ( Convert::Year( nYear ), 1L, 1L ); // 1st Jan.
			CSchemaTypeCalendar::CDuration days( true, 0L, 0L, (nWeek-1) * 7, 0L, 0L, 0.0 );
			CSchemaTypeCalendar::CDate date( base + days );

			CSchemaTypeCalendar::CDuration oneWeek( true, 0L, 0L, 7L, 0L, 0L, 0.0 );
			int nWeekNumber = 0L;
			do
			{
				nWeekNumber = Lang::Weeknumber( date );
				if( nWeekNumber < nWeek )
					date = date + oneWeek;
			}
			while( nWeekNumber < nWeek );

			CSchemaTypeCalendar::CDuration dayOffset( true, 0L, 0L, 0L, 0L, 0L, 0.0 );
			int nWeekDay = Lang::Weekday( date );
			dayOffset.nDay =  -1 * (nWeekDay-1);
			date = date + dayOffset;
			dayOffset.nDay = nDay-1;
			date = date + dayOffset;
			return CSchemaTypeCalendar::CDate( date );
		}
		break;
		
	// YYDDD
	// Calendar day: Y = Year ; D = Day 
	// January the first = Day 001 
	// Always start numbering the days of the year from January 1st through December 31st.
	case 105:
		{
			_stscanf( szValue, _T("%2d%3d"), &nYear, &nDay );
			CSchemaTypeCalendar::CDate base( Convert::Year( nYear ), 1L, 1L ); // January 1st 
			CSchemaTypeCalendar::CDuration days( true, 0L, 0L, nDay-1, 0L, 0L, 0.0 );
			return CSchemaTypeCalendar::CDate( base + days );
		}
		break;
		
	// MMDD
	// Day of a month: M = Month; D = Day.
	case 106:
		{
			_stscanf( szValue, _T("%2d%2d"), &nMonth, &nDay );
			return CSchemaTypeCalendar::CDate( 1L, nMonth, nDay );
		}
		break;

	default:
		{
		}
		break;
	}
	return CSchemaDate();
}

CSchemaTime Edifact::ToTime(const CSchemaString& rValue, const CSchemaString& rFormat)
{
	int nDay = 0L;
	int nHour = 0L;
	int nMinute = 0L;
	int nSeconds = 0L;

	tstring sValue = (tstring)(rValue);
	const TCHAR* szValue = sValue.c_str();

	switch( rFormat.ToLong() )
	{
	// HHMM
	// Time without seconds: H = Hour; m = Minute.
	case 401:
		{
			_stscanf( szValue, _T("%2d%2d"), &nHour, &nMinute );
			return CSchemaTypeCalendar::CTime( nHour, nMinute, 0.0 );
		}
		break;
		
	// HHMMSS
	// Time with seconds: H = Hour; m = Minute; s = Seconds.
	case 402:
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nHour, &nMinute, &nSeconds );
			return CSchemaTypeCalendar::CTime( nHour, nMinute, nSeconds );
		}
		break;
		
	// HHMMSSZZZ
	// See 402 plus Z=Time zone.
	case 404:
		{
			TCHAR chTimezone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%3c"), &nHour, &nMinute, &nSeconds, &chTimezone );
			return CSchemaTypeCalendar::CTime( nHour, nMinute, nSeconds, Convert::Timezone(chTimezone) );
		}
		break;
		
	// MMMMSS
	// Time without hours: m=minutes, s=seconds.
	case 405:
		{
			_stscanf( szValue, _T("%4d%2d"), &nMinute, &nSeconds );
			return CSchemaTypeCalendar::CTime( nMinute / 60, nMinute % 60, nSeconds );
		}
		break;
		
	default:
		{
		}
		break;
	}
	return CSchemaTime();
}

CSchemaDateTime Edifact::ToDatetime(const CSchemaString& rValue, const CSchemaString& rFormat)
{
	int nCentury = 0L;
	int nYear = 0L;
	int nMonth = 0L;
	int nWeek = 0L;
	int nDay = 0L;
	int nHour = 0L;
	int nMinute = 0L;
	double dSecond = 0.0;
	int nTimezone = 0L;

	tstring sValue = (tstring)(rValue);
	const TCHAR* szValue = sValue.c_str();

	switch( rFormat.ToLong() )
	{

	// DDMMCCYYHHMM
	case 5:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nDay, &nMonth, &nCentury, &nYear, &nHour, &nMinute );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear), nMonth, nDay, nHour, nMinute, dSecond );
		}
		break;

	// CCYYMMDDTHHMM
	// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; T=Time designator; H=Hour; M=Minutes.
	// The character \[T\] shall be used as time designator to indicate the start of the representation of the time.
	// For example: 20010912T1433.
	case 10:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2dT%2d%2d"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute);
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, dSecond );
		}
		break;

	// YYMMDDHHMM
	// Calendar date including time without seconds: Y = Year; M = Month; D = Day; H = Hour; M = Minute.
	case 201:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d"), &nYear, &nMonth, &nDay, &nHour, &nMinute);
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nYear ), nMonth, nDay, nHour, nMinute, dSecond );
		}
		break;

	// YYMMDDHHMMSS
	// Calendar date including time with seconds: Y = Year; M = Month; D = Day; H = Hour; m = Minutes = Seconds.
	case 202:
		{
			int nSeconds = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSeconds );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nYear ), nMonth, nDay, nHour, nMinute, nSeconds );
		}
		break;
		
	// CCYYMMDDHHMM
	// Calendar date including time with minutes: C=Century; Y=Year; M=Month; D=Day; H=Hour; M=Minutes.
	case 203:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, dSecond );
		}
		break;

	// CCYYMMDDHHMMSS
	// Calendar date including time with seconds: C=Century;Y=Year; M=Month;D=Day;H=Hour;M=Minute;S=Second.
	case 204:
		{
			int nSeconds = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSeconds );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, nSeconds );
		}
		break;
		
		// CCYYMMDDHHMMZHHMM
		// Calendar date including time and time zone expressed in hours and minutes.
		// ZHHMM = time zone given as offset from Coordinated Universal Time (UTC).
	case 205:
		{
			TCHAR chOffset = 0L;
			int nOffsetHour = 0L;
			int nOffsetMinute = 0L;
			bool bUTC = true;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%1c%2d%2d"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute, &chOffset, &nOffsetHour, &nOffsetMinute );
			CSchemaTypeCalendar::CDateTime utcBase( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, dSecond, nOffsetHour*60+nOffsetMinute );
			return utcBase;
		}
		break;
		
		
		// YYMMDDHHMMZZZ
		// See 201 + Z = Time zone.
	case 301:
		{
			TCHAR chTimezone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%3c"), &nYear, &nMonth, &nDay, &nHour, &nMinute, &chTimezone );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nYear ), nMonth, nDay, nHour, nMinute, 0.0, Convert::Timezone(chTimezone) );
		}
		break;
		
		// YYMMDDHHMMSSZZZ
		// See 202 + Z = Time zone.
	case 302:
		{
			int nSeconds = 0L;
			TCHAR chTimezone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%3c"), &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSeconds, &chTimezone );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nYear ), nMonth, nDay, nHour, nMinute, nSeconds, Convert::Timezone(chTimezone) );
		}
		break;
		
		// CCYYMMDDHHMMZZZ
		// See 203 plus Z=Time zone.
	case 303:
		{
			TCHAR chTimezone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%3c"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute, &chTimezone );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, dSecond, Convert::Timezone(chTimezone) );
		}
		break;
		
		// CCYYMMDDHHMMSSZZZ
		// See 204 plus Z=Time zone.
	case 304:
		{
			int nSeconds = 0L;
			TCHAR chTimezone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d%3c"), &nCentury, &nYear, &nMonth, &nDay, &nHour, &nMinute, &nSeconds, &chTimezone );
			return CSchemaTypeCalendar::CDateTime( Convert::Year( nCentury, nYear ), nMonth, nDay, nHour, nMinute, nSeconds, Convert::Timezone(chTimezone) );
		}
		break;
		
	default:
		{
			return CSchemaDateTime();
		}
		break;
	}
	return CSchemaDateTime();
}

CSchemaDuration Edifact::ToDuration(const CSchemaString& rValue, const CSchemaString& rFormat)
{
	int nCentury = 0L;
	int nYear = 0L;
	int nMonth = 0L;
	int nWeek = 0L;
	int nDay = 0L;
	int nHour = 0L;
	int nMinute = 0L;
	double dSecond = 0.0;
	int nTimezone = 0L;

	tstring sValue = (tstring)(rValue);
	const TCHAR* szValue = sValue.c_str();

	switch( rFormat.ToLong() )
	{

	//	MMDDHHMM
	//	Month, day, hours, minutes; M = Month; D = Day; H = Hour; M = Minute.
	case 305:
		{
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nMonth, &nDay, &nHour, &nMinute );
			return CSchemaTypeCalendar::CDuration( true, 0L, nMonth, nDay, nHour, nMinute, 0.0 );
		}
		break;
	
	//	DDHHMM
	//	Day, hours, minutes; D = Day; H = Hour; M = Minute.
	case 306:	
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nDay, &nHour, &nMinute );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, nDay, nHour, nMinute, 0.0 );
		}
		break;

	//	ZHHMM
	//	Offset from Coordinated Universal Time (UTC) where Z is plus (+) or minus (-).
	case 406:
		{
			TCHAR chDirection = 0x0;
			_stscanf( szValue, _T("%1c%2d%2d"), &chDirection, &nHour, &nMinute );
			return CSchemaTypeCalendar::CDuration( chDirection == _T('+'), 0L, 0L, 0L, nHour, nMinute, 0.0 );
		}
		break;
		
	// HHMMHHMM
	// Time span without seconds: H = Hour; m = Minute;.
	case 501:	
		{
			int nFromHour = 0;
			int nFromMinute = 0;
			int nToHour = 0;
			int nToMinute = 0;
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nFromHour, &nFromMinute, &nToHour, &nToMinute );
			CSchemaTypeCalendar::CTime timeFrom( nFromHour, nFromMinute, 0.0 );
			CSchemaTypeCalendar::CTime timeTo( nToHour, nToMinute, 0.0 );
			return CSchemaTypeCalendar::CDuration( timeTo - timeFrom );
		}
		break;
		
	// HHMMSS-HHMMSS
	// A period of time specified by giving the start time
	// followed by the end time (both expressed by hours
	// minutes and seconds). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 502:
		{
			int nFromHour = 0;
			int nFromMinute = 0;
			int nFromSecond = 0;
			int nToHour = 0;
			int nToMinute = 0;
			int nToSecond = 0;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nFromHour, &nFromMinute, &nFromSecond, &nToHour, &nToMinute, &nToSecond );
			CSchemaTypeCalendar::CTime timeFrom( nFromHour, nFromMinute, nFromSecond );
			CSchemaTypeCalendar::CTime timeTo( nToHour, nToMinute, nToSecond );
			return CSchemaTypeCalendar::CDuration( timeTo - timeFrom );
		}
		break;
		
	// HHMMSSZZZ-HHMMSSZZZ
	// A period of time specified by giving the start time
	// followed by the end time (both expressed by hours
	// minutes, seconds and time zone). Data is to be
	// transmitted as consecutive characters without hyphen.
	case 503:
		{
			int nFromHour = 0;
			int nFromMinute = 0;
			int nFromSecond = 0;
			TCHAR chFromZone\[4\] = {0,0,0,0};
			int nToHour = 0;
			int nToMinute = 0;
			int nToSecond = 0;
			TCHAR chToZone\[4\] = {0,0,0,0};
			_stscanf( szValue, _T("%2d%2d%2d%3c%2d%2d%2d%3c"), &nFromHour, &nFromMinute, &nFromSecond, &chFromZone, &nToHour, &nToMinute, &nToSecond, &chToZone );
			CSchemaTypeCalendar::CTime timeFrom( nFromHour, nFromMinute, nFromSecond, Convert::Timezone(chFromZone) );
			CSchemaTypeCalendar::CTime timeTo( nToHour, nToMinute, nToSecond, Convert::Timezone(chToZone) );
			return CSchemaTypeCalendar::CDuration( timeTo - timeFrom );
		}
		break;
		
	// YY-YY
	// A period of time specified by giving the start year
	// followed by the end year (both without century). Data is
	// to be transmitted as consecutive characters without
	// hyphen.
	case 701:
		{
			int nFromYear = 0L;
			int nToYear = 0L;
			_stscanf( szValue, _T("%2d%2d"), &nFromYear, &nToYear );
			nFromYear = Convert::Year( nFromYear );
			nToYear = Convert::Year( nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// CCYY-CCYY
	// A period of time specified by giving the start year
	// followed by the end year (both including century). Data
	// is to be transmitted as consecutive characters without hyphen.
	case 702:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nToCentury = 0L;
			int nToYear = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nFromCentury, &nFromYear, &nToCentury, &nToYear );
			nFromYear = Convert::Year( nFromCentury, nFromYear );
			nToYear = Convert::Year( nToCentury, nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;
		
	// YYS-YYS
	// A period of time specified by giving the start semester
	// of a year followed by the end semester of a year (both
	// not including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 703:
		{
			int nFromYear = 0L;
			int nFromSemester = 0L;
			int nToYear = 0L;
			int nToSemester = 0L;	// !!! semester value is currently ignored
			_stscanf( szValue, _T("%2d%1d%2d%1d"), &nFromYear, &nFromSemester, &nToYear, &nToSemester );
			nFromYear = Convert::Year( nFromYear );
			nToYear = Convert::Year( nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// CCYYS-CCYYS
	// A period of time specified by giving the start semester
	// of a year followed by the end semester of a year (both
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 704:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromSemester = 0L;		// !!! semester value is currently ignored
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToSemester = 0L;		// !!! semester value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d%2d%2d%1d"), &nFromCentury, &nFromYear, &nFromSemester, &nToCentury, &nToYear, &nToSemester );
			nFromYear = Convert::Year( nFromCentury, nFromYear );
			nToYear = Convert::Year( nToCentury, nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// YYPYYP
	// Format of period to be given without hyphen (P = period of 4 months).
	case 705:	
		{
			int nFromYear = 0L;
			int nFromPeriod = 0L;
			int nToYear = 0L;
			int nToPeriod = 0L;		// !!! period value is currently ignored
			_stscanf( szValue, _T("%2d%1d%2d%2d%1d"), &nFromYear, &nFromPeriod, &nToYear, &nToPeriod );
			nFromYear = Convert::Year( nFromYear );
			nToYear = Convert::Year( nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// CCYYP-CCYYP
	// Format of period to be given without hyphen (P = period of 4 months).
	case 706:	
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromPeriod = 0L;	// !!! period value is currently ignored
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToPeriod = 0L;		// !!! period value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d%2d%2d%1d"), &nFromCentury, &nFromYear, &nFromPeriod, &nToCentury, &nToYear, &nToPeriod );
			nFromYear = Convert::Year( nFromCentury, nFromYear );
			nToYear = Convert::Year( nToCentury, nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// YYQ-YYQ
	// A period of time specified by giving the start quarter
	// of a year followed by the end quarter of year (both not
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 707:
		{
			int nFromYear = 0L;
			int nFromQuarter = 0L;		// !!! quarter value is currently ignored
			int nToYear = 0L;
			int nToQuarter = 0L;		// !!! quarter value is currently ignored
			_stscanf( szValue, _T("%2d%1d%2d%2d%1d"), &nFromYear, &nFromQuarter, &nToYear, &nToQuarter );
			nFromYear = Convert::Year( nFromYear );
			nToYear = Convert::Year( nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;

	// CCYYQ-CCYYQ
	// A period of time specified by giving the start quarter
	// of a year followed by the end quarter of year (both
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 708:	
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromQuarter = 0L;	// !!! quarter value is currently ignored
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToQuarter = 0L;	// !!! quarter value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d%2d%2d%1d"), &nFromCentury, &nFromYear, &nFromQuarter, &nToCentury, &nToYear, &nToQuarter );
			nFromYear = Convert::Year( nFromCentury, nFromYear );
			nToYear = Convert::Year( nToCentury, nToYear );
			return CSchemaTypeCalendar::CDuration( nFromYear < nToYear, nFromYear < nToYear ? nToYear-nFromYear : nFromYear-nToYear, 0, 0, 0, 0, 0.0 );
		}
		break;
		
	// YYMM-YYMM
	// A period of time specified by giving the start month of
	// a year followed by the end month of a year (both not
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 709:
		{
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nFromYear, &nFromMonth, &nToYear, &nToMonth );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromYear ), nFromMonth, 0 );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToYear ), nToMonth, 0 );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );

		}
		break;

	// CCYYMM-CCYYMM
	// A period of time specified by giving the start month of
	// a year followed by the end month of a year (both
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 710:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nFromCentury, &nFromYear, &nFromMonth, &nToCentury, &nToYear, &nToMonth );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromCentury, nFromYear ), nFromMonth, 0 );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToCentury, nToYear ), nToMonth, 0 );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
		}
		break;
		

	// CCYYMMDD-CCYYMMDD
	// Format of period to be given in actual message without hyphen.
	// Note: 1. This code value will be removed effective with directory D.03B.
	case 711:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nFromDay = 0L;
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			int nToDay = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d%2d"), &nFromCentury, &nFromYear, &nFromMonth, &nFromDay, &nToCentury, &nToYear, &nToMonth, &nToDay );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromCentury, nFromYear ), nFromMonth, nFromDay );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToCentury, nToYear ), nToMonth, nToDay );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
		}
		break;
		
	// YYMMDDHHMM-YYMMDDHHMM
	// A period of time specified by giving the start time
	// followed by the end time (format year, month, day, hour
	// and minute). Data is to be transmitted as consecutive
	// characters without hyphen.
	case 713:
		{
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nFromDay = 0L;
			int nFromHour = 0L;
			int nFromMinute = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			int nToDay = 0L;
			int nToHour = 0L;
			int nToMinute = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d%2d%2d%2d"), &nFromYear, &nFromMonth, &nFromDay, &nFromHour, &nFromHour, &nToYear, &nToMonth, &nToDay, &nToHour, &nToHour );
			CSchemaTypeCalendar::CDateTime datetimeFrom( Convert::Year( nFromYear ), nFromMonth, nFromDay, nFromHour, nFromMinute, 0.0 );
			CSchemaTypeCalendar::CDateTime datetimeTo  ( Convert::Year( nToYear ),   nToMonth,   nToDay,   nToHour,   nToMinute,   0.0 );
			return CSchemaTypeCalendar::CDuration( datetimeTo - datetimeFrom );
		}
		break;
		
	// YYWW-YYWW
	// A period of time specified by giving the start week of a
	// year followed by the end week of year (both not
	// including century). Data is to be transmitted as
	// consecutive characters without hyphen.
	case 715:
		{
			int nFromYear = 0L;
			int nFromWeek = 0L;
			int nToYear = 0L;
			int nToWeek = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d"), &nFromYear, &nFromWeek, &nToYear, &nToWeek );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromYear ), 0, 7 * nFromWeek );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToYear ), 0, 7 * nToWeek );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
			
		}
		break;

	// CCYYWW-CCYYWW
	// A period of time specified by giving the start week of a
	// year followed by the end week of year (both including
	// century). Data is to be transmitted as consecutive
	// characters without hyphen.
	case 716:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromWeek = 0L;
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToWeek = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nFromCentury, &nFromYear, &nFromWeek, &nToCentury, &nToYear, &nToWeek );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromCentury, nFromYear ), 0, 7 * nFromWeek );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToCentury, nToYear ), 0, 7 * nToWeek );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
		}
		break;

		

	// YYMMDD-YYMMDD
	// A period of time specified by giving the start date
	// followed by the end date (both not including century).
	// Data is to be transmitted as consecutive characters
	// without hyphen.
	case 717:
		{
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nFromDay = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			int nToDay = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nFromYear, &nFromMonth, &nFromDay, &nToYear, &nToMonth, &nToDay );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromYear ), nFromMonth, nFromDay );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToYear ), nToMonth, nToDay );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
		}
		break;
		
	// CCYYMMDD-CCYYMMDD
	// A period of time specified by giving the start date
	// followed by the end date (both including century). Data
	// is to be transmitted as consecutive characters without
	// hyphen.
	case 718:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nFromDay = 0L;
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			int nToDay = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d%2d"), &nFromCentury, &nFromYear, &nFromMonth, &nFromDay, &nToCentury, &nToYear, &nToMonth, &nToDay );
			CSchemaTypeCalendar::CDate dateFrom( Convert::Year( nFromCentury, nFromYear ), nFromMonth, nFromDay );
			CSchemaTypeCalendar::CDate dateTo  ( Convert::Year( nToCentury, nToYear ), nToMonth, nToDay );
			return CSchemaTypeCalendar::CDuration( dateTo - dateFrom );
		}
		break;
		
	// CCYYMMDDHHMM-CCYYMMDDHHMM
	// A period of time which includes the century, year,
	// month, day, hour and minute. Format of period to be
	// given in actual message without hyphen.
	case 719:
		{
			int nFromCentury = 0L;
			int nFromYear = 0L;
			int nFromMonth = 0L;
			int nFromDay = 0L;
			int nFromHour = 0L;
			int nFromMinute = 0L;
			
			int nToCentury = 0L;
			int nToYear = 0L;
			int nToMonth = 0L;
			int nToDay = 0L;
			int nToHour = 0L;
			int nToMinute = 0L;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d%2d%2d%2d%2d%2d%2d"),
				&nFromCentury, &nFromYear, &nFromMonth, &nFromDay, &nFromHour, &nFromMinute,
				&nToCentury, &nToYear, &nToMonth, &nToDay, &nToHour, &nToMinute );
			
			CSchemaTypeCalendar::CDateTime datetimeFrom( Convert::Year( nFromCentury, nFromYear ), nFromMonth, nFromDay, nFromHour, nFromMinute, 0.0 );
			CSchemaTypeCalendar::CDateTime datetimeTo  ( Convert::Year( nToCentury, nToYear ), nToMonth, nToDay, nToHour, nToMinute, 0.0 );
			return CSchemaTypeCalendar::CDuration( datetimeTo - datetimeFrom );
		}
		break;
		
	// DHHMM-DHHMM
	// Format of period to be given without hyphen (D=day of
	// the week, 1=Monday; 2=Tuesday; ... 7=Sunday).
	case 720:
		{
			int nFromDayOfWeek = 0;
			int nFromHour = 0;
			int nFromMinute = 0;
			int nToDayOfWeek = 0;
			int nToHour = 0;
			int nToMinute = 0;
			_stscanf( szValue, _T("%2d%2d%2d%2d%2d%2d"), &nFromDayOfWeek, &nFromHour, &nFromMinute, &nToDayOfWeek, &nToHour, &nToMinute );
			
			// Lang::Weekday returns 1=Sunday ... 7=Saturday
			nFromDayOfWeek	= ( ( nFromDayOfWeek + 1 ) % 7 ) + 1;
			nToDayOfWeek	= ( ( nToDayOfWeek + 1 ) % 7 ) + 1;

			CSchemaTypeCalendar::CDuration oneday( true, 0, 0, 1, 0, 0, 0.0 );
			CSchemaTypeCalendar::CDateTime from( 1, 1, 1, nFromHour, nFromMinute, 0.0 );
			
			while( Lang::Weekday( Lang::DateFromDatetime(from) ) != nFromDayOfWeek )
				from = from + oneday;

			CSchemaDateTime to( from );
				to.GetValue().nHour =  nToHour;
				to.GetValue().nMinute = nToMinute;

			while( Lang::Weekday( Lang::DateFromDatetime(to) ) != nToDayOfWeek )
				to = to + oneday;
			
			return CSchemaDuration( to - from );

		}
		break;
		

	// Year
	// To indicate a quantity of years.
	case 801:	
		{
			int nYears = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, nYears, 0L, 0L, 0L, 0L, 0.0 );
		}
		break;
		
	// Month
	// To indicate a quantity of months.
	case 802:
		{
			int nMonth = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, nMonth, 0L, 0L, 0L, 0.0 );
		}
		break;
		
	// Week
	// To indicate a quantity of weeks.
	case 803:
		{
			int nWeeks = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, nWeeks * 7, 0L, 0L, 0.0 );
		}
		break;
		
	// Day
	// To indicate a quantity of days.
	case 804:
		{
			int nDays = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, nDays, 0L, 0L, 0.0 );
		}
		break;
		
	// Hour
	// To indicate a quantity of hours.
	case 805:
		{
			int nHours = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, 0L, nHours, 0L, 0.0 );
		}
		break;
		
	// Minute
	// To indicate a quantity of minutes.
	case 806:
		{
			int nMinutes = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, 0L, 0L, nMinutes, 0.0 );
		}
		break;
		
	// Second
	// To indicate a quantity of seconds.
	case 807:
		{
			int nSeconds = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, 0L, 0L, 0L, nSeconds );
		}
		break;
		
	// Semester
	// To indicate a quantity of semesters (six months).
	case 808:
		{
			int nSemesters = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 6 * nSemesters, 0L, 0L, 0L, 0.0 );
		}
		break;
		
	// Four months period
	// To indicate a quantity of four months periods.
	case 809:
		{
			int nFourMonth = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 4 * nFourMonth, 0L, 0L, 0L, 0.0 );
		}
		break;
		
	// Trimester
	// To indicate a quantity of trimesters (three months).
	case 810:
		{
			int nTrimesters = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 3 * nTrimesters, 0L, 0L, 0L, 0.0 );
		}
		break;
		
	// Half month
	// To indicate a quantity of half months.
	case 811:
		{
			int nHalfMonth = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, 15 * nHalfMonth, 0L, 0L, 0.0 );
		}
		break;
		
	// Ten days
	// To indicate a quantity of ten days periods.
	case 812:
		{
			int nTenDays = _ttoi( szValue );
			return CSchemaTypeCalendar::CDuration( true, 0L, 0L, 10 * nTenDays, 0L, 0L, 0.0 );
		}
		break;
		
	default:
		{
			return CSchemaDuration();
		}
		break;
	}
	return CSchemaDuration();
}

CSchemaString Edifact::Autoformat(const CSchemaString& rValue, const CSchemaString& rFormat)
{
	CSchemaTime time = Edifact::ToTime( rValue, rFormat );
	if( !time.IsEmpty() )
		return CSchemaString( time );

	CSchemaDate date = Edifact::ToDate( rValue, rFormat );
	if( !date.IsEmpty() )
		return CSchemaString( date );
	
	CSchemaDateTime datetime = Edifact::ToDatetime( rValue, rFormat );
	if( !datetime.IsEmpty() )
		return CSchemaString( datetime );
	
	CSchemaDuration duration = Edifact::ToDuration( rValue, rFormat );
	if( !duration.IsEmpty() )
		return CSchemaString( duration );

	int nCentury = 0L;
	int nYear = 0L;
	int nMonth = 0L;
	int nWeek = 0L;
	int nDay = 0L;
	
	tstring sValue = (tstring)(rValue);
	const TCHAR* szValue = sValue.c_str();

	switch( rFormat.ToLong() )
	{
	// DDD
	// Day's number within a specific year: D = Day.
	case 107:
		{
			_stscanf( szValue, _T("%3d"), &nDay );
			return CSchemaString( CSchemaDay( CSchemaTypeCalendar::CDay( nDay ) ) );
		}
		break;
		
	// WW
	// Week's number within a specific year: W = Week.
	case 108:
		{
			_stscanf( szValue, _T("%2d"), &nWeek );
			return CSchemaString( CSchemaLong( nWeek ) );
		}
		break;
		
	// MM
	// Month's number within a specific year: M = Month.
	case 109:
		{		
			_stscanf( szValue, _T("%2d"), &nMonth );
			return CSchemaString( CSchemaMonth( CSchemaTypeCalendar::CMonth( nMonth ) ) );
		}
		break;
		
	// DD
	// Day's number within is a specific month: D = Day.
	case 110:
		{
			_stscanf( szValue, _T("%2d"), &nDay );
			return CSchemaString( CSchemaDay( CSchemaTypeCalendar::CDay( nDay ) ) );
		}
		break;

	// CC
	// Century.
	case 600:
		{
			_stscanf( szValue, _T("%2d"), &nCentury );
			return CSchemaString( CSchemaLong( nCentury ) );
		}
		break;

	// YY
	// Calendar year: Y = Year.
	case 601:
		{
			_stscanf( szValue, _T("%2d"), &nYear );
			return CSchemaString( CSchemaYear( CSchemaTypeCalendar::CYear( Convert::Year( nYear ) ) ) );
		}
		break;

	// CCYY
	// Calendar year including century: C = Century; Y = Year.
	case 602:
		{
			_stscanf( szValue, _T("%2d%2d"), &nCentury, &nYear );
			return CSchemaString( CSchemaYear( CSchemaTypeCalendar::CYear( Convert::Year( nCentury, nYear ) ) ) );
		}
		break;

	// YYS
	// Semester in a calendar year: Y = Year; S = Semester.
	case 603:
			
		{
			int nSemester = 0L;
			_stscanf( szValue, _T("%2d%1d"), &nYear, &nSemester );
			return CSchemaString( CSchemaYear( CSchemaTypeCalendar::CYear( Convert::Year( nYear ) ) ) );
		}
		break;
		
	// CCYYS
	// Semester in a calendar year: C = Century; Y = Year; S = Semester.
	case 604:
		{
			int nSemester = 0L;	// !!! semester value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d"), &nCentury, &nYear, &nSemester );
			return CSchemaString( CSchemaYear( CSchemaTypeCalendar::CYear( Convert::Year( nCentury, nYear ) ) ) );
		}
		break;

	// CCYYQ
	// Quarter in a calendar year: C = Century; Y = Year; Q = Quarter.
	case 608:
		{
			int nQuarter = 0L;	// !!! quarter value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d"), &nCentury, &nYear, &nQuarter );
			return CSchemaString( CSchemaYear( CSchemaTypeCalendar::CYear( Convert::Year( nCentury, nYear ) ) ) );
		}
		break;

	// YYMM
	// Month within a calendar year: Y = Year; M = Month.
	case 609:
		{
			_stscanf( szValue, _T("%2d%2d"), &nYear, &nMonth );
			return CSchemaString( CSchemaYearMonth( CSchemaTypeCalendar::CYearMonth( Convert::Year( nYear ), nMonth ) ) );
		}
		break;
		
	// CCYYMM
	// Month within a calendar year: CC = Century; Y = Year; M = Month.
	case 610:
		{
			_stscanf( szValue, _T("%2d%2d%2d"), &nCentury, &nYear, &nMonth );
			return CSchemaString( CSchemaYearMonth( CSchemaTypeCalendar::CYearMonth( Convert::Year( nCentury, nYear ), nMonth ) ) );
		}
		break;
		
	// YYMMA
	// To specifiy a ten-day period within a month of a year (A = ten day period).
	case 613:
		{
			int nPeriod = 0L;	// !!! period value is currently ignored
			_stscanf( szValue, _T("%2d%2d%1d"), &nYear, &nMonth, &nPeriod );
			return CSchemaString( CSchemaYearMonth( CSchemaTypeCalendar::CYearMonth( Convert::Year( nYear ), nMonth ) ) );
		}
		break;

	// CCYYMMA
	// To specifiy a ten-day period within a month of a year, including century  (A = ten day period).
	case 614:	
		{
			int nPeriod = 0L;	// !!! period value is currently ignored
			_stscanf( szValue, _T("%2d%2d%2d%1d"), &nCentury, &nYear, &nMonth, &nPeriod );
			return CSchemaString( CSchemaYearMonth( CSchemaTypeCalendar::CYearMonth( Convert::Year( nCentury, nYear ), nMonth ) ) );
		}
		break;
		
	// Day of the week
	// Numeric representation of the day (Monday = 1).
	case 813:

	// Working days
	// Number of working days.
	case 814:
		{
			int nWorkingDays = _ttoi( szValue );
			return CSchemaString( CSchemaDay( CSchemaTypeCalendar::CDay( nWorkingDays ) ) );
		}
		break;
	default:
		{
			return CSchemaString( szValue );
		}
		break;
	}

	return CSchemaString();
}

} // namespace altova
