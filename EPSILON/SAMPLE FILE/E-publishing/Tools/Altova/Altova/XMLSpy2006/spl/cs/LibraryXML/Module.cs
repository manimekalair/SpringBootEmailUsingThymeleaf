//
// [=$QualifiedFilename]
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//


[if $class.IsComplexType
]using System;
using System.Collections;
using System.Xml;
using Altova.Types;

namespace [=$QualifiedNamespace]
{
[	$BaseIsComplex  = $class.HasBaseObject and $class.BaseObject.IsComplexType
	if $BaseIsComplex
		if $class.NamespacePrefix <> $class.BaseObject.NamespacePrefix
			$QualifiedBase = $class.BaseObject.NamespacePrefix & "." & $class.Base
		else
			$QualifiedBase = $class.Base
		endif
	else
		$QualifiedBase = "Altova.Xml.Node"
	endif

]	public class [=$class.Name] : [=$QualifiedBase]
	{
		#region Forward constructors
[if $CompatibilityMode <= "2005"]
		public [=$class.Name]() : base() { SetCollectionParents(); }
[endif]
		public [=$class.Name](XmlDocument doc) : base(doc) { SetCollectionParents(); }
		public [=$class.Name](XmlNode node) : base(node) { SetCollectionParents(); }
		public [=$class.Name](Altova.Xml.Node node) : base(node) { SetCollectionParents(); }
		public [=$class.Name](Altova.Xml.Document doc, string namespaceURI, string prefix, string name) : base(doc, namespaceURI, prefix, name) { SetCollectionParents(); }
		#endregion // Forward constructors
[	if $class.IsComplexFromSimpleType or $class.IsMixed
		if $class.HasSimpleBaseObject
			if $class.NamespacePrefix <> $class.SimpleBaseObject.NamespacePrefix
				$QualifiedValueType = $class.SimpleBaseObject.NamespacePrefix & "." & $class.SimpleBaseObject.Name
			else
				$QualifiedValueType = $class.SimpleBaseObject.Name
			endif
		else
			if $class.IsMixed
				$QualifiedValueType = "SchemaString"
			else
				$QualifiedValueType = $class.BuiltInBase
			endif
		endif
		if not $BaseIsComplex
]
		#region Value accessor methods
		public [=$QualifiedValueType] GetValue()
		{
			return new [=$QualifiedValueType](GetDomNodeValue(domNode));
		}

		public void SetValue(ISchemaType newValue)
		{
			SetDomNodeValue(domNode, newValue.ToString());
		}

		public void Assign(ISchemaType newValue)
		{
			SetValue(newValue);
		}

		public [=$QualifiedValueType] Value
		{
			get
			{
				return new [=$QualifiedValueType](GetDomNodeValue(domNode));
			}
			set
			{
				SetDomNodeValue(domNode, value.ToString());
			}
		}
		#endregion // Value accessor methods
[		endif
	endif
]
		public override void AdjustPrefix()
		{
[	foreach $member in $class.Members
		if $member.IsQualified
			$IsQualified = "true"
		else
			$IsQualified = "false"
		endif
		if $member.HasTypeObject
			if $member.TypeObject.NamespacePrefix <> $class.NamespacePrefix and $member.TypeObject.NamespacePrefix <> ""
				$QualifiedType = $member.TypeObject.NamespacePrefix & "." & $member.Type
			else
				$QualifiedType = $member.Type
			endif
		else
			$QualifiedType = $member.Type
		endif
]
		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]", DOMNode )
				)
			{
				InternalAdjustPrefix(DOMNode, [=$IsQualified]);
[		if $member.HasTypeObject and $member.TypeObject.IsComplexType
]				new [=$QualifiedType](DOMNode).AdjustPrefix();
[		endif
]			}
[
	next ' member
	if $BaseIsComplex]
			base.AdjustPrefix();
[	endif
]		}

[if $HostShort = "MapForce" and $application.IsWebService
]		public override void GenerateXsiTypeAttributes()
		{
[
	if $class.IsSOAPArray
]			{
				XmlElement DOMElement = (XmlElement) domNode;			
				DOMElement.SetAttribute("xmlns:soapenc", "http://schemas.xmlsoap.org/soap/encoding/");
				SetXsiType(DOMElement, "soapenc:Array");
				XmlAttribute a = DOMElement.OwnerDocument.CreateAttribute("soapenc:arrayType", "http://schemas.xmlsoap.org/soap/encoding/");
				a.Value = "[=$class.SOAPArrayType]";
				DOMElement.SetAttributeNode(a);
			}
[	endif

	foreach $member in $class.Members
		if $member.NodeType = "Element"
			if $member.HasTypeObject and $member.TypeObject.IsComplexType
				if $member.TypeObject.NamespacePrefix <> $class.NamespacePrefix
					$QualifiedType = $member.TypeObject.NamespacePrefix & "." & $member.Type
				else
					$QualifiedType = $member.Type
				endif
			else
				$QualifiedType = $member.Type
			endif
]
		    for (	XmlNode DOMNode = GetDomFirstChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]" );
					DOMNode != null; 
					DOMNode = GetDomNextChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]", DOMNode )
				)
			{
[			if $member.HasTypeObject
				$xsiType = $member.TypeObject.Namespace.Prefix
				if $xsiType <> ""
					$xsiType = $xsiType & ":"
				endif
				$xsiType = $xsiType & $member.SchemaType
			else
				$xsiType = "xsd:" & $member.SchemaType
			endif
]				SetXsiType(DOMNode, "[=$xsiType]");
[			if $member.HasTypeObject and $member.TypeObject.IsComplexType
]				new [=$QualifiedType](DOMNode).GenerateXsiTypeAttributes();
[
			endif
]			}
[		endif
	next ' member
	if $BaseIsComplex]
			base.GenerateXsiTypeAttributes();
[	endif
]		}
[endif ' MapForce web service
]
[
	foreach $member in $class.Members
		if $member.HasTypeObject and $member.TypeObject.NamespacePrefix <> $class.NamespacePrefix
			if $member.TypeObject.NamespacePrefix <> ""
				$QualifiedType = $member.TypeObject.NamespacePrefix & "." & $member.Type
			else
				$QualifiedType = $member.Type
			endif
		else
			$QualifiedType = $member.Type
		endif
]
		#region [=$member.Name] accessor methods
		public static int Get[=$member.Name]MinCount()
		{
			return [=$member.MinOcc];
		}

		public static int [=$member.Name]MinCount
		{
			get
			{
				return [=$member.MinOcc];
			}
		}

		public static int Get[=$member.Name]MaxCount()
		{
			return [if $member.MaxOcc = -1]Int32.MaxValue[else][=$member.MaxOcc][endif];
		}

		public static int [=$member.Name]MaxCount
		{
			get
			{
				return [if $member.MaxOcc = -1]Int32.MaxValue[else][=$member.MaxOcc][endif];
			}
		}
[
		if $class.IsSOAPArray
			$lName = "null"
		else
			$lName = "\"" & $member.SchemaName & "\""
		endif
]
		public int Get[=$member.Name]Count()
		{
			return DomChildCount(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName]);
		}

		public int [=$member.Name]Count
		{
			get
			{
				return DomChildCount(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName]);
			}
		}

		public bool Has[=$member.Name]()
		{
			return HasDomChild(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName]);
		}

		public [=$QualifiedType] New[=$member.Name]()
		{
			return new [=$QualifiedType]([if not $member.IsSimpleType
]domNode.OwnerDocument.CreateElement("[=$member.SchemaName]", "[=$member.NamespaceURI]")[endif]);
		}

		public [=$QualifiedType] Get[=$member.Name]At(int index)
		{
[		if $member.IsSimpleType
]			return new [=$QualifiedType](GetDomNodeValue(GetDomChildAt(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName], index)));
[		else
]			return new [=$QualifiedType](GetDomChildAt(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName], index));
[		endif
]		}

		public XmlNode GetStarting[=$member.Name]Cursor()
		{
			return GetDomFirstChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName] );
		}

		public XmlNode GetAdvanced[=$member.Name]Cursor( XmlNode curNode )
		{
			return GetDomNextChild( NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName], curNode );
		}

		public [=$QualifiedType] Get[=$member.Name]ValueAtCursor( XmlNode curNode )
		{
			if( curNode == null )
				  throw new Altova.Xml.XmlException("Out of range");
			else
[			if $member.IsSimpleType
				if $member.NodeType = "Element"
]				return new [=$QualifiedType]( curNode.InnerText );
[				else 
]				return new [=$QualifiedType]( curNode.Value );
[				endif
			else
]				return new [=$QualifiedType]( curNode );
[			endif
]		}


		public [=$QualifiedType] Get[=$member.Name]()
		{
			return Get[=$member.Name]At(0);
		}

		public [=$QualifiedType] [=$member.Name][if $class.Name = $member.Name]_[endif]
		{
			get
			{
				return Get[=$member.Name]At(0);
			}
		}

		public void Remove[=$member.Name]At(int index)
		{
			RemoveDomChildAt(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", [=$lName], index);
		}

		public void Remove[=$member.Name]()
		{
[		if $member.MaxOcc > 1
]			Remove[=$member.Name]At(0);
[		else
]			while (Has[=$member.Name]())
				Remove[=$member.Name]At(0);
[		endif
]		}

		public void Add[=$member.Name]([=$QualifiedType] newValue)
		{
[		if $member.IsSimpleType
]			if( newValue.IsNull() == false )
				AppendDomChild(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]", newValue.ToString());
[		else
]			AppendDomElement("[=$member.NamespaceURI]", "[=$member.SchemaName]", newValue);
[		endif
]		}

		public void Insert[=$member.Name]At([=$QualifiedType] newValue, int index)
		{
[		if $member.IsSimpleType
]			if( newValue.IsNull() == false )
				InsertDomChildAt(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]", index, newValue.ToString());
[		else
]			InsertDomElementAt("[=$member.NamespaceURI]", "[=$member.SchemaName]", index, newValue);
[		endif
]		}

		public void Replace[=$member.Name]At([=$QualifiedType] newValue, int index)
		{
[		if $member.IsSimpleType
]			ReplaceDomChildAt(NodeType.[=$member.NodeType], "[=$member.NamespaceURI]", "[=$member.SchemaName]", index, newValue.ToString());
[		else
]			ReplaceDomElementAt("[=$member.NamespaceURI]", "[=$member.SchemaName]", index, newValue);
[		endif
]		}
		#endregion // [=$member.Name] accessor methods

		#region [=$member.Name] collection
        public [=$member.Name]Collection	My[=$member.Name]s = new [=$member.Name]Collection( );

        public class [=$member.Name]Collection: IEnumerable
        {
            [=$class.Name] parent;
            public [=$class.Name] Parent
			{
				set
				{
					parent = value;
				}
			}
			public [=$member.Name]Enumerator GetEnumerator() 
			{
				return new [=$member.Name]Enumerator(parent);
			}
		
			IEnumerator IEnumerable.GetEnumerator() 
			{
				return GetEnumerator();
			}
        }

        public class [=$member.Name]Enumerator: IEnumerator 
        {
			int nIndex;
			[=$class.Name] parent;
			public [=$member.Name]Enumerator([=$class.Name] par) 
			{
				parent = par;
				nIndex = -1;
			}
			public void Reset() 
			{
				nIndex = -1;
			}
			public bool MoveNext() 
			{
				nIndex++;
				return(nIndex < parent.[=$member.Name]Count );
			}
			public [=$QualifiedType]  Current 
			{
				get 
				{
					return(parent.Get[=$member.Name]At(nIndex));
				}
			}
			object IEnumerator.Current 
			{
				get 
				{
					return(Current);
				}
			}
    	}

        #endregion // [=$member.Name] collection
[	next
]
[if $class.IsMixed
]		public void AddTextNode(SchemaString newValue)
		{
			AppendDomChild(NodeType.Text, "", "", newValue.ToString());
		}
		public void AddProcessingInstruction(SchemaString name, SchemaString newValue)
		{
			AppendDomChild(NodeType.ProcessingInstruction , "", name.ToString(), newValue.ToString());
		}
		public void AddCDataNode(SchemaString newValue)
		{
			AppendDomChild(NodeType.CData, "", "", newValue.ToString());
		}
		public void AddComment(SchemaString newValue)
		{
			AppendDomChild(NodeType.Comment, "", "", newValue.ToString());
		}
[endif
]        private void SetCollectionParents()
        {
[	foreach $member in $class.Members
]            My[=$member.Name]s.Parent = this; 
[	next
]	}
}
}
[else
	if $class.IsSimpleType and not $class.IsInternal
		$QualifiedBase = $class.Base
		if $class.Base = $class.BuiltInBase
			$IsDirectChild = true
		else
			$IsDirectChild = false
			if $class.HasBaseObject and $class.NamespacePrefix <> $class.BaseObject.NamespacePrefix
				$QualifiedBase = $class.BaseObject.NamespacePrefix & "." & $class.Base
			endif
		endif
]using Altova.Types;

namespace [=$QualifiedNamespace]
{

	public class [=$class.Name] : [=$QualifiedBase]
	{
[		foreach $facet in $class.Facets
			if $facet.IsEnumeration
]		public static string\[\] sEnumValues = {
[				foreach $enum in $facet.Enumeration
]			"[=$enum.ValueJava]",
[				next
]		};

		public enum EnumValues
		{
[				foreach $enum in $facet.Enumeration
]			[=$enum.Name] = [=$enum.Index], /* [=$enum.Value] */
[				next
]			EnumValueCount
		};
[			else : if $facet.IsPattern
]		public static string\[\] sPatternValues = {
[				foreach $pattern in $facet.Pattern
]			"[=$pattern.ValueJava]",
[				next
]		};

[			endif : endif
		next
]
		public [=$class.Name]() : base()
		{
		}

		public [=$class.Name](string newValue) : base(newValue)
		{
			Validate();
		}

		public [=$class.Name]([=$class.BuiltInBase] newValue) : base(newValue)
		{
			Validate();
		}

[		foreach $facet in $class.Facets
			if $facet.IsEnumeration
]		public static int GetEnumerationCount()
		{
			return sEnumValues.Length;
		}

		public static string GetEnumerationValue(int index)
		{
			return sEnumValues\[index\];
		}

		public static bool IsValidEnumerationValue(string val)
		{
			foreach (string s in sEnumValues)
			{
				if (val == s)
					return true;
			}
			return false;
		}

[			else : if $facet.IsPattern
]
		public static int GetPatternCount()
		{
			return sPatternValues.Length;
		}

		public static string GetPatternValue(int index)
		{
			return sPatternValues\[index\];
		}
[
			endif : endif
		next
]		public void Validate()
		{
[		foreach $facet in $class.Facets
			if $facet.IsMinLength
]			if (Value.Length < GetMinLength())
				throw new System.Exception("Value of [=$class.SchemaName] is too short.");
[			else:if $facet.IsMaxLength
]			if (Value.Length > GetMaxLength())
				throw new System.Exception("Value of [=$class.SchemaName] is too long.");
[			else:if $facet.IsLength]
			if (Value.Length != GetRequiredLength())
				throw new System.Exception("Value of [=$class.SchemaName] is not of the required length.");
[			else:if $facet.IsMinInclusive]
			if (CompareTo(GetMinInclusive()) < 0)
				throw new System.Exception("Value of [=$class.SchemaName] is out of range.");
[			else:if $facet.IsMinExclusive]
			if (CompareTo(GetMinExclusive()) <= 0)
				throw new System.Exception("Value of [=$class.SchemaName] is out of range.");
[			else:if $facet.IsMaxExclusive]
			if (CompareTo(GetMaxExclusive()) >= 0)
				throw new System.Exception("Value of [=$class.SchemaName] is out of range.");
[			else:if $facet.IsMaxInclusive]
			if (CompareTo(GetMaxInclusive()) > 0)
				throw new System.Exception("Value of [=$class.SchemaName] is out of range.");
[			else:if $facet.IsEnumeration]
			if (!IsValidEnumerationValue(ToString()))
				throw new System.Exception("Value of [=$class.SchemaName] is invalid.");
[			endif:endif:endif:endif:endif:endif:endif:endif
		next
]		}
[
		foreach $facet in $class.Facets
			if $facet.IsMinLength
]		public int GetMinLength()
		{
			return [=$facet.Constraint];
		}
[			else:if $facet.IsMaxLength
]		public int GetMaxLength()
		{
			return [=$facet.Constraint];
		}
[			else:if $facet.IsLength
]		public int GetRequiredLength()
		{
			return [=$facet.Constraint];
		}
[			else:if $facet.IsMinInclusive
]		public [=$class.BuiltInBase] GetMinInclusive()
		{
			return new [=$class.BuiltInBase]("[=$facet.Constraint]");
		}
[			else:if $facet.IsMinExclusive
]		public [=$class.BuiltInBase] GetMinExclusive()
		{
			return new [=$class.BuiltInBase]("[=$facet.Constraint]");
		}
[			else:if $facet.IsMaxExclusive
]		public [=$class.BuiltInBase] GetMaxExclusive()
		{
			return new [=$class.BuiltInBase]("[=$facet.Constraint]");
		}
[			else:if $facet.IsMaxInclusive
]		public [=$class.BuiltInBase] GetMaxInclusive()
		{
			return new [=$class.BuiltInBase]("[=$facet.Constraint]");
		}
[			endif:endif:endif:endif:endif:endif:endif
		next
]	}
}
[	endif
endif
]