////////////////////////////////////////////////////////////////////////
//
// Core.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include <Altova.h>
#include <SchemaTypes.h>
#include <AltovaException.h>
#include <SchemaTypeCalendar.h>
#include <SchemaTypeNumber.h>
#include <SchemaTypeString.h>
#include <SchemaTypeBinary.h>
#include "Core.h"


namespace altova {

////////////////////////////////////////////////////////////////////////
//
//  string functions
//
////////////////////////////////////////////////////////////////////////

CSchemaString Core::NormalizeSpace(const CSchemaString& rObj)
{
	tstring str = rObj;
	
	unsigned int o = 0;
	for ( unsigned long i = 0; i < str.length(); ++i )
	{
		if( str\[i\]==_T(' ') || str\[i\]==_T('\\n') || str\[i\]==_T('\\r') || str\[i\]==_T('\\t') )
		{
			if ( o > 0 && str\[o-1\] != _T(' ') )
				str\[o++\] = _T(' ');
		}
		else
			str\[o++\] = str\[i\];
	}
	if ( o > 0 && str\[o - 1\] == _T(' ') )
		str.erase( o - 1 );
	else
		if ( o < str.length() )
			str.erase( o );
	return CSchemaString(str);
}


CSchemaString Core::Substring(const CSchemaString& rString, const CSchemaTypeNumber& rStart, const CSchemaTypeNumber& rLength)
{ 
	tstring s = (tstring)rString;
	long nStart = rStart.ToLong() -1;
	long nLength = rLength.ToLong();
	if( nStart >= (long)s.length() || nStart + nLength < 0 )
		return CSchemaString();
	if( nLength > 0 )
		return CSchemaString( s.substr( nStart, nLength ) ); 
	else
		return CSchemaString( s.substr( nStart ) ); 
}


CSchemaString Core::SubstringAfter(const CSchemaString& rString, const CSchemaString& rSubStr)
{
	long nPos = ((tstring)rString).find((tstring)rSubStr);
	if( nPos < 0  ||  (nPos+((tstring)rSubStr).length()) == ((tstring)rString).length() )
		return CSchemaString();
	return CSchemaString( ((tstring)rString).substr(nPos+((tstring)rSubStr).length()) );
}


CSchemaString Core::SubstringBefore(const CSchemaString& rString, const CSchemaString& rSubStr)
{
	long nPos = ((tstring)rString).find((tstring)rSubStr);
	if( nPos < 1 )
		return CSchemaString();
	return CSchemaString( ((tstring)rString).substr(0, nPos) );
}


CSchemaString Core::Translate(const CSchemaString& rValue, const CSchemaString& rFrom, const CSchemaString& rTo)
{
	tstring sResult;
	tstring sValue = (tstring)rValue;
	tstring string1 = (tstring)rFrom;
	tstring string2 = (tstring)rTo;
	for (unsigned int nPosition = 0; nPosition < sValue.length(); nPosition++) 
	{
		TCHAR sActChar = sValue\[nPosition\];
		int nFindChar = string1.find(sActChar);
		if (nFindChar < 0) 
			sResult += sActChar;
		else 
			if (nFindChar < (int)string2.length()) 
				sResult += string2\[nFindChar\];
	}
	return CSchemaString(sResult);
}

CSchemaDecimal	Core::ToNumber(const CSchemaType& rObj)
{
	return CSchemaDecimal( rObj );
}

} // namespace altova
