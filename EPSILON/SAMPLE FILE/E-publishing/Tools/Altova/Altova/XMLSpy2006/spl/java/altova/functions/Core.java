/**
 * Core.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */
package com.altova.functions;

import java.math.BigDecimal;
import java.lang.String;
import com.altova.types.*;
import java.text.DecimalFormat;

public class Core {
  public static final int MAX_SCALE = 18;

  // ---------- logical functions ----------

  // result = logical-not( value )
  /* Logical boolean "NOT" function, if value is true then result is false, otherwise true.
  */
  public static SchemaBoolean logicalNot(SchemaType value ) {
    return new SchemaBoolean( !value.booleanValue() );
  }

  // result = logical-or( value1, value2 )
  /* Logical boolean "OR" function, if either values are true result is true, otherwise false.
  */
  public static SchemaBoolean logicalOr(SchemaType value1, SchemaType value2 ) {
    return new SchemaBoolean( value1.booleanValue() || value2.booleanValue() );
  }

  // result = logical-and( value1, value2 )
  /* Logical boolean "AND" function, if both values are true result is true, otherwise false.
  */
  public static SchemaBoolean logicalAnd(SchemaType value1, SchemaType value2 ) {
    return new SchemaBoolean( value1.booleanValue() && value2.booleanValue() );
  }

  // result = a equal b
  /* Result is true if a is equal b, otherwise false.
   */
  public static SchemaBoolean equal(SchemaString a, SchemaString b) {
    return new SchemaBoolean(a.equals(b));
  }
  
  // result = a equal b
  /* Result is true if a is equal b, otherwise false.
   */
  public static SchemaBoolean equal(SchemaType a, SchemaType b) {
    if (isNumber(a, b))
      return new SchemaBoolean(getCommonNumberInstance(a,b).equals(getCommonNumberInstance(b, a)));
    if (is_oneCalendar_oneString(a, b))
      return new SchemaBoolean(getCommonCalendarInstance(a,b).equals(getCommonCalendarInstance(b, a)));
    return new SchemaBoolean( a.equals(b) );
  }

  // result = a > b
  /* Result is true if a is greater than b, otherwise false.
   */
  public static SchemaBoolean greater(SchemaString a, SchemaString b) {
    return new SchemaBoolean( a.compareTo( b ) > 0 );
  }
  
  // result = a > b
  /* Result is true if a is greater than b, otherwise false.
   */
  public static SchemaBoolean greater(SchemaType a, SchemaType b) {
    if( isNumber(a, b))
      return new SchemaBoolean(getCommonNumberInstance(a,b).compareTo(getCommonNumberInstance(b, a)) > 0);
    if( is_oneCalendar_oneString(a, b))
      return new SchemaBoolean(getCommonCalendarInstance(a,b).compareTo(getCommonCalendarInstance(b, a)) > 0);
    return new SchemaBoolean( a.compareTo( b ) > 0 );
  }

  // result = a < b
  /* Result is true if a is less than b, otherwise false.
   */
  public static SchemaBoolean less(SchemaString a, SchemaString b) {
    return new SchemaBoolean( a.compareTo( b ) < 0 );
  }
  
  // result = a < b
  /* Result is true if a is less than b, otherwise false.
   */
  public static SchemaBoolean less(SchemaType a, SchemaType b) {
    if( isNumber(a, b))
      return new SchemaBoolean(getCommonNumberInstance(a,b).compareTo(getCommonNumberInstance(b, a)) < 0);
    if( is_oneCalendar_oneString(a, b))
      return new SchemaBoolean(getCommonCalendarInstance(a,b).compareTo(getCommonCalendarInstance(b, a)) < 0);
    return new SchemaBoolean( a.compareTo( b ) < 0 );
  }

  // result = logical-not( a equal b )
  /* Result is true if a is not equal b, otherwise false.
   */
  public static SchemaBoolean notEqual(SchemaString a, SchemaString b) {
    return new SchemaBoolean( !equal( a, b ).booleanValue() );
  }
  
  // result = logical-not( a equal b )
  /* Result is true if a is not equal b, otherwise false.
   */
  public static SchemaBoolean notEqual(SchemaType a, SchemaType b) {
    return new SchemaBoolean( !equal( a, b ).booleanValue() );
  }

  // result = a >= b
  /* Result is true if a is equal or greater than b, otherwise false.
   */
  public static SchemaBoolean equalOrGreater(SchemaString a, SchemaString b) {
    return new SchemaBoolean( !less( a, b ).booleanValue() );
  }
  
  // result = a >= b
  /* Result is true if a is equal or greater than b, otherwise false.
   */
  public static SchemaBoolean equalOrGreater(SchemaType a, SchemaType b) {
    return new SchemaBoolean( !less( a, b ).booleanValue() );
  }

  // result = a <= b
  /* Result is true if a is equal or less than b, otherwise false.
   */
  public static SchemaBoolean equalOrLess(SchemaString a, SchemaString b) {
    return new SchemaBoolean( !greater( a, b ).booleanValue() );
  }
  
  // result = a <= b
  /* Result is true if a is equal or less than b, otherwise false.
   */
  public static SchemaBoolean equalOrLess(SchemaType a, SchemaType b) {
    return new SchemaBoolean( !greater( a, b ).booleanValue() );
  }

  // ---------- mathematical functions ----------

  // result = value1 + value2
  /* Result is the numeric value of adding value1 and value2.
  */
  public static SchemaTypeNumber add(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() + value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() + value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().add( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( value1.floatValue() + value2.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( value1.doubleValue() + value2.doubleValue() );
    }
    return new SchemaDecimal( value1.bigDecimalValue().add( value2.bigDecimalValue() ) );
  }

  // result = value1 - value2
  /* Result is the numeric value of subtracting value2 from value1.
  */
  public static SchemaTypeNumber subtract(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() - value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() - value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().subtract( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( value1.floatValue() - value2.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( value1.doubleValue() - value2.doubleValue() );
    }
    return new SchemaDecimal(value1.bigDecimalValue().subtract(value2.bigDecimalValue()));
  }

  // result = value1 * value2
  /* Result is the numeric value of multiplying value1 with value2.
  */
  public static SchemaTypeNumber multiply(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() * value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() * value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().multiply( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( value1.floatValue() * value2.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( value1.doubleValue() * value2.doubleValue() );
    }
    return new SchemaDecimal(value1.bigDecimalValue().multiply( value2.bigDecimalValue()) );
  }

  // result = floor( value )
  /* Result is the largest integer that is not greater than the value.
  */
  public static SchemaTypeNumber floor(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.floor( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.floor( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.floor( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.floor( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.floor( value.doubleValue() ) );
    }
    return new SchemaDecimal( value.bigDecimalValue().setScale( 0, BigDecimal.ROUND_FLOOR  ) );
  }

  // result = ceiling( value )
  /* Result is the smallest integer that is not less than the value.
  */
  public static SchemaTypeNumber ceiling(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.ceil( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.ceil( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.ceil( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.ceil( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.ceil( value.doubleValue() ) );
    }
    return new SchemaDecimal( value.bigDecimalValue().setScale( 0, BigDecimal.ROUND_CEILING  ) );
  }

  // result = round( value )
  /* Result is the rounding of the value to the nearest integer.
  */
  public static SchemaTypeNumber round(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( java.lang.Math.round( value.floatValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( java.lang.Math.round( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( java.lang.Math.round( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( java.lang.Math.round( value.floatValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.round( value.doubleValue() ) );
    }
    return new SchemaDecimal( value.bigDecimalValue().setScale( 0, BigDecimal.ROUND_HALF_UP  ) );
  }

  // result = value1 / value2
  /* Result is the numeric value of dividing value1 with value2.
  */
  public static SchemaTypeNumber divide(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() / value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() / value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().divide( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( value1.floatValue() / value2.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( value1.doubleValue() / value2.doubleValue() );
    }
    SchemaDecimal result = new SchemaDecimal(value1.bigDecimalValue().divide( value2.bigDecimalValue(), MAX_SCALE, BigDecimal.ROUND_HALF_UP) );
    result.reduceScale();
    return result;
  }

  // result = value1 mod value2
  /* Result is the numeric value of modulus value1 with value2.
  */
  public static SchemaTypeNumber modulus(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() % value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() % value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().remainder( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (int)(value1.floatValue() % value2.floatValue()) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( (long)(value1.doubleValue() % value2.doubleValue()) );
    }
    return subtract( value1, multiply( divideInteger( value1, value2 ) , new SchemaDecimal( value2.bigDecimalValue() )) );
  }

  // ---------- string functions ----------

  // result = concat( string1, string2 )
  /* Returns the concatenation of string1 and string2.
  */
  public static SchemaString concat(SchemaString string1, SchemaString string2 ) {
    return new SchemaString( string1.getValue() + string2.getValue() );
  }

  // result = normalize-space( string )
  /* Removes leading and trailing spaces from the string.
  */
  public static SchemaString normalizeSpace(SchemaString string ) {
    return new SchemaString( string.getValue().trim() );
  }

  // result = starts-with( string, substr )
  /* Returns true if the string starts with the substr, otherwise it returns false.
  */
  public static SchemaBoolean startsWith(SchemaString string, SchemaString substr ) {
    return new SchemaBoolean( string.getValue().startsWith( substr.getValue() ) );
  }

  // result = string-length( string )
  /* Returns the number of characters in the string.
  */
  public static SchemaTypeNumber stringLength(SchemaString string ) {
    return new SchemaInt( string.getValue().length() );
  }

  // result = substring( string, start \[,length\] )
  /* Returns part of the string, beginning at start with the length number of characters.
  */
  public static SchemaString substring(SchemaString string, SchemaTypeNumber start, SchemaTypeNumber length ) {
    try {
    	int nStart = start.intValue() - 1;
		int nLength = length.intValue();
		if( nStart + nLength >= 0 )
		{
			if( nLength > 0 )
				return new SchemaString(string.getValue().substring(nStart, Math.min(nStart + nLength, string.getValue().length())));
			else
				return new SchemaString(string.getValue().substring(nStart));
		}
		else
			return new SchemaString();
    } catch( IndexOutOfBoundsException e ) {
      return new SchemaString();
    }
  }

  // result = substring-after( string, substr )
  /* Returns the part of the string that occurs after the substr.
  */
  public static SchemaString substringAfter(SchemaString string, SchemaString substr ) {
    int position = string.getValue().indexOf( substr.getValue() );
    if( position >= 0 )
      return new SchemaString(string.getValue().substring(position +
          substr.getValue().length()));
    else
      return new SchemaString("");
  }

  // result = substring-before( string, substr )
  /* Returns the part of the string that occurs before the substr.
  */
  public static SchemaString substringBefore(SchemaString string, SchemaString substr ) {
    int position = string.getValue().indexOf( substr.getValue() );
    if( position > 0 )
      return new SchemaString(string.getValue().substring(0, position));
    else
      return new SchemaString("");
  }

  // result = translate( value, string1, string2 )
  /* Performs a character by character replacement. It looks in the value for characters contained in string1, and replaces each character for the one in the same position in the string2.
  */
  public static SchemaString translate(SchemaString value, SchemaString string1, SchemaString string2 ) {
    String sResult = new String();
    try {
      for (int nPosition = 0; nPosition < value.getValue().length(); nPosition++) {
        String sActChar = value.getValue().substring(nPosition, nPosition + 1);
        int nFindChar = string1.getValue().indexOf(sActChar);
        if (nFindChar < 0) {
          sResult = sResult + sActChar;
        }
        else {
          if (nFindChar < string2.getValue().length()) {
            sResult = sResult +
                string2.getValue().substring(nFindChar, nFindChar + 1);
          }
        }
      }
      return new SchemaString(sResult);
    } catch( IndexOutOfBoundsException e) {
      return new SchemaString();
    }
  }

  // result = contains( value, substring )
  /* Returns true if the first argument string contains the second argument string; otherwise returns false.
   */
  public static SchemaBoolean contains(SchemaString value, SchemaString substr ) {
   return new SchemaBoolean( value.getValue().indexOf( substr.getValue() ) >= 0 );
  }

  // ---------- conversion functions ----------

  // result = boolean ( arg )
  /* Converts the value of arg to a boolean value.
  */
  public static SchemaBoolean ToBoolean(SchemaType a) {
    return new SchemaBoolean( a );
  }

  // result = number ( arg )
  /* Converts the value of arg to a number.
  */
  public static SchemaDecimal ToNumber(SchemaType a) {
    return new SchemaDecimal( a );
  }

  // result = string ( arg )
  /* Converts the value of arg to a string.
  */
  public static SchemaString ToString(SchemaType a) {
    return new SchemaString( a );
  }


  // ---------- helpers ----------
  protected static boolean isNumber(SchemaType a) {
    if( a instanceof SchemaString )
      return ((SchemaString)a).isValueNumeric();
    return( a instanceof SchemaTypeNumber );
  }

  protected static boolean isNumber(SchemaType a, SchemaType b) {
    return( isNumber(a) && isNumber(b) );
  }

  protected static SchemaTypeNumber getCommonNumberInstance(int numericType, SchemaTypeNumber a_value) {
    switch( numericType ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( a_value.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( a_value.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( a_value.bigIntegerValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( a_value.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( a_value.doubleValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGDECIMAL:
        return new SchemaDecimal( a_value.bigDecimalValue() );
    }
    return null;
  }

  protected static SchemaType getCommonNumberInstance(SchemaType a_value, SchemaType b) {
    return (SchemaType)getCommonNumberInstance( java.lang.Math.max( ((SchemaTypeNumber)a_value).numericType(), ((SchemaTypeNumber)b).numericType()), (SchemaTypeNumber)a_value );
  }

  protected static boolean isCalendar(SchemaType a) {
    return (a instanceof SchemaCalendarBase);
  }

  protected static boolean is_oneCalendar_oneString(SchemaType a, SchemaType b) {
    return (isCalendar(a) && b instanceof SchemaString) ||
        (isCalendar(b) && a instanceof SchemaString);
  }

  protected static SchemaType getCommonCalendarInstance(SchemaType a_value, SchemaType b) {
    switch (java.lang.Math.max( ( (SchemaTypeCalendar) a_value).calendarType(),( (SchemaTypeCalendar) b).calendarType())) {
      case SchemaTypeCalendar.CALENDAR_VALUE_DURATION:
        return new SchemaDuration( ( (SchemaTypeCalendar) a_value).durationValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_DATETIME:
        return new SchemaDateTime( ( (SchemaTypeCalendar) a_value).dateTimeValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_DATE:
        return new SchemaDate( ( (SchemaTypeCalendar) a_value).dateValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_TIME:
        return new SchemaTime( ( (SchemaTypeCalendar) a_value).timeValue());
    }
    throw new ValuesNotConvertableException(a_value, b);
  }

  // result = value1 div value2
  /* Result is the numeric value of integer dividing value1 with value2.
  */
  protected static SchemaTypeNumber divideInteger(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() / value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() / value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().divide( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (int)(value1.floatValue() / value2.floatValue()) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( (long)(value1.doubleValue() / value2.doubleValue()) );
    }
    return new SchemaDecimal(value1.bigDecimalValue().divide( value2.bigDecimalValue(), 0, BigDecimal.ROUND_DOWN ));
  }

}