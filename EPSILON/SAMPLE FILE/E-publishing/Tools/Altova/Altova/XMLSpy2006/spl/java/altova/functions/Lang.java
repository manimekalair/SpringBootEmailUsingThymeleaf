/**
 * Lang.java
 *
 * This file was generated by [=$Host].
 *
 * YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
 * OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
 *
 * Refer to the [=$HostShort] Documentation for further details.
 * [=$HostURL]
 */
package com.altova.functions;

import java.math.BigDecimal;
import java.lang.String;
import java.lang.Character;
import java.util.Calendar;
import java.util.TimeZone;
import java.util.GregorianCalendar;
import java.util.Hashtable;

import com.altova.types.*;


public class Lang {

  private static Hashtable _s_InstanceIDs = new Hashtable();

  // ---------- logical functions ----------

  // result = logical-xor( value1, value2 )
  /* Logical boolean "XOR" function, if values are different then result is true, otherwise false.
  */
  public static SchemaBoolean logicalXor(SchemaType value1, SchemaType value2 ) {
    return new SchemaBoolean( value1.booleanValue() ^ value2.booleanValue() );
  }

  // result = value >= 0
  /* Result is true if value is positive (greater or equal zero), otherwise false.
  */
  public static SchemaBoolean positive(SchemaTypeNumber value ) {
    SchemaType n0 = new SchemaInt( 0 );
    return new SchemaBoolean(getCommonNumberInstance((SchemaType)value,n0).compareTo(getCommonNumberInstance(n0, (SchemaType)value)) >= 0);
  }

  // result = value < 0
  /* Result is true if value is negative (less than zero), otherwise false.
  */
  public static SchemaBoolean negative(SchemaTypeNumber value ) {
    return new SchemaBoolean( !positive( value ).booleanValue() );
  }

  // result = numeric( value )
  /* Returns true if the given value is a number, otherwise false.
  */
  public static SchemaBoolean numeric(SchemaType value ) {
    return new SchemaBoolean( isNumber(value) );
  }

  // ---------- mathematical functions ----------

  // result = value1 div value2
  /* Result is the numeric value of integer dividing value1 with value2.
  */
  public static SchemaTypeNumber divideInteger(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( value1.intValue() / value2.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( value1.longValue() / value2.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().divide( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (int)(value1.floatValue() / value2.floatValue()) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( (long)(value1.doubleValue() / value2.doubleValue()) );
    }
    return new SchemaDecimal(value1.bigDecimalValue().divide( value2.bigDecimalValue(), 0, BigDecimal.ROUND_DOWN ));
  }

  // result = -value
  /* Result is the numeric value of -value.
  */
  public static SchemaTypeNumber unaryMinus(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( -value.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( -value.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value.bigIntegerValue().negate() ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( -value.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( -value.doubleValue() );
    }
    return new SchemaDecimal( value.bigDecimalValue().negate() );
  }

  // result = max( value1, value2 )
  /* Result is the numeric value of the largest value.
  */
  public static SchemaTypeNumber max(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( java.lang.Math.max(value1.intValue(), value2.intValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( java.lang.Math.max(value1.longValue(), value2.longValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().max( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( java.lang.Math.max(value1.floatValue(), value2.floatValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.max(value1.doubleValue(), value2.doubleValue()) );
    }
    return new SchemaDecimal( value1.bigDecimalValue().max( value2.bigDecimalValue() ) );
  }

  // result = min( value1, value2 )
  /* Result is the numeric value of the smallest value.
  */
  public static SchemaTypeNumber min(SchemaTypeNumber value1, SchemaTypeNumber value2 ) {
    switch( java.lang.Math.max( value1.numericType(), value2.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( java.lang.Math.min(value1.intValue(), value2.intValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( java.lang.Math.min(value1.longValue(), value2.longValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( value1.bigIntegerValue().min( value2.bigIntegerValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( java.lang.Math.min(value1.floatValue(), value2.floatValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.min(value1.doubleValue(), value2.doubleValue()) );
    }
    return new SchemaDecimal( value1.bigDecimalValue().min( value2.bigDecimalValue() ) );
  }

  // result = pi()
  public static SchemaTypeNumber pi() {
    return new SchemaDouble( java.lang.Math.PI );
  }

  // result = sin(value)
  /* Result is the trigonometric sine of the angle given by value. The unit of value is radian.
  */
  public static SchemaTypeNumber sin(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.sin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.sin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.sin( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.sin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.sin( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.sin( value.doubleValue() ) );
  }

  // result = cos(value)
  /* Result is the trigonometric cosine of the angle given by value. The unit of value is radian.
  */
  public static SchemaTypeNumber cos(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.cos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.cos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.cos( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.cos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.cos( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.cos( value.doubleValue() ) );
  }

  // result = tan(value)
  /* Result is the trigonometric tangent of the angle given by value. The unit of value is radian.
  */
  public static SchemaTypeNumber tan(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.tan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.tan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.tan( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.tan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.tan( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.tan( value.doubleValue() ) );
  }

  // result = asin(value)
  /* Returns the arc sine of an angle, in the range of -pi/2 through pi/2.
  */
  public static SchemaTypeNumber asin(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.asin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.asin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.asin( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.asin( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.asin( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.asin( value.doubleValue() ) );
  }

  // result = acos(value)
  /* Returns the arc cosine of an angle, in the range of -pi/2 through pi/2.
  */
  public static SchemaTypeNumber acos(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.acos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.acos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.acos( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.acos( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.acos( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.acos( value.doubleValue() ) );
  }

  // result = atan(value)
  /* Returns the arc tangent of an angle, in the range of -pi/2 through pi/2.
  */
  public static SchemaTypeNumber atan(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.atan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.atan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.atan( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.atan( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.atan( value.doubleValue() ) );
    }
    return new SchemaDecimal( java.lang.Math.atan( value.doubleValue() ) );
  }

  // result = radians(value)
  /* Converts an angle measured in degrees to an approximately equivalent angle measured in radians.
  */
  public static SchemaTypeNumber radians(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
     case SchemaTypeNumber.NUMERIC_VALUE_INT:
       return new SchemaInt( (int)java.lang.Math.toRadians( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_LONG:
       return new SchemaLong( (long)java.lang.Math.toRadians( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
       return new SchemaInteger( (long)java.lang.Math.toRadians( value.doubleValue() ) ); // note: possible loss of precision
     case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
       return new SchemaFloat( (float)java.lang.Math.toRadians( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
       return new SchemaDouble( java.lang.Math.toRadians( value.doubleValue() ) );
   }
   return new SchemaDecimal( java.lang.Math.toRadians( value.doubleValue() ));
  }

  // result = degrees(value)
  /* Converts an angle measured in radians to an approximately equivalent angle measured in degrees.
  */
  public static SchemaTypeNumber degrees(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
     case SchemaTypeNumber.NUMERIC_VALUE_INT:
       return new SchemaInt( (int)java.lang.Math.toDegrees( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_LONG:
       return new SchemaLong( (long)java.lang.Math.toDegrees( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
       return new SchemaInteger( (long)java.lang.Math.toDegrees( value.doubleValue() ) ); // note: possible loss of precision
     case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
       return new SchemaFloat( (float)java.lang.Math.toDegrees( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
       return new SchemaDouble( java.lang.Math.toDegrees( value.doubleValue() ) );
   }
    return new SchemaDecimal(java.lang.Math.toDegrees( value.doubleValue() ));
  }

  // result = abs(value)
  /* Returns the absolute value. If the argument is not negative, the argument is returned. If the argument is negative, the negation of the argument is returned.
  */
  public static SchemaTypeNumber abs(SchemaTypeNumber value ) {
    if( negative( value ).booleanValue() )
      return unaryMinus( value );
    return getCommonNumberInstance( value.numericType(), value );
  }

  // result = exp(value)
  /* Returns Euler's number e raised to the power of the value.
  */
  public static SchemaTypeNumber exp(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
     case SchemaTypeNumber.NUMERIC_VALUE_INT:
       return new SchemaInt( (int)java.lang.Math.exp( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_LONG:
       return new SchemaLong( (long)java.lang.Math.exp( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
       return new SchemaInteger( (long)java.lang.Math.exp( value.doubleValue() ) ); // note: possible loss of precision
     case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
       return new SchemaFloat( (float)java.lang.Math.exp( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
       return new SchemaDouble( java.lang.Math.exp( value.doubleValue() ) );
   }
   return new SchemaDecimal(java.lang.Math.exp( value.doubleValue() ));
  }

  // result = log(value)
  /* Returns the natural logarithm (base e) of a value
  */
  public static SchemaTypeNumber log(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
     case SchemaTypeNumber.NUMERIC_VALUE_INT:
       return new SchemaInt( (int)java.lang.Math.log( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_LONG:
       return new SchemaLong( (long)java.lang.Math.log( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
       return new SchemaInteger( (long)java.lang.Math.log( value.doubleValue() ) ); // note: possible loss of precision
     case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
       return new SchemaFloat( (float)java.lang.Math.log( value.doubleValue() ) );
     case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
       return new SchemaDouble( java.lang.Math.log( value.doubleValue() ) );
   }
   return new SchemaDecimal(java.lang.Math.log( value.doubleValue() ));
  }

  // result = log10(value)
  /* Returns the decimal logarithm (base 10) of a value.
  */
  public static SchemaTypeNumber log10(SchemaTypeNumber value ) {
    switch (value.numericType()) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)(java.lang.Math.log(value.doubleValue())/ java.lang.Math.log(10.0)));
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)(java.lang.Math.log(value.doubleValue())/ java.lang.Math.log(10.0)));
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)(java.lang.Math.log(value.doubleValue())/ java.lang.Math.log(10.0))); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)(java.lang.Math.log(value.doubleValue())/ java.lang.Math.log(10.0)));
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble(java.lang.Math.log(value.doubleValue())/ java.lang.Math.log(10.0));
    }
    return new SchemaDecimal(java.lang.Math.log(value.doubleValue()) / java.lang.Math.log(10.0));
  }

  // result = a ^ b
  /* Returns the value of a raised to the power of b.
  */
  public static SchemaTypeNumber pow(SchemaTypeNumber a, SchemaTypeNumber b ) {
    switch( java.lang.Math.max( a.numericType(), b.numericType()) ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.pow(a.doubleValue(), b.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.pow(a.doubleValue(), b.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.pow( a.doubleValue(), b.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.pow(a.doubleValue(), b.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.pow(a.doubleValue(), b.doubleValue()) );
    }
    return new SchemaDecimal(java.lang.Math.pow( a.doubleValue(), b.doubleValue() ));
  }

  // result = random()
  /* Returns a value with a positive sign, greater than or equal to 0.0 and less than 1.0.
     Returned values are chosen pseudorandomly with (approximately) uniform distribution from that range.
   */
  public static SchemaTypeNumber random() {
    return new SchemaDouble(java.lang.Math.random());
  }

  // result = sqrt(value)
  /* Returns the correctly rounded positive square root of a value.
  */
  public static SchemaTypeNumber sqrt(SchemaTypeNumber value ) {
    switch( value.numericType() ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( (int)java.lang.Math.sqrt( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( (long)java.lang.Math.sqrt( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( (long)java.lang.Math.sqrt( value.doubleValue() ) ); // note: possible loss of precision
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( (float)java.lang.Math.sqrt( value.doubleValue() ) );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( java.lang.Math.sqrt( value.doubleValue() ) );
    }
    return new SchemaDecimal(java.lang.Math.sqrt( value.doubleValue()) );
  }

  // ---------- string functions ----------

  // result = uppercase( string )
  /* Result is the uppercase version of all the characters in the string.
  */
  public static SchemaString uppercase(SchemaString string ) {
    return new SchemaString( string.getValue().toUpperCase() );
  }

  // result = lowercase( string )
  /* Result is the lowercase version of all the characters in the string.
  */
  public static SchemaString lowercase(SchemaString string ) {
    return new SchemaString( string.getValue().toLowerCase() );
  }

  // result = capitalize( value )
  /* Turns every first character of a word into upper-case letters.
  */
  public static SchemaString capitalize(SchemaString value ) {
    String sResult = value.getValue();
    int nPos = -1;
    while( true )
    {
      if( nPos < sResult.length()-1 ) {
        sResult = sResult.substring( 0, nPos+1 ) + sResult.substring( nPos + 1, nPos + 2).toUpperCase() + sResult.substring( nPos+2, sResult.length());
      }
      nPos = sResult.indexOf( " ", nPos + 1);
	  if( nPos < 0 )
		  break;
    }
    return new SchemaString( sResult );
  }

  // result = char-from-code( value )
  /* Returns a string with the character given by the numeric code.
  */
  public static SchemaString charFromCode(SchemaTypeNumber value ) {
    Character c = new Character( (char)value.intValue() );
    return new SchemaString( c.toString() );
  }

  // result = code-from-char( value )
  /* Returns the numeric code of the first character given by the string value.
  */
  public static SchemaTypeNumber codeFromChar(SchemaString value ) {
    return new SchemaInt( (int)value.getValue().charAt(0) );
  }

  // result = string-compare( string1, string2 )
  /* Performes a string comparation considering case of characters. Returns 0 if strings are equal. Returns -1 if string1 < string2. Returns +1 if string1 > string2.
  */
  public static SchemaTypeNumber stringCompare(SchemaString string1, SchemaString string2 ) {
    return new SchemaInt( string1.getValue().compareTo( string2.getValue()) );
  }

  // result = string-compare-ignore-case( string1, string2 )
  /* Performes a string comparation ignoring the case of characters. Returns 0 if strings are equal. Returns -1 if string1 < string2. Returns +1 if string1 > string2.
  */
  public static SchemaTypeNumber stringCompareIgnoreCase(SchemaString string1, SchemaString string2 ) {
    return new SchemaInt( string1.getValue().compareToIgnoreCase( string2.getValue()) );
  }

  // result = count-substring( string, substr )
  /* Returns the numer of times substr is contained inside string.
  */
  public static SchemaTypeNumber countSubstring(SchemaString string, SchemaString substr ) {
    int nPosition = string.getValue().indexOf( substr.getValue() );
    int nResult = 0;
    while( nPosition >= 0 ) {
      nResult++;
      nPosition = string.getValue().indexOf( substr.getValue(), nPosition+1 );
    }
    return new SchemaInt( nResult );
  }

  // result = match-pattern( string, substr )
  /* Tells whether or not this string matches the given regular expression.
  */
  public static SchemaBoolean matchPattern(SchemaString string, SchemaString pattern ) {
    return new SchemaBoolean( string.getValue().matches( pattern.getValue( )));
  }

  // result = find-substring( string, substr \[,startindex\] )
  /* Returns the index within the string of the first occurrence of the specified substring, starting at the specified index. The first character has index=1. If the substring was not found 0 is returned.
  */
  public static SchemaTypeNumber findSubstring(SchemaString string, SchemaString substr, SchemaTypeNumber startindex ) {
		int nStart = startindex.intValue();
		if( nStart > 0 )
			return new SchemaInt( string.getValue().indexOf( substr.getValue(), nStart-1)+1 );
		else
			return new SchemaInt( string.getValue().indexOf( substr.getValue())+1 );
  }

  // result = reversefind-substring( string, substr \[,endindex\] )
  /* Returns the index within this string of the rightmost occurrence of the specified substring, starting at the specified index. The first character has index=0. If the substring was not found -1 is returned.
  */
  public static SchemaTypeNumber reversefindSubstring(SchemaString string, SchemaString substr, SchemaTypeNumber endindex ) {
    int nLastPosition = -1;
    int nActPosition = string.getValue().indexOf( substr.getValue() );
	int nEndIndex = endindex.intValue();
	if( nEndIndex < 0 )
		nEndIndex = string.toString().length();
    while( nActPosition > -1  &&  nActPosition < nEndIndex ) { // note: endindex is 1 based
      nLastPosition = nActPosition;
      nActPosition = string.getValue().indexOf( substr.getValue(), nActPosition+1 );
    }
    return new SchemaInt( nLastPosition+1 );
  }

  // result = left( string, number)
  /* Returns a string with the given number of characters on the left of the given string.
  */
  public static SchemaString left(SchemaString string, SchemaTypeNumber number ) {
    try {
      return new SchemaString(string.getValue().substring(0, number.intValue()));
    } catch( IndexOutOfBoundsException e ) {
      return new SchemaString( string );
    }
  }

  // result = left-trim( string )
  /* Removes whitespaces on the left end of the given string.
  */
  public static SchemaString leftTrim(SchemaString string ) {
    String s = string.getValue();
    int nPosition = 0;
    while( nPosition < s.length() && Character.isWhitespace(s.charAt(nPosition) ) ) {
      nPosition++;
    }
    try {
      return new SchemaString(string.getValue().substring(nPosition,
          string.getValue().length()));
    } catch( IndexOutOfBoundsException e) {
      return new SchemaString(string);
    }
  }

  // result = right( string, number)
  /* Returns a string with the given number of characters on the right side of the given string.
  */
  public static SchemaString right(SchemaString string, SchemaTypeNumber number ) {
    String s = string.getValue();
    try {
      return new SchemaString(s.substring(s.length() - number.intValue(),
                                          s.length()));
    } catch( IndexOutOfBoundsException e) {
      return new SchemaString( string );
    }
  }

  // result = right-trim( string )
  /* Removes whitespaces on the right end of the given string.
  */
  public static SchemaString rightTrim(SchemaString string ) {
    String s = string.getValue();
    int nPosition = s.length();
    while( nPosition > 0 && Character.isWhitespace(s.charAt(nPosition-1) ) ){
      nPosition--;
    }
    try {
      return new SchemaString(s.substring(0, nPosition));
    } catch( IndexOutOfBoundsException e ) {
      return new SchemaString( string );
    }
  }

  // result = replace( value, oldstring, newstring )
  /* Replaces each substring of this string that matches the given oldstring with the given newstring.
  */
  public static SchemaString replace(SchemaString value, SchemaString oldstring, SchemaString newstring ) {
    String sResult = value.getValue();
    int nPos = sResult.indexOf( oldstring.getValue() );
    while( nPos >= 0 ) {
      sResult = sResult.substring( 0, nPos ) + newstring.getValue() + sResult.substring( nPos+oldstring.getValue().length(), sResult.length());
      nPos = sResult.indexOf( oldstring.getValue(), nPos+newstring.getValue().length() );
    }
    return new SchemaString( sResult );
  }

  // result = empty( value )
  /* Returns true if the string value is empty. Otherwise false is returned.
   */
  public static SchemaBoolean empty(SchemaString value) {
	return new SchemaBoolean( value.getValue().length()==0 );
  }

  // formated_guid = format-guid-string( unformated_guid )
  /* Formats a GUID correctly to use it in databases.
   */ 
  public static SchemaString formatGuidString(SchemaString val) {
    String sGuid = val.toString();
    if( sGuid.length() != 32 )
      return new SchemaString();		// input value is not correct

    String sBuffer;
    String sResult = "";
    for( int i=0; i<16; ++i ) {
      sBuffer = sGuid.substring( i*2, 2 );
      sResult += sBuffer;

      if( i==3 || i==5 || i==7 || i==9 )
        sResult += "-";		// format correctly because it is used as string.
    }
    return new SchemaString( sResult );
  }

  // ---------- datetime functions ----------

  // result = datetime + duration
  /* Performs a addition of dates, times and durations.
  */
  public static SchemaDateTime datetimeAdd(SchemaDateTime datetime, SchemaDuration duration ) {
    Calendar dt1 = (Calendar)datetime.getValue();
    int hasTZ = datetime.hasTimezone(); // backup TZ settings because Calendar would overwrite it
    int offsetTZ = datetime.getTimezoneOffset();
    if( duration.isNegative() ) {
      dt1.add(Calendar.MILLISECOND, -duration.getMillisecond());
      dt1.add(Calendar.SECOND, -duration.getSecond());
      dt1.add(Calendar.MINUTE, -duration.getMinute());
      dt1.add(Calendar.HOUR_OF_DAY, -duration.getHour());
      dt1.add(Calendar.DAY_OF_MONTH, -duration.getDay());
      dt1.add(Calendar.MONTH, -duration.getMonth());
      dt1.add(Calendar.YEAR, -duration.getYear());
    }
    else {
      dt1.add(Calendar.MILLISECOND, duration.getMillisecond());
      dt1.add(Calendar.SECOND, duration.getSecond());
      dt1.add(Calendar.MINUTE, duration.getMinute());
      dt1.add(Calendar.HOUR_OF_DAY, duration.getHour());
      dt1.add(Calendar.DAY_OF_MONTH, duration.getDay());
      dt1.add(Calendar.MONTH, duration.getMonth());
      dt1.add(Calendar.YEAR, duration.getYear());
    }
    SchemaDateTime result = new SchemaDateTime(dt1);
    result.setTimezone(hasTZ, offsetTZ); // restore TZ settings
    return result;
  }

  // result = datetime1 - datetime2
  /* Result is the datetime value of subtracting datetime2 from datetime1.
  */
  public static SchemaDuration datetimeDiff(SchemaDateTime datetime1, SchemaDateTime datetime2 ) {
    double resultseconds = datetime1.getApproximatedTotal() - datetime2.getApproximatedTotal();
    SchemaDuration dur = new SchemaDuration( "PT0S" );
    if( resultseconds < 0 ) {
      dur.setNegative(true);
      resultseconds = -resultseconds;
    }
    long result = (long)(java.lang.Math.floor( resultseconds ));
    dur.setPartSecond( resultseconds - result );
    dur.setSecond( (int)(result % 60) );
    result = result / 60;
    dur.setMinute( (int)(result % 60) );
    result = result / 60;
    dur.setHour( (int)(result % 24) );
    result = result / 24;
    dur.setDay( (int)(result % 31) );
    if( result > 28 ) {
      System.err.println("WARNING: Lang.datetimeDiff() result may not be exact, because days of month approximated to be 31!");
      result = result / 31;

      dur.setMonth( (int)(result % 12) );
      result = result / 12;
      dur.setYear( (int)result );
    }
    return dur;
  }

  // result = datetime-from-parts( year, month, day , \[hour \[, minute \[, second \[, millisecond \[, timezone \]\]\]\]\])
  /* The result is the datetime value consisting of the parts given by year, month, day, hour, minute and second.
  */
  public static SchemaDateTime datetimeFromParts(SchemaTypeNumber year, SchemaTypeNumber month, SchemaTypeNumber day, SchemaTypeNumber hour /* optional */, SchemaTypeNumber minute /* optional */, SchemaTypeNumber second /* optional */, SchemaTypeNumber millisecond /* optional */, SchemaTypeNumber timezone /* optional */ ) {
    SchemaDateTime result = new SchemaDateTime( year.intValue(), month.intValue(), day.intValue(), hour.intValue(), minute.intValue(), second.intValue(), 0);
    result.setMillisecond( millisecond.intValue() );
    if( timezone.intValue() >= -1440  &&  timezone.intValue() <= 1440 )
      result.setTimezone( SchemaCalendarBase.TZ_OFFSET, timezone.intValue() );
    return result;
  }

  // result = datetime-from-date-and-time( datevalue \[,timevalue\] )
  /* The result is the datetime value built of datevalue and timevalue.
   */
  public static SchemaDateTime datetimeFromDateAndTime(SchemaDate datevalue, SchemaTime timevalue /* optional */) {
    if( timevalue.hasTimezone() == SchemaCalendarBase.TZ_OFFSET )
	  return new SchemaDateTime( datevalue.getYear(), datevalue.getMonth(), datevalue.getDay(), timevalue.getHour(), timevalue.getMinute(), timevalue.getSecond(), timevalue.getPartSecond(), timevalue.getTimezoneOffset() );

    SchemaDateTime result = new SchemaDateTime( datevalue.getYear(), datevalue.getMonth(), datevalue.getDay(), timevalue.getHour(), timevalue.getMinute(), timevalue.getSecond(), timevalue.getPartSecond() );
	result.setTimezone( timevalue.hasTimezone(), 0 );

	return result;
  }

  // result = date-from-datetime( value )
  /* Returns the date-part of the given datetime value.
   */
  public static SchemaDate dateFromDatetime( SchemaDateTime value ) {
	return value.dateValue();
  }

  // result = time-from-datetime( value )
  /* Returns the time-part of the given datetime value.
   */
  public static SchemaTime timeFromDatetime( SchemaDateTime value ) {
    return value.timeValue();
  }

  // result = day( value )
  /* Returns the day of the given datetime value.
  */
  public static SchemaTypeNumber dayFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getDay() );
  }

  // result = now()
  /* Returns the actual date and time.
   */
  public static SchemaDateTime now() {
    return SchemaDateTime.now();
  }

  // result = hours( value )
  /* Returns the hours of the given datetime value.
  */
  public static SchemaTypeNumber hourFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getHour() );
  }

  // result = holiday( value )
  /* Returns true if the given date is a holiday.
  */
  public static SchemaBoolean holiday(SchemaDateTime value ) {
    // !!!!! implementation
    return new SchemaBoolean( false );
  }

  // result = leapyear( value )
  /* Returns true if the given year of the date is a leapyear.
  */
  public static SchemaBoolean leapyear(SchemaDateTime value ) {
    return new SchemaBoolean( new GregorianCalendar().isLeapYear( value.getYear() ) );
  }

  // result = milliseconds( value )
  /* Returns the milliseconds of the given datetime value.
  */
  public static SchemaTypeNumber millisecondFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getMillisecond() );
  }

  // result = minutes( value )
  /* Returns the minutes of the given datetime value.
  */
  public static SchemaTypeNumber minuteFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getMinute() );
  }

  // result = month( value )
  /* Returns the month of the given datetime value.
  */
  public static SchemaTypeNumber monthFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getMonth() );
  }

  // result = seconds( value )
  /* Returns the seconds of the given datetime value.
  */
  public static SchemaTypeNumber secondFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getSecond() );
  }

  // result = timezone( value )
  /* Returns the timezone of the given datetime value.
  */
  public static SchemaTypeNumber timezone(SchemaDateTime value ) {
    return new SchemaInt( value.getTimezoneOffset() );
  }

  // result = weekday( value )
  /* Returns the day of week of the given datetime value. Sunday=1, Monday=2,...
  */
  public static SchemaTypeNumber weekday(SchemaDateTime value ) {
	  long a = ( 14 - value.getMonth() ) / 12;
	  long m = value.getMonth() + 12 * a - 3;
	  long y = value.getYear() + 4800 - a;

	  long JD = value.getDay() + (153 * m + 2) / 5 + y*365 + y/4 - y/100 + y/400 - 32045;

	  return new SchemaInt( (int)(JD % 7 + 1) );
  }

  // result = weeknumber( value )
  /* Returns the number of the week within the year of the given datetime value.
  */
  public static SchemaTypeNumber weeknumber(SchemaDateTime value ) {
	  long a = ( 14 - value.getMonth() ) / 12;
	  long m = value.getMonth() + 12 * a - 3;
	  long y = value.getYear() + 4800 - a;

	  long JD = value.getDay() + (153 * m + 2) / 5 + y*365 + y/4 - y/100 + y/400 - 32045;
	
	  long d4 = (JD+31741 - ( JD % 7 ) ) % 146097 % 36524 % 1461;
	  long L = d4/1460;
	  long d1 = ((d4-L) % 365) + L;

	  return new SchemaInt( (int)(d1/7+1) );
  }

  // result = year( value )
  /* Returns the year of the given datetime value.
  */
  public static SchemaTypeNumber yearFromDatetime(SchemaDateTime value ) {
    return new SchemaInt( value.getYear() );
  }

  // result = duration1 + duration2
  /* Returns the addition of two durations.
   */
  public static SchemaDuration durationAdd(SchemaDuration duration1, SchemaDuration duration2) {
    SchemaDuration dur = new SchemaDuration( "PT0S" );
    dur.setYear( duration1.getYear() + duration2.getYear() );
    dur.setMonth( duration1.getMonth() + duration2.getMonth() );
    dur.setDay( duration1.getDay() + duration2.getDay() );
    dur.setHour( duration1.getHour() + duration2.getHour() );
    dur.setMinute( duration1.getMinute() + duration2.getMinute() );
    dur.setSecond( duration1.getSecond() + duration2.getSecond() );
    dur.setMillisecond( duration1.getMillisecond() + duration2.getMillisecond());
    return dur;
  }

  // result = duration1 - duration2
  /* Returns the subtraction of two durations.
   */
  public static SchemaDuration durationSubtract(SchemaDuration duration1, SchemaDuration duration2) {
    SchemaDuration dur = new SchemaDuration( "PT0S" );
    dur.setYear( duration1.getYear() - duration2.getYear() );
    dur.setMonth( duration1.getMonth() - duration2.getMonth() );
    dur.setDay( duration1.getDay() - duration2.getDay() );
    dur.setHour( duration1.getHour() - duration2.getHour() );
    dur.setMinute( duration1.getMinute() - duration2.getMinute() );
    dur.setSecond( duration1.getSecond() - duration2.getSecond() );
    dur.setMillisecond( duration1.getMillisecond() - duration2.getMillisecond());
    return dur;
  }

  // result = duration-from-parts( year, month, day \[, hour \[, minute \[, second \[, millisecond\]\]\]\])
  /* The result is the datetime value consisting of the parts given by year, month, day, hour, minute and second.
  */
  public static SchemaDuration durationFromParts(SchemaTypeNumber year, SchemaTypeNumber month, SchemaTypeNumber day, SchemaTypeNumber hour /* optional */, SchemaTypeNumber minute /* optional */, SchemaTypeNumber second /* optional */, SchemaTypeNumber partsecond /* optional */, SchemaBoolean negative /* optional */) {
    SchemaDuration result = new SchemaDuration( year.intValue(), month.intValue(), day.intValue(), hour.intValue(), minute.intValue(), second.intValue(), 0, negative.booleanValue() );
    result.setMillisecond( partsecond.intValue() );
    return result;
  }

  // result = day( value )
  /* Returns the day of the given datetime value.
  */
  public static SchemaTypeNumber dayFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getDay() );
  }

  // result = hours( value )
  /* Returns the hours of the given datetime value.
  */
  public static SchemaTypeNumber hourFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getHour() );
  }

  // result = milliseconds( value )
  /* Returns the milliseconds of the given datetime value.
  */
  public static SchemaTypeNumber millisecondFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getMillisecond() );
  }

  // result = minutes( value )
  /* Returns the minutes of the given datetime value.
  */
  public static SchemaTypeNumber minuteFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getMinute() );
  }

  // result = month( value )
  /* Returns the month of the given datetime value.
  */
  public static SchemaTypeNumber monthFromDuration(SchemaDuration value ) {
    return new SchemaInt(  value.getMonth() );
  }

  // result = seconds( value )
  /* Returns the seconds of the given datetime value.
  */
  public static SchemaTypeNumber secondFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getSecond() );
  }

  // result = year( value )
  /* Returns the year of the given datetime value.
  */
  public static SchemaTypeNumber yearFromDuration(SchemaDuration value ) {
    return new SchemaInt( value.getYear() );
  }


  // ---------- generator functions ----------

  // result = auto-number( start_at, increase )
  /* Generates numbers automatically. On every call of this function it returns the actual-counter-value (starting at 'start_at') 
   * increased by the 'increase' value.
   * 'start_at' (default = 1) and 'increase' (default = 1) are optional.
   */
  public static SchemaTypeNumber autoNumber( int nId, SchemaTypeNumber startAt, SchemaTypeNumber increase ) {
    Integer nInstanceId = new Integer( nId );
    Integer nActNumber = null;
    try {
      nActNumber = (Integer)(_s_InstanceIDs.get( nInstanceId ));
    }
	catch( NullPointerException e ) {
    }
	if( nActNumber == null )
		nActNumber = new Integer( startAt.intValue() );
    _s_InstanceIDs.put( nInstanceId, new Integer( nActNumber.intValue() + increase.intValue() ) );
    return new SchemaInt( nActNumber.intValue() );
  }

  // result = create-guid()
  /* Creates a global-unique-identifier as hexadecimal-encoded string.
   */
  public static SchemaString createGuid() throws Exception {
    String guid  = new java.rmi.server.UID().toString().replaceAll("\[-:\]","");
    byte\[\] addr = java.net.InetAddress.getLocalHost().getAddress();
    guid +=Long.toHexString(addr\[0\]) + Long.toHexString(addr\[1\]) + Long.toHexString(addr\[2\]) + Long.toHexString(addr\[3\]);
    for (int i =guid.length(); i<32; i++)
      guid+="0";
    return new SchemaString(guid);
  }


  // ---------- helpers ----------
  protected static boolean isNumber(SchemaType a) {
    if( a instanceof SchemaString )
      return ((SchemaString)a).isValueNumeric();
    return( a instanceof SchemaTypeNumber );
  }

  protected static boolean isNumber(SchemaType a, SchemaType b) {
    return( isNumber(a) && isNumber(b) );
  }

  protected static SchemaTypeNumber getCommonNumberInstance(int numericType, SchemaTypeNumber a_value) {
    switch( numericType ) {
      case SchemaTypeNumber.NUMERIC_VALUE_INT:
        return new SchemaInt( a_value.intValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_LONG:
        return new SchemaLong( a_value.longValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGINTEGER:
        return new SchemaInteger( a_value.bigIntegerValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_FLOAT:
        return new SchemaFloat( a_value.floatValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_DOUBLE:
        return new SchemaDouble( a_value.doubleValue() );
      case SchemaTypeNumber.NUMERIC_VALUE_BIGDECIMAL:
        return new SchemaDecimal( a_value.bigDecimalValue() );
    }
    return null;
  }

  protected static SchemaType getCommonNumberInstance(SchemaType a_value, SchemaType b) {
    return (SchemaType)getCommonNumberInstance( java.lang.Math.max( ((SchemaTypeNumber)a_value).numericType(), ((SchemaTypeNumber)b).numericType()), (SchemaTypeNumber)a_value );
  }

  protected static boolean isCalendar(SchemaType a) {
    return (a instanceof SchemaCalendarBase);
  }

  protected static boolean is_oneCalendar_oneString(SchemaType a, SchemaType b) {
    return (isCalendar(a) && b instanceof SchemaString) ||
        (isCalendar(b) && a instanceof SchemaString);
  }

  protected static SchemaType getCommonCalendarInstance(SchemaType a_value, SchemaType b) {
    switch (java.lang.Math.max( ( (SchemaTypeCalendar) a_value).calendarType(),( (SchemaTypeCalendar) b).calendarType())) {
      case SchemaTypeCalendar.CALENDAR_VALUE_DURATION:
        return new SchemaDuration( ( (SchemaTypeCalendar) a_value).durationValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_DATETIME:
        return new SchemaDateTime( ( (SchemaTypeCalendar) a_value).dateTimeValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_DATE:
        return new SchemaDate( ( (SchemaTypeCalendar) a_value).dateValue());
      case SchemaTypeCalendar.CALENDAR_VALUE_TIME:
        return new SchemaTime( ( (SchemaTypeCalendar) a_value).timeValue());
    }
    throw new ValuesNotConvertableException(a_value, b);
  }
}