//
// [=$application.WSDLService.Name].asmx.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using System.Collections;
using System.ComponentModel;
using System.Data;
using System.Diagnostics;
using System.Runtime.Remoting.Metadata;
using System.Web;
using System.Web.Services;
using System.Web.Services.Description;
using System.Web.Services.Protocols;
using System.Xml;
using System.Xml.Serialization;

[
foreach $tmplibrary in $application.Libraries
	if $tmplibrary.Kind = 5	' WSDL Library
]using [=$tmplibrary.Name];
[	endif
next
]

namespace [=$application.Name]
{
	/// <summary>
	/// Summary description for [=$WebServiceClassName].
	/// </summary>
	\[WebService(Namespace="[=$application.WSDLService.NamespaceURI]")\]
	public class [=$WebServiceClassName] : System.Web.Services.WebService
	{
		public [=$WebServiceClassName]()
		{
			//CODEGEN: This call is required by the ASP.NET Web Services Designer
			InitializeComponent();
		}

		#region Component Designer generated code
		
		//Required by the Web Services Designer 
		private IContainer components = null;
				
		/// <summary>
		/// Required method for Designer support - do not modify
		/// the contents of this method with the code editor.
		/// </summary>
		private void InitializeComponent()
		{
		}

		/// <summary>
		/// Clean up any resources being used.
		/// </summary>
		protected override void Dispose( bool disposing )
		{
			if(disposing && components != null)
			{
				components.Dispose();
			}
			base.Dispose(disposing);		
		}
		
		#endregion

		// WEB SERVICE EXAMPLE
		// The HelloWorld() example service returns the string Hello World
		// To build, uncomment the following lines then save and build the project
		// To test this web service, press F5

		// \[WebMethod\]
		// public string HelloWorld()
		// {
		//	return "Hello World";
		// }

[
' generate method for each mapping

$RpcHelpersGenerated = false
foreach $Mapping in $application.Mappings

	if $Mapping.WSDLBindingOperation.SOAPStyle = 1 and $Mapping.WSDLBindingOperation.Input.Use = 12 and not $RpcHelpersGenerated ' RPC/encoded
]		XmlElement FindReferencedElement(string href, XmlElement\[\] input)
		{
			if (href.StartsWith("#"))
			{
				href = href.Substring(1);
				foreach (XmlElement node in input)
					if (node.GetAttribute("id") == href) 
						return node;
			}
			else throw new System.ApplicationException("external URI references are not supported");
			throw new System.ApplicationException("referenced element '" + href + "' not found");
		}


		void ResolveRpcReferences(XmlElement parent, XmlElement\[\] input, Hashtable stack)
		{
			foreach (XmlNode child in parent.ChildNodes)
			{
				if (child.NodeType == XmlNodeType.Element)
				{
					string href = ((XmlElement) child).GetAttribute("href");
					if (href.Length > 0)
					{
						XmlElement referencedElement = FindReferencedElement(href, input);
						foreach (XmlNode childNode in referencedElement.ChildNodes)
							child.AppendChild(parent.OwnerDocument.ImportNode(childNode, true));
						if (!stack.Contains(href)) 
						{
							Hashtable newStack = new Hashtable(stack);
							newStack.Add(href, null);
							ResolveRpcReferences((XmlElement) child, input, newStack);
						}
						else throw new System.ApplicationException("reference '" + href + "' causes infinite recursion");
					}
					else
						ResolveRpcReferences((XmlElement) child, input, stack);
				}
			}
		}

[		$RpcHelpersGenerated = true
	endif

]		\[WebMethod(MessageName="[=$Mapping.WSDLBindingOperation.Name]")\]
		\[SoapDocumentMethod(Action="[=$Mapping.WSDLBindingOperation.SOAPAction]", Use=SoapBindingUse.Literal, ParameterStyle=SoapParameterStyle.Bare)\]
		\[return: XmlAnyElement\]
		public XmlElement\[\] [=$Mapping.WSDLBindingOperation.Name](\[XmlAnyElement\] XmlElement\[\] input)
		{
[
	' prepare XML documents
	$TargetName = ""
	$InputGenerated = false		' generate input document only for first algorithm group
	foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
		if not $InputGenerated
			foreach $SourceInstance in $AlgorithmGroup.SourceLibraryList
				if $SourceInstance.Kind = 5 ' WSDL Library
					$lDocName	= $SourceInstance.UniqueName & "Doc"
					$lQDocType	= $SourceInstance.Library.UniqueName & "." & $SourceInstance.Library.UniqueName & "Doc"
					$lRootName	= $SourceInstance.Message.UniqueName
					$lQRootType	= $SourceInstance.Library.UniqueName & "." & $SourceInstance.Message.Name
]			// Prepare input document
			[=$lQDocType] [=$lDocName]SourceObject = new [=$lQDocType]();
[					if $Mapping.WSDLBindingOperation.SOAPStyle = 1 ' RPC
]			[=$lQRootType] [=$lRootName]SourceObject = new [=$lQRootType](
					[=$lDocName]SourceObject.GetDomDocument().ImportNode(input\[0\], true));
[						if $Mapping.WSDLBindingOperation.Input.Use = 12 ' SOAP encoded
]			ResolveRpcReferences((XmlElement) [=$lRootName]SourceObject.getDOMNode(), input, new Hashtable());
[						endif
					else ' document
]			[=$lQRootType] [=$lRootName]SourceObject = new [=$lQRootType]([=$lDocName]SourceObject,
					"[=$SourceInstance.Message.Namespace]", "", "[=$SourceInstance.Message.Name]");
			foreach (XmlNode part in input)
				[=$lRootName]SourceObject.getDOMNode().AppendChild(
					[=$lDocName]SourceObject.GetDomDocument().ImportNode(part, true));
[					endif
                	$InputGenerated = true
				endif
			next
		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 5	' WSDL Library
			$lDocName	= $AlgorithmGroup.TargetLibrary.UniqueName & "Doc"
			$lQDocType	= $AlgorithmGroup.TargetLibrary.Library.UniqueName & "." & $AlgorithmGroup.TargetLibrary.Library.UniqueName & "Doc"
			$lRootName	= $AlgorithmGroup.TargetLibrary.Message.UniqueName
			$lQRootType	= $AlgorithmGroup.TargetLibrary.Library.UniqueName & "." & $AlgorithmGroup.TargetLibrary.Message.Name
]
			// Prepare output document
			[=$lQDocType] [=$lDocName]TargetObject = new [=$lQDocType]();
			[=$lQRootType] [=$lRootName]TargetObject = new [=$lQRootType]([=$lDocName]TargetObject,
					"[=$AlgorithmGroup.TargetRootNamespace]", "[=$AlgorithmGroup.TargetRootPrefix]", "[=$AlgorithmGroup.TargetLibrary.Message.OriginalName]");
[			$TargetName = $lRootName & "TargetObject";
		endif
	next

	foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
		$AlgorithmGroupClass = $application.Name & $AlgorithmGroup.Name
		$Args = ""
]
			// run [=$AlgorithmGroup.Name]
			[=$AlgorithmGroupClass] [=$AlgorithmGroupClass]Object = new [=$AlgorithmGroupClass]();
			try
			{
				[=$AlgorithmGroupClass]Object.Run(
				[
		foreach $SourceInstance in $AlgorithmGroup.SourceLibraryList
			if $SourceInstance.Kind = 1 ' XML Library
				]"[=$SourceInstance.InputInstanceName]"[
			endif
			if $SourceInstance.Kind = 2 ' Database Library
				]"[=$SourceInstance.ADOConnectionString]"[
			endif
			if $SourceInstance.Kind = 3 ' Text Library
				]"[=$SourceInstance.InputFileName]"[
			endif
			if $SourceInstance.Kind = 4 ' Parameter Library
				' TODO: how can webservices get parameters?
			endif
			if $SourceInstance.Kind = 5 ' WSDL Library
				=$SourceInstance.Message.UniqueName]SourceObject[
			endif
			],
					[
		next ' SourceInstance
		if $AlgorithmGroup.TargetLibrary.Kind = 1	' XML Library
			]"[=$AlgorithmGroup.TargetLibrary.OutputInstanceName]");
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 2	' Database Library
			]"[=$AlgorithmGroup.TargetLibrary.ADOConnectionString]");
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 3	' Text Library
			]"[=$AlgorithmGroup.TargetLibrary.OutputFileName]");
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 5	' WSDL Library
			=$AlgorithmGroup.TargetLibrary.UniqueName]TargetObject);
[		endif]
			}
			catch (Altova.Xml.FaultException fe)
			{
				XmlNode detail = fe.getNode().getDOMNode();
				// fix detail!!!
				string message = "MapForce user exception: " + fe.getThrower();
				XmlQualifiedName code = new XmlQualifiedName("Server", "http://schemas.xmlsoap.org/soap/envelope/");
				string actor = "[=$application.WSDLPort.Address]";
				System.Web.Services.Protocols.SoapException fault = new System.Web.Services.Protocols.SoapException(message, code, actor, detail, null);
				throw fault;
			}
[	next ' AlgorithmGroup
]
			// set namespace prefixes
			[=$TargetName].AdjustPrefix();
[
	if $Mapping.WSDLBindingOperation.Output.Use = 12 ' SOAP encoded
]
			// generate xsi:type attributes
			[=$TargetName].GenerateXsiTypeAttributes();
[	endif

	if $Mapping.WSDLBindingOperation.SOAPStyle = 1 ' RPC
]
			XmlElement\[\] result = new XmlElement\[1\];
			result\[0\] = (XmlElement) [=$TargetName].getDOMNode();
[	else ' Document
]
            // Build return array
			ArrayList elements = new ArrayList();
			int nNodes = [=$TargetName].getDOMNode().ChildNodes.Count;
			for (int i = 0; i < nNodes; ++i)
			{
				XmlNode node = [=$TargetName].getDOMNode().ChildNodes\[i\];
				if (node.NodeType == XmlNodeType.Element)
					elements.Add((XmlElement) node);
			}

			XmlElement\[\] result = new XmlElement\[elements.Count\];
			elements.CopyTo(result);
[	endif ' RPC/Doc
]			return result;
		}

[next ' Mapping
]	}
}
