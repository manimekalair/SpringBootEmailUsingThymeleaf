////////////////////////////////////////////////////////////////////////
//
// Node.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "../Altova/Altova.h"
#include "../Altova/AltovaException.h"
#include "../Altova/SchemaTypes.h"
#include "../Altova/SchemaTypeString.h"
#include "XmlException.h"
#include "Node.h"
#include "Doc.h"


namespace altova {


//#define ADJUST_LOCAL_NAMES


#ifdef ADJUST_LOCAL_NAMES

#define Q2L(x) Q2LHelper(x).GetData()

class Q2LHelper
{
public:
	Q2LHelper(const XMLCh* szQName)
	{
		int nPos = xercesc::XMLString::indexOf(szQName, L':');
		if (nPos != -1)
			m_szLocalName = xercesc::XMLString::replicate(szQName + nPos + 1);
		else
			m_szLocalName = xercesc::XMLString::replicate(szQName);
	}

	~Q2LHelper()
	{
		xercesc::XMLString::release(&m_szLocalName);
	}

	const XMLCh* GetData() const
	{
		return m_szLocalName;
	}

protected:
	XMLCh* m_szLocalName;
};

#else

#define Q2L(x) x

#endif


CNode::CNode()
{
	m_pDOMNode = CDoc::CreateFragment();
}


CNode::CNode(xercesc::DOMNode* pThisNode)
{
	m_pDOMNode = pThisNode;
}


CNode::CNode(xercesc::DOMDocument* pDOMDocument)
{
	m_pDOMNode = pDOMDocument->getDocumentElement();
}


CNode::~CNode()
{
	CDoc::ReleaseFragment(m_pDOMNode);
}


CNode&	CNode::Assign(const CNode& rOther)
{
	tstring innerText = ((CNode&)rOther).InternalGetElementValue();
	InternalSetElementValue( innerText );
	return *this;
}


tstring CNode::GetNodeName()
{
	return XC2TS(m_pDOMNode->getNodeName());
}


tstring CNode::GetNodeValue()
{
	if (m_pDOMNode->getNodeValue())
		return XC2TS(m_pDOMNode->getNodeValue());
	else
		return _T("");
}


xercesc::DOMNode* CNode::GetDOMNode()
{
	return m_pDOMNode;
}


void CNode::MapPrefix(const tstring& sPrefix, const tstring& sURI)
{
	if (sURI.empty())
		return;

	xercesc::DOMElement* pElement = reinterpret_cast<xercesc::DOMElement*>(m_pDOMNode);

	InternalDeclareNamespace(pElement, sPrefix, sURI);
}



tstring CNode::GetNodeTextValue(xercesc::DOMNode* pNode)
{
	if (pNode == NULL)
		return _T("");
	if (pNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
//		return XC2TS(pNode->getTextContent());  // this is buggy in Xerces < 2.4 - see http://issues.apache.org/bugzilla/show_bug.cgi?id=24693
		tstring value;
		for (xercesc::DOMNode* pChildNode = pNode->getFirstChild(); pChildNode != NULL; pChildNode = pChildNode->getNextSibling())
				value += GetNodeTextValue(pChildNode);
		return value;
	}
	else
		return XC2TS(pNode->getNodeValue());
}


tstring CNode::InternalGetElementValue()
{
	return GetNodeTextValue(m_pDOMNode);
}


void CNode::InternalSetElementValue(const tstring& sValue)
{
	m_pDOMNode->appendChild(m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue)));
}


bool CNode::InternalNamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName)
{
	tstring sNodeURI;
	tstring sNodeName;
	if (pNode->getNamespaceURI())
		sNodeURI = XC2TS(pNode->getNamespaceURI());
	if (pNode->getLocalName())
		sNodeName = XC2TS(pNode->getLocalName());
	return sNamespaceURI == sNodeURI && sName == sNodeName;
}

bool CNode::NamesMatch(xercesc::DOMNode* pNode, const tstring& sNamespaceURI, const tstring& sName)
{
	return InternalNamesMatch(pNode, sNamespaceURI, sName);
}

int CNode::ChildCountInternal(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				nCount++;

		return nCount;
	}
	else
		return (static_cast<xercesc::DOMElement*>(m_pDOMNode))->hasAttributeNS(X(sNamespaceURI), Q2L(X(sName))) ? 1 : 0;
}


bool CNode::InternalHasChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				return true;
		
		return false;
	}
	else
		return (static_cast<xercesc::DOMElement*>(m_pDOMNode))->hasAttributeNS(X(sNamespaceURI), Q2L(X(sName)));
}


xercesc::DOMNode* CNode::InternalCreate(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	switch ( eNodeType )
	{
		case Element:
			{
			xercesc::DOMElement* pElement = m_pDOMNode->getOwnerDocument()->createElementNS(X(sNamespaceURI), X(sName));
			pElement->appendChild(m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue)));
			return pElement;
			}
		case Text:
			{
			xercesc::DOMText* pText = m_pDOMNode->getOwnerDocument()->createTextNode(X(sValue));
			return pText;
			}
		case CData:
			{
			xercesc::DOMCDATASection* pText = m_pDOMNode->getOwnerDocument()->createCDATASection(X(sValue));
			return pText;
			}
		case ProcessingInstruction:
			{
			xercesc::DOMProcessingInstruction* pText = m_pDOMNode->getOwnerDocument()->createProcessingInstruction(X(sName), X(sValue));
			return pText;
			}
		case Comment:
			{
			xercesc::DOMComment* pText = m_pDOMNode->getOwnerDocument()->createComment(X(sValue));
			return pText;
			}
		default: //attribute
			{
			xercesc::DOMAttr* pAttribute = m_pDOMNode->getOwnerDocument()->createAttributeNS(X(sNamespaceURI), X(sName));
			pAttribute->setNodeValue(X(sValue));
			return pAttribute;
			}
	}
}


xercesc::DOMNode* CNode::InternalAppend(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, const tstring& sValue)
{
	switch ( eNodeType )
	{
		case Element:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, sNamespaceURI, sName, sValue));
		case Text:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		case CData:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		case ProcessingInstruction:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), sName, sValue));
		case Comment:
			return m_pDOMNode->appendChild(InternalCreate(eNodeType, _T(""), _T(""), sValue));
		default:
			return m_pDOMNode->getAttributes()->setNamedItemNS(InternalCreate(eNodeType, sNamespaceURI, sName, sValue));
	}
}


xercesc::DOMNode* CNode::InternalAppendNode(const tstring& sNamespaceURI, const tstring& sName, CNode& rNode)
{
	xercesc::DOMNode* pOldNode = rNode.m_pDOMNode;
	rNode.m_pDOMNode = m_pDOMNode->appendChild(InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName));
	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalGetAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	if (eNodeType == Element)
	{
		int nCount = 0;

		for (xercesc::DOMNode* pNode = m_pDOMNode->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
			if (InternalNamesMatch(pNode, sNamespaceURI, sName))
				if (nCount++ == nIndex)
					return pNode;

		throw CXmlException(1, _T("Index out of range"));
	}
	else
	{
		xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(m_pDOMNode->getAttributes()->getNamedItemNS(X(sNamespaceURI), Q2L(X(sName))));
		if (pAttr != NULL)
			return pAttr;
		else
			throw CXmlException(1, _T("Index out of range"));
	}
}

xercesc::DOMNode* CNode::InternalGetFirstChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	if (eNodeType == Element)
	{
		for (xercesc::DOMNode* spChild = m_pDOMNode->getFirstChild(); spChild != NULL; spChild = spChild->getNextSibling())
			if (InternalNamesMatch(spChild, sNamespaceURI, sName))
					return spChild;
	}
	else // eNodeType == Attribute
	{
		xercesc::DOMAttr* pAttr = static_cast<xercesc::DOMAttr*>(m_pDOMNode->getAttributes()->getNamedItemNS(X(sNamespaceURI), Q2L(X(sName))));
		if (pAttr != NULL)
			return pAttr;
	}
	return NULL;
}

xercesc::DOMNode* CNode::InternalGetNextChild(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, xercesc::DOMNode* pCurNode )
{
	if (eNodeType == Element && pCurNode != NULL)
	{
		for (xercesc::DOMNode* spChild = pCurNode->getNextSibling(); spChild != NULL; spChild = spChild->getNextSibling())
			if (InternalNamesMatch(spChild, sNamespaceURI, sName))
					return spChild;
	}
	
	return NULL;
}


xercesc::DOMNode* CNode::InternalGet(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName)
{
	return InternalGetAt(eNodeType, sNamespaceURI, sName, 0);
}


xercesc::DOMNode* CNode::InternalInsertAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return m_pDOMNode->insertBefore(
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue),
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


xercesc::DOMNode* CNode::InternalInsertNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	rNode.m_pDOMNode = m_pDOMNode->insertBefore(
			InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName),
			InternalGetAt(Element, sNamespaceURI, sName, nIndex)
			);

	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalReplaceAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex, const tstring& sValue)
{
	if (eNodeType == Element)
		return m_pDOMNode->replaceChild(
				InternalCreate(eNodeType, sNamespaceURI, sName, sValue),
				InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex)
				);
	else
		return InternalAppend(eNodeType, sNamespaceURI, sName, sValue);
}


xercesc::DOMNode* CNode::InternalReplaceNodeAt(const tstring& sNamespaceURI, const tstring& sName, int nIndex, CNode& rNode)
{
	xercesc::DOMNode* pOldNode = rNode.m_pDOMNode;
	rNode.m_pDOMNode = m_pDOMNode->replaceChild(
			InternalAdopt(rNode.m_pDOMNode, sNamespaceURI, sName),
			InternalGetAt(Element, sNamespaceURI, sName, nIndex)
			);
	CDoc::ReleaseFragment(pOldNode);

	return rNode.m_pDOMNode;
}


xercesc::DOMNode* CNode::InternalRemoveAt(ENodeType eNodeType, const tstring& sNamespaceURI, const tstring& sName, int nIndex)
{
	if (eNodeType == Element)
		return m_pDOMNode->removeChild(InternalGetAt(eNodeType, sNamespaceURI, sName, nIndex));
	else
		return m_pDOMNode->getAttributes()->removeNamedItemNS(X(sNamespaceURI), Q2L(X(sName)));
}


xercesc::DOMElement* CNode::InternalAdopt(xercesc::DOMNode* pElement, const tstring& sNamespaceURI, const tstring& sName)
{
	xercesc::DOMDocument* pDoc = m_pDOMNode->getOwnerDocument();
	xercesc::DOMElement* pNewElement = pDoc->createElementNS(X(sNamespaceURI), X(sName));

	for (xercesc::DOMNode* pNode = pElement->getFirstChild(); pNode != NULL; pNode = pNode->getNextSibling())
	{
		pNewElement->appendChild(pDoc->importNode(pNode, true));
	}

	xercesc::DOMNamedNodeMap* pSrcAttributes = pElement->getAttributes();
	xercesc::DOMNamedNodeMap* pDstAttributes = pNewElement->getAttributes();
	for (XMLSize_t i = 0; i < pSrcAttributes->getLength(); i++)
	{
		xercesc::DOMNode* pNode = pSrcAttributes->item(i);
		pDstAttributes->setNamedItemNS(pDoc->importNode(pNode, true));
	}

	return pNewElement;

}


void CNode::DeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI)
{
	if (sURI.empty())
		return;

	xercesc::DOMNamedNodeMap* pAttrs = pElement->getAttributes();
	for (XMLSize_t i = 0; i < pAttrs->getLength(); i++)
	{
		xercesc::DOMAttr* pAttr = reinterpret_cast<xercesc::DOMAttr*>(pAttrs->item(i));
		if (xercesc::XMLString::startsWith(pAttr->getNodeName(), L"xmlns") && xercesc::XMLString::equals(pAttr->getValue(), X(sURI)))
			return;
	}

	InternalDeclareNamespace(pElement, sPrefix, sURI);
}

 
void CNode::InternalDeclareNamespace(xercesc::DOMElement* pElement, const tstring& sPrefix, const tstring& sURI)
{
	tstring sTmp;

	if (sPrefix.empty())
		sTmp = _T("xmlns");
	else
		sTmp = _T("xmlns:") + sPrefix;

	pElement->setAttributeNS(X("http://www.w3.org/2000/xmlns/"), X(sTmp), X(sURI));
}


const XMLCh* CNode::LookupPrefix(xercesc::DOMNode* pNode, const XMLCh* szURI)
{
	if (pNode == NULL)
		return NULL;

	if (szURI == NULL || *szURI == 0)
		return NULL;

	if (pNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMNamedNodeMap* pAttrs = pNode->getAttributes();
		if (pAttrs != NULL)
		{
			XMLSize_t len = pAttrs->getLength();
			for (XMLSize_t i = 0; i < len; i++)
			{
				xercesc::DOMAttr* pAttr = reinterpret_cast<xercesc::DOMAttr*>(pAttrs->item(i));
				const XMLCh* szName = pAttr->getName();
				const XMLCh* szValue = pAttr->getValue();
				if (xercesc::XMLString::equals(szValue, szURI))
				{
					if (xercesc::XMLString::stringLen(szName) < 6 || !xercesc::XMLString::startsWith(szName, L"xmlns"))
						continue;
					else
						return szName + 6;
				}
			}
		}
		return LookupPrefix(pNode->getParentNode(), szURI);
	}
	else if (pNode->getNodeType() == xercesc::DOMNode::ATTRIBUTE_NODE)
	{
		return LookupPrefix(reinterpret_cast<xercesc::DOMAttr*>(pNode)->getOwnerElement(), szURI);
	}
	else
	{
		return NULL;
	}
}


xercesc::DOMNode* CNode::LookupDefaultNamespace(xercesc::DOMNode* pDOMNode)
{
	if (pDOMNode == NULL)
		return NULL;

	if (pDOMNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMElement* pElement = reinterpret_cast<xercesc::DOMElement*>(pDOMNode);
		xercesc::DOMAttr* pAttr = pElement->getAttributeNodeNS(X("http://www.w3.org/2000/xmlns/"), X("xmlns"));
		if (pAttr != NULL)
			return pAttr;
	}

	return LookupDefaultNamespace(pDOMNode->getParentNode());
}


void CNode::InternalAdjustPrefix(xercesc::DOMNode* pDOMNode, bool bQualified)
{
	if (pDOMNode == NULL)
		return;
	if (bQualified)
	{
		const XMLCh* szPrefix = LookupPrefix(pDOMNode, pDOMNode->getNamespaceURI());
		if (szPrefix)
			pDOMNode->setPrefix(szPrefix);
	}
	else if (pDOMNode->getNodeType() == xercesc::DOMNode::ELEMENT_NODE)
	{
		xercesc::DOMElement* pElement = reinterpret_cast<xercesc::DOMElement*>(pDOMNode);
		if (LookupDefaultNamespace(pElement) != NULL)
			InternalDeclareNamespace(pElement, _T(""), _T(""));
	}
}



CAnyTypeNode::CAnyTypeNode(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

CAnyTypeNode& CAnyTypeNode::operator=(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
	return *this;
}

void CAnyTypeNode::Assign(const CSchemaString& Value)
{
	InternalSetElementValue(Value);
}

CAnyTypeNode::operator CSchemaString()
{
	return InternalGetElementValue();
}

CNode::EGroupType CAnyTypeNode::GetGroupType()
{
	return eSequence;
}

void CAnyTypeNode::AdjustPrefix()
{
}

void CAnyTypeNode::AddTextNode(CSchemaString text)
{
	InternalAppend(Text, _T(""), _T("#text"), text);
}

void CAnyTypeNode::AddCDataNode(CSchemaString text)
{
	InternalAppend(CData, _T(""), _T("#cdata"), text);
}

void CAnyTypeNode::AddComment(CSchemaString text)
{
	InternalAppend(Comment, _T(""), _T("#cdata"), text);
}

void CAnyTypeNode::AddProcessingInstruction(CSchemaString name, CSchemaString text)
{
	InternalAppend(ProcessingInstruction, _T(""), name, text);
}



} // namespace altova
