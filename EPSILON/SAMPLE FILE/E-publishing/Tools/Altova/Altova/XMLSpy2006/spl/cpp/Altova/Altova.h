////////////////////////////////////////////////////////////////////////
//
// Altova.h
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#ifndef ALTOVA_H_INCLUDED
#define ALTOVA_H_INCLUDED

#if _MSC_VER > 1000
	#pragma once
#endif // _MSC_VER > 1000

namespace altova {


////////////////////////////////////////////////////////////////////////
//
//  Utility functions
//
////////////////////////////////////////////////////////////////////////


#define ThrowFormatError() \\
	throw CAltovaException(CAltovaException::eError1, _T("Format error"));

#define ThrowOutOfRangeError() \\
	throw CAltovaException(CAltovaException::eError1, _T("Out of range!"));

#define ThrowIncompatibleTypesError() \\
	throw CAltovaException(CAltovaException::eError1, _T("Types incompatible!"));

#define ThrowValuesNotConvertableError() \\
	throw CAltovaException(CAltovaException::eError1, _T("Values are not convertable"));



#ifndef _USRDLL
	#define ALTOVA_DECLSPECIFIER
#else
	#ifdef ALTOVA_EXPORTS
		#define ALTOVA_DECLSPECIFIER __declspec(dllexport)
		#define ALTOVA_EXPIMP_TEMPLATE
	#else
		#define ALTOVA_DECLSPECIFIER __declspec(dllimport)
		#define ALTOVA_EXPIMP_TEMPLATE extern
	#endif

	#ifndef _MFC_VER
		#pragma warning(disable: 4660)
		#pragma warning(disable: 4231)
		#pragma warning(disable: 4251)
	#endif
#endif



	
#if defined(UNICODE) || defined(_UNICODE)
	#define tstring			std::wstring
	#define tstringstream	std::wstringstream
	#define tcin			std::wcin
	#define tcout			std::wcout
	#define tcerr			std::wcerr
	#define tclog			std::wclog
	#define tostream		std::wostream
	#define tofstream		std::wofstream
	#define tostringstream	std::wostringstream
#else
	#define tstring			std::string
	#define tstringstream	std::stringstream	
	#define tcin			std::cin
	#define tcout			std::cout
	#define tcerr			std::cerr
	#define tclog			std::clog
	#define tostream		std::ostream
	#define tofstream		std::ofstream
	#define tostringstream	std::ostringstream
#endif
	

#if defined( __GNUC__ )
	#define ALTOVA_INT64 long long
#else
	#define ALTOVA_INT64 __int64
#endif


#ifdef _XERCES_VERSION

	#if defined(UNICODE) || defined(_UNICODE)
		#define XC2TS(x) x
	#else
		#define XC2TS(x) StrX(x).localForm()
	#endif

	class XStr
	{
	public:
		XStr(const char* const toTranscode) { m_bClone = true; fUnicodeForm = xercesc::XMLString::transcode(toTranscode); }
		XStr(const std::string& toTranscode) { m_bClone = true; fUnicodeForm = xercesc::XMLString::transcode(toTranscode.c_str()); }
		XStr(const wchar_t* const toTranscode) { m_bClone = false; fUnicodeForm = (XMLCh*)toTranscode; }
		XStr(const std::wstring& toTranscode) { m_bClone = false; fUnicodeForm = (XMLCh*)(toTranscode.c_str()); }
		~XStr() { if (m_bClone && fUnicodeForm) xercesc::XMLString::release(&fUnicodeForm); }
		const XMLCh* unicodeForm() const { return fUnicodeForm; }
	protected:
		bool m_bClone;
		XMLCh* fUnicodeForm;
	};

	#define X(str) XStr(str).unicodeForm()

	class StrX
	{
	public:
		StrX(const XMLCh* const toTranscode) { fLocalForm = xercesc::XMLString::transcode(toTranscode); }
		~StrX() { xercesc::XMLString::release(&fLocalForm); }
		const char* localForm() const { return fLocalForm; }
	protected:
		char* fLocalForm;
	};

#endif
#ifdef _MFC_VER
	inline tostream& operator<<(tostream& out, const CString& sText)
	{
		return tcout << (LPCTSTR)sText;
	}
#endif // _MFC_VER


////////////////////////////////////////////////////////////////////////
//
//  Utility functions and templates
//
////////////////////////////////////////////////////////////////////////

template<typename TValue>
TValue InRangeInt(TValue nValue, ALTOVA_INT64 nMin, ALTOVA_INT64 nMax)
{
	if( nValue < nMin || nValue > nMax )
		throw CAltovaException(CAltovaException::eError1, _T("Out of range!"));
	return nValue;
}


template<typename TValue>
TValue InRangeDbl(TValue nValue, const double nPosMin, const double nPosMax)
{
	TValue nTmpValue = nValue;
	if( nTmpValue == 0 )
		return nValue;
	if( nTmpValue < 0 )
		nTmpValue = -nTmpValue;
	if( nTmpValue >= nPosMin  &&  nTmpValue <= nPosMax )
		return nValue;
	throw CAltovaException(CAltovaException::eError1, _T("Out of range!"));
}

////////////////////////////////////////////////////////////////////////
//
//  CBaseObject
//
////////////////////////////////////////////////////////////////////////


class ALTOVA_DECLSPECIFIER CBaseObject
{
public:
	virtual ~CBaseObject() {}
};

} // namespace altova

#endif