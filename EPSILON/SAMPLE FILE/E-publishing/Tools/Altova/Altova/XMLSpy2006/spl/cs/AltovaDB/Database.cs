//
// Database.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using System.Data;

namespace Altova.Db
{

	public abstract class Database 
	{
		protected string 			connectionString;
		protected IDbConnection		connectionForModify;	// necessary for transactions (must be executed all on the same connection)
		protected bool				rollbackTransaction = false;
		protected int				transactionCount = 0;
		protected IDbTransaction	transaction = null;

		#region Construction and Destruction
		public Database(string connectionString) 
		{
			this.connectionString = connectionString;

			try
			{
				connectionForModify = CreateConnection();
			}
			catch( Exception e )
			{
				throw new DBConnectionException( DBConnectionException.EErrorKind.Open, connectionString, e.Message );
			}
		}
		#endregion Construction and Destruction

		#region Accessors
		public string ConnectionString
		{
			get
			{
				return connectionString;
			}
		}

		public IDbConnection ConnectionForModify
		{
			get
			{
				return connectionForModify;
			}
		}

		public IDbTransaction Transaction
		{
			get
			{
				return transaction;
			}
		}

		public bool RollbackTransactionOnClose
		{
			get
			{
				return rollbackTransaction;
			}
			set
			{
				rollbackTransaction = value;
			}
		}
		#endregion Accessors


		public abstract IDbConnection CreateConnection();
		// Note: Better to close the connection after IDbConnection-object is no longer used

		public IDataReader ExecuteQuery(string query)
		{	// use new connection
			IDbConnection conn = CreateConnection();
			conn.Open();
			IDbCommand cmd = conn.CreateCommand();
			cmd.CommandText = query;
			cmd.Transaction = transaction;
			return cmd.ExecuteReader();
		}

		public void ExecuteCommand(string statement)
		{
			IDbCommand cmd = connectionForModify.CreateCommand();
			cmd.CommandText = statement;
			cmd.Transaction = transaction;
			cmd.ExecuteNonQuery();
		}

		#region Transactions
		public void	BeginTransaction( string sName )
		{
			if( transactionCount == 0 )
				InternalBeginTransaction();
			else
				InternalSetSavepoint( sName );

			transactionCount++;
		}

		public void	CommitTransaction( string sName )
		{
			if( transactionCount< 1 )
				throw new DBExecuteException( DBExecuteException.EErrorKind.Execute, sName, " ERROR: No open transaction to commit!" );
			else if( transactionCount== 1 )
				InternalCommitTransaction();
			//else
			//	ignore commit of nested transaction - they are done when main-transaction is commited.

			transactionCount--;
		}

		public void	RollbackTransaction( string sName )
		{
			if( transactionCount< 1 )
				throw new DBExecuteException( DBExecuteException.EErrorKind.Execute, sName, " ERROR: No open transaction to rollback!" );
			else if( transactionCount== 1 )
				InternalRollbackTransaction();
			else
				InternalRollbackToSavepoint( sName );

			transactionCount--;
		}

		protected abstract void	InternalBeginTransaction();
		protected abstract void	InternalCommitTransaction();
		protected abstract void	InternalRollbackTransaction();
		protected abstract void	InternalSetSavepoint( string sTransactionName );
		protected abstract void	InternalRollbackToSavepoint( string sTransactionName );
		#endregion Transactions
	}
}