//
// [=$application.Name]Console.cs
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//

using System;
using System.Collections;
using System.Data;
using Altova.Types;
using Altova.Functions;

namespace [=$application.Name]
{
	public class [=$application.Name]Console 
	{

		public static void Main(string\[\] args) 
		{
			Console.Out.WriteLine("[=$application.Name] Application");
			
			try 
			{
				TraceTargetConsole ttc = new TraceTargetConsole();
[if $InputParameterCount > 0
]				System.Collections.Hashtable	mapArguments = new System.Collections.Hashtable();
				if( args.Length <= 1 )
				{
					Console.Out.WriteLine();
					Console.Out.WriteLine( \"WARNING: No parameters given!\" );
					Console.Out.WriteLine( \"SYNTAX: [=$application.Name].exe [
	foreach $Mapping in $application.Mappings
		foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
			foreach $SourceLibrary in $AlgorithmGroup.SourceLibraryList
				if $SourceLibrary.Kind = 4	' Parameter Library
					if $SourceLibrary.IsOptional ]\[[endif
					]/[=$SourceLibrary.Name] ...[
					if $SourceLibrary.IsOptional ]\][endif
					] [
				endif
			next
		next
	next
					]\");
					Console.Out.WriteLine( \"Note: If you want to use spaces as values write them inbetween double quotes.\");
					Console.Out.WriteLine();
				}
				else
				{
					for( int i = 0; i < args.Length; i++ )
					{
						String sName = args\[ i \];
						if( sName.Substring( 0, 1 ) == \"/\"  &&  ( i + 1 ) < args.Length )
							mapArguments\[ sName.Substring( 1, sName.Length - 1 ) \] = args\[ ++i \];
					}
				}
[endif

foreach $Mapping in $application.Mappings
	foreach $AlgorithmGroup in $Mapping.AlgorithmGroups
		$AlgorithmGroupClass = $application.Name & $AlgorithmGroup.Name
		$Args = ""
]				[=$AlgorithmGroupClass] [=$AlgorithmGroupClass]Object = new [=$AlgorithmGroupClass]();
				[=$AlgorithmGroupClass]Object.RegisterTraceTarget(ttc);
				[=$AlgorithmGroupClass]Object.Run(
					[
		foreach $SourceLibrary in $AlgorithmGroup.SourceLibraryList
			if $SourceLibrary.Kind = 1 ' XML Library
				]"[=$SourceLibrary.InputInstanceName]"[
			endif
			if $SourceLibrary.Kind = 2 ' Database Library
				]"[=$SourceLibrary.ADOConnectionString]"[
			endif
			if $SourceLibrary.Kind = 3 ' Text Library
				]"[=$SourceLibrary.InputFileName]"[
			endif
			if $SourceLibrary.Kind = 4 ' Parameter Library
				]mapArguments.ContainsKey( \"[=$SourceLibrary.Name]\" ) ? new Altova.Types.[=$SourceLibrary.DataType]( ( String )mapArguments\[ \"[=$SourceLibrary.Name]\" \] ) : new Altova.Types.[=$SourceLibrary.DataType]()[
			endif
			],
					[
		next
		if $AlgorithmGroup.TargetLibrary.Kind = 1	' XML Library
			]"[=$AlgorithmGroup.TargetLibrary.OutputInstanceName]");
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 2	' Database Library
			]"[=$AlgorithmGroup.TargetLibrary.ADOConnectionString]");
[		endif
		if $AlgorithmGroup.TargetLibrary.Kind = 3	' Text Library
			]"[=$AlgorithmGroup.TargetLibrary.OutputFileName]");[
		endif
	next
next]

				Console.Out.WriteLine("Finished");
			} 
			catch (Altova.UserException ue)
			{
				Console.Out.Write("USER EXCEPTION: ");
				Console.Out.WriteLine( ue.Message );
				System.Environment.Exit(1);
			}
			catch (Exception e) 
			{
				Console.Out.Write("ERROR: ");
				Console.Out.WriteLine( e.Message );
				Console.Out.WriteLine( e.StackTrace );
				System.Environment.Exit(1);
			}
		}
	}


	class TraceTargetConsole : Altova.TraceTarget {
		public void WriteTrace(string info) {
			Console.Out.WriteLine(info);
		}
	}
}
