////////////////////////////////////////////////////////////////////////
//
// AltovaDB.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include <Altova.h>
#include <SchemaTypes.h>
#include <AltovaException.h>
#include "AltovaDB.h"

#pragma warning(disable: 4146)
// If you get a compiler-error on the line below, add the path to the DLL
// at Tools|Options|Directories|Include Directories.
// Hint: Depending on your installation it might be C:\\Program Files\\Common Files\\System\\ADO
#import "msado15.dll" rename("EOF", "EndOfFile") implementation_only
#pragma warning(default: 4146)

namespace altova {


ADODB::DataTypeEnum VariantType2ADOType(const _variant_t& vValue)
{
	switch (vValue.vt)
	{
	case VT_DECIMAL:		return ADODB::adDecimal;
	case VT_I1:				return ADODB::adTinyInt;
	case VT_I2:				return ADODB::adSmallInt;
	case VT_I4:				return ADODB::adInteger;
	case VT_I8:				return ADODB::adBigInt;
	case VT_UI1:			return ADODB::adUnsignedTinyInt;
	case VT_UI2:			return ADODB::adUnsignedSmallInt;
	case VT_UI4:			return ADODB::adUnsignedInt;
	case VT_UI8:			return ADODB::adUnsignedBigInt;
	case VT_R4:				return ADODB::adSingle;
	case VT_R8:				return ADODB::adDouble;
	case VT_DATE:			return ADODB::adDate;	// Note: ADODB::adDate - not supported by ODBC-driver for SQLServer - use adDBTimeStamp instead
	case VT_BOOL:			return ADODB::adBoolean;
	case VT_NULL:
	case VT_EMPTY:			return ADODB::adTinyInt; // instead of ADODB::adEmpty because many ODBC-drivers do not accept this as column-type
	case VT_ARRAY | VT_UI1:	return ADODB::adBinary;
	case VT_BSTR:
	default:				return ADODB::adBSTR;
	}
}


long	VariantValueSize(const _variant_t& vValue)
{
	switch (vValue.vt)
	{
	case VT_DECIMAL:		return sizeof( DECIMAL );
	case VT_I1:				return sizeof( CHAR );
	case VT_I2:				return sizeof( SHORT );
	case VT_I4:				return sizeof( INT );
	case VT_I8:				return sizeof( LONG );
	case VT_UI1:			return sizeof( BYTE );
	case VT_UI2:			return sizeof( USHORT );
	case VT_UI4:			return sizeof( UINT );
	case VT_UI8:			return sizeof( ULONG );
	case VT_R4:				return sizeof( FLOAT );
	case VT_R8:				return sizeof( DOUBLE );
	case VT_DATE:			return sizeof( DATE );
	case VT_BOOL:			return sizeof( BOOL );
	case VT_NULL:
	case VT_EMPTY:			return 0;
	case VT_ARRAY | VT_UI1:	return (*(LPSAFEARRAY)vValue.parray).rgsabound\[ 0 \].cElements;
	case VT_BSTR:
	default:				return ( _tcslen( _bstr_t(vValue) ) <= 0 ) ? 1 : _tcslen( _bstr_t(vValue) ) ;
	}
}


VARTYPE ADOType2VariantType( const ADODB::DataTypeEnum& rADOType )
{
	switch ( rADOType )
	{
	case ADODB::adEmpty:			return VT_NULL;
    case ADODB::adTinyInt:			return VT_I1;
    case ADODB::adSmallInt:			return VT_I2;
    case ADODB::adInteger:			return VT_I4;
    case ADODB::adBigInt:			return VT_I8;
    case ADODB::adUnsignedTinyInt:	return VT_UI1;
    case ADODB::adUnsignedSmallInt:	return VT_UI2;
    case ADODB::adUnsignedInt:		return VT_UI4;
    case ADODB::adUnsignedBigInt:	return VT_UI8;
    case ADODB::adSingle:			return VT_R4;
    case ADODB::adDouble:			return VT_R8;
    case ADODB::adCurrency:			return VT_CY;
    case ADODB::adDecimal:			return VT_DECIMAL;
    case ADODB::adNumeric:			return VT_DECIMAL;
    case ADODB::adBoolean:			return VT_BOOL;
    case ADODB::adDate:				return VT_DATE;
    case ADODB::adDBDate:			return VT_DATE;
    case ADODB::adDBTime:			return VT_DATE;
    case ADODB::adDBTimeStamp:		return VT_DATE;
    case ADODB::adBinary:			return VT_ARRAY | VT_UI1;
    case ADODB::adVarBinary:		return VT_ARRAY | VT_UI1;
    case ADODB::adLongVarBinary:	return VT_ARRAY | VT_UI1;
    case ADODB::adFileTime:			return VT_DATE;
//    case ADODB::adDBFileTime:		return VT_DATE;
//	  case ADODB::adVarNumeric:		return VT_DECIMAL;

	default:
		return VT_BSTR;
	}
}

////////////////////////////////////////////////////////////////////////
//
//  CCommand
//
////////////////////////////////////////////////////////////////////////
CCommand::CCommand(tstring sStatement, bool bAutoReadFieldsIntoBuffer)
: m_sStatement( sStatement )
, m_bAutoReadFieldsIntoBuffer( bAutoReadFieldsIntoBuffer )
{
}


void CCommand::AddParameter( _variant_t vValue, bool bUseValueIndirect )
{
	TCHAR szParamNr\[12\];
	_sntprintf( szParamNr, 12, _T("P%d"), m_listParameters.size()+1 );
	m_listParameters.push_back( CFieldValue(szParamNr, vValue, bUseValueIndirect) );
}


void CCommand::SetAutoReadFieldsIntoBuffer( bool bAutoReadFieldsIntoBuffer )
{
	m_bAutoReadFieldsIntoBuffer = bAutoReadFieldsIntoBuffer;
}

////////////////////////////////////////////////////////////////////////
//
//  CCommandList
//
////////////////////////////////////////////////////////////////////////
CCommandList::CCommandList(CCommand command)
{
	if( !command.IsEmpty() )
		push_back(command);
}


////////////////////////////////////////////////////////////////////////
//
//  CDatabase
//
////////////////////////////////////////////////////////////////////////


CDatabase::CDatabase()
: m_spConnection(NULL)
, m_bRollbackTransaction( FALSE )
, m_nTransactionCounter( 0 )
{
}


CDatabase::CDatabase(const CDatabase& other)
: m_spConnection(other.m_spConnection)
, m_bRollbackTransaction( FALSE )
, m_nTransactionCounter( 0 )
{
}


CDatabase::CDatabase(const tstring& sConnectionString)
: m_bRollbackTransaction( FALSE )
, m_nTransactionCounter( 0 )
{
	try
	{
		m_spConnection.CreateInstance(__uuidof(ADODB::Connection));
		m_spConnection->Open(sConnectionString.c_str(), "", "", ADODB::adConnectUnspecified);
	}
	catch( _com_error& e )
	{
		throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Open, sConnectionString, (LPCTSTR)e.Description() );
	}
}


CDatabase::~CDatabase()
{
/*	if( (bool)m_spConnection )
	{
		try
		{
			m_spConnection->Close();
			m_spConnection.Release();
			m_spConnection = NULL;
		}
		catch ( _com_error& e ) 
		{
			throw CAltovaDBConnectionException( k_AltovaDBConnectionError_Close, sConnectionString, (LPCTSTR)e.Description() );
		}
	}
*/
}


void CDatabase::BeginTransaction( LPCTSTR szName )
{
	if( m_nTransactionCounter == 0 )
		InternalBeginTransaction();
	else
		InternalSetSavepoint( szName );

	m_nTransactionCounter++;
}


void CDatabase::CommitTransaction( LPCTSTR szName )
{
	if( m_nTransactionCounter < 1 )
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, szName, _T(" ERROR: No open transaction to commit!") );
	else if( m_nTransactionCounter == 1 )
		InternalCommitTransaction();
//	else
//		ignore commit of nested transaction - they are done when main-transaction is commited.
	m_nTransactionCounter--;
}


void CDatabase::RollbackTransaction( LPCTSTR szName )
{
	if( m_nTransactionCounter < 1 )
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, szName, _T(" ERROR: No open transaction to rollback!") );
	else if( m_nTransactionCounter == 1 )
		InternalRollbackTransaction();
	else
		InternalRollbackToSavepoint( szName );
	m_nTransactionCounter--;
}


////////////////////////////////////////////////////////////////////////
//
//  CRecordSet
//
////////////////////////////////////////////////////////////////////////


CRecordSet::CRecordSet()
: m_pDatabase( NULL )
, m_bRecordsetOwner( false )
, m_bRecordsetOpened( false )
, m_bReadAccess( true )
{
	m_itActRecordset = m_Recordsets.end();
}


CRecordSet::CRecordSet(const CRecordSet& other)
{
	Assign( other );
}


CRecordSet::CRecordSet(CDatabase& rDatabase, const CCommand& cmdQuery, const bool bReadAccess )
: m_pDatabase( &rDatabase )
, m_CommandList( cmdQuery )
, m_bRecordsetOwner( false )
, m_bRecordsetOpened( false )
, m_bReadAccess( bReadAccess )
{
	m_itActRecordset = m_Recordsets.end();
}


CRecordSet::~CRecordSet()
{
	CloseRecordsets();
}


CRecordSet&	CRecordSet::Assign( const CRecordSet& rOther )
{
	m_pDatabase = rOther.m_pDatabase;
	m_bReadAccess = rOther.m_bReadAccess;
	m_CommandList = rOther.m_CommandList;

	m_bRecordsetOpened = rOther.m_bRecordsetOpened;
	m_bRecordsetOwner = false;
	m_Recordsets = rOther.m_Recordsets;
	m_itActRecordset = rOther.m_itActRecordset;

	return *this;
}


void CRecordSet::SetCommand(CCommandList cmdSQLList)
{
	m_CommandList = cmdSQLList;
}


long CRecordSet::Execute(CCommandList cmdList)
{
	CloseRecordsets();

	m_CommandList = !cmdList.IsEmpty() ? cmdList : m_CommandList;
	CCommandListIt	itCmdBegin	= m_CommandList.begin();
	CCommandListIt	itCmdEnd	= m_CommandList.end();
	long	nRecordsAffected = 0;
	for( CCommandListIt itCmd = itCmdBegin; itCmd != itCmdEnd; ++itCmd )
	{
		CCommand	cmdSQL = *itCmd;

		// initialize local variables
		TFieldValueList&	listParameters = cmdSQL.GetParameters();
		TFieldValueListIt	itParam		= listParameters.begin();
		TFieldValueListIt	itParamEnd	= listParameters.end();
		bool bUseCommandObject = itParam != itParamEnd;
		_variant_t vRecordsAffected;
		VariantInit(&vRecordsAffected);
		ADODB::_CommandPtr	spCommand;

		// prepare command
		if( bUseCommandObject )
		{
			bool	bRefreshParametersOK = false;
			_variant_t	vNull;
			vNull.vt = VT_NULL;
			try
			{
				// create ADO command
				spCommand.CreateInstance(__uuidof(ADODB::Command));
				spCommand->ActiveConnection	= m_pDatabase->GetConnection();
				spCommand->Prepared			= VARIANT_TRUE;
				spCommand->CommandType		= ADODB::adCmdText;
				spCommand->CommandText = _bstr_t( cmdSQL.GetStatement().c_str() );

				// prepare ADO-parameters for ADO-command
				try
				{
					// try to read parameter info from database
					spCommand->Parameters->Refresh();
					bRefreshParametersOK = true;
				}
				catch( _com_error& )
				{
					// was not able to read parameter info from database --> add information manually
					for(long	nParamNr = 1 ; itParam != itParamEnd; ++itParam )
					{
						TCHAR szParamNr\[16\];
						_sntprintf(szParamNr, 16, _T("Param%d"), nParamNr++);
						_variant_t	vValue = (*itParam).m_vValue;
						if( (*itParam).m_bUseValueIndirect )
							vValue = GetValueByName( tstring(_bstr_t(vValue)) );
						if( vValue.vt == VT_DECIMAL )
							vValue = long( vValue );	// !!!!! possible loss of data

						ADODB::_ParameterPtr spParameter = spCommand->CreateParameter(_bstr_t(szParamNr), VariantType2ADOType(vValue), ADODB::adParamInput, VariantValueSize(vValue), vValue);
						spCommand->Parameters->Append(spParameter);
					}
				}
			}
			catch( _com_error& e )
			{
				throw CAltovaDBExecuteException( k_AltovaDBExecuteError_PrepareCommand, cmdSQL.GetStatement(), (LPCTSTR)e.Description() );
			}
			

			if( bRefreshParametersOK )
			{
				try
				{
					// copy values
					for(long	nParamNr = 0 ; itParam != itParamEnd; ++nParamNr )
					{
						ADODB::_ParameterPtr spParameter = spCommand->Parameters->GetItem(nParamNr);
						_variant_t	vValue = (*itParam).m_vValue;
						if( (*itParam).m_bUseValueIndirect )
							vValue = GetValueByName( tstring(_bstr_t(vValue)) );

						ADODB::DataTypeEnum	eParameterType = spParameter->Type;
						if ( ADOType2VariantType( eParameterType ) != vValue.vt )
						{
							// Here goes all specials for the different database-types which unfortunately can't be avoided.

							// Note: I kept this section restrictive, to make sure not to change the behaviour 
							// of things in different database
							switch ( eParameterType )
							{
							case ADODB::adVarChar:
								if ( vValue.vt == VT_DATE )
								{
									// MYSQL dateTime columns:
									//		db-api returns varChar as type for the parameter and in that case we have to fill in the correctly formatted string.
									TCHAR	s\[20\];
									SYSTEMTIME dt;
									VariantTimeToSystemTime( vValue, &dt );
									_stprintf( &s\[ 0 \], _T("%04d-%02d-%02d %02d:%02d:%02d"), dt.wYear, dt.wMonth, dt.wDay, dt.wHour, dt.wMinute, dt.wSecond );
									vValue = _variant_t( s ); 
								}
								break;
							}
							
						}

						spParameter->Value = ( vValue.vt == VT_EMPTY || vValue.vt == VT_NULL ) ? vNull : vValue;
						++itParam;
					}
				}
				catch( _com_error& e )
				{
					throw CAltovaDBExecuteException( k_AltovaDBExecuteError_PrepareParams, cmdSQL.GetStatement(), (LPCTSTR)e.Description() );
				}
			}
		}

		// execute ADO command and assign ADO recordset
		try
		{
			if( bUseCommandObject )
			{
				m_itActRecordset = m_Recordsets.insert( m_Recordsets.end(), spCommand->Execute(&vRecordsAffected, NULL, ADODB::adCmdText) );
				spCommand.Release();
			}
			else
				m_itActRecordset = m_Recordsets.insert( m_Recordsets.end(), m_pDatabase->GetConnection()->Execute( _bstr_t( cmdSQL.GetStatement().c_str() ), &vRecordsAffected, ADODB::adCmdText ) );
		}
		catch( _com_error& e )
		{
			bool	bErrorHandled = false;
			tstring sDescription = e.Description();

			// IBM/DB2: with this database-kind when UPDATE, DELETE or FETCH doesnot affect rows an error is thrown by the ODBC-driver
			// In reality the statement succeeds --> act as if it is so and ignore this specific error
			if( sDescription.find( _T("\[IBM\]") ) == 0  &&
				sDescription.find( _T("\[DB2") ) != tstring::npos  &&  
				sDescription.find( _T("SQL0100W") ) != tstring::npos
			)
				bErrorHandled = TRUE;

			// Node: Add additional internal error-handling mechanism here

			if( !bErrorHandled )
			{
				if( m_pDatabase )
					m_pDatabase->SetRollbackTransaction();
				tstring sMsg = _T("Runtime database error: ") + sDescription;
				throw CAltovaDBExecuteException( k_AltovaDBExecuteError_Execute, cmdSQL.GetStatement(), (LPCTSTR)e.Description() );

			}
		}

		// calculate affected rows as detailed as possible
		if( HasNext() )
			vRecordsAffected = (*m_itActRecordset)->RecordCount;
		else if( long(vRecordsAffected) == -1 )
			vRecordsAffected = long(0);	// when there is no resultset and the affected-rows value can't be retrieved (often when using SELECT), act as if no rows are affected
		if( long(vRecordsAffected) == -1  ||  nRecordsAffected == -1 )
			nRecordsAffected = -1;
		else
			nRecordsAffected += long(vRecordsAffected);

		// check if results of the recordsets have to be read into buffer
		if( cmdSQL.IsAutoReadFieldsIntoBuffer() )
		{
			long nTmpRecordsAffected = nRecordsAffected;
			do
			{
				if( nTmpRecordsAffected != 0 )
					ReadFieldsIntoBuffer();
			}
			while( NextRecordset(nTmpRecordsAffected) );
		}
	}

	m_bRecordsetOwner = true;
	m_bRecordsetOpened = true;
	m_itActRecordset = m_Recordsets.begin();
	return nRecordsAffected;
}


bool CRecordSet::HasNext()
{
	if( (m_Recordsets.begin() == m_Recordsets.end())  ||  ( m_itActRecordset == m_Recordsets.end() ) )
		return false;	// no recordset available
	try
	{
		return (*m_itActRecordset)->EndOfFile == VARIANT_FALSE;	
	}
	catch( _com_error& )
	{
		return false;
	}
	catch( ... )
	{
		return false;
	}
}


void CRecordSet::MoveNext()
{
	try
	{
		(*m_itActRecordset)->MoveNext();
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_ReadNextResult, _T(""), (LPCTSTR)e.Description() );
	}
}


bool CRecordSet::NextRecordset(long& nRecordsAffected)
{
	nRecordsAffected = 0;
	if( (m_Recordsets.begin() == m_Recordsets.end())  ||  ( m_itActRecordset == m_Recordsets.end() ) )
		return false;	// no recordset available
	try
	{
		_variant_t	vRecordsAffected;
		(*m_itActRecordset) = (*m_itActRecordset)->NextRecordset(&vRecordsAffected);
		nRecordsAffected = long(vRecordsAffected);
		return true;
	}
	catch( _com_error& )
	{	
		++m_itActRecordset;
		return NextRecordset(nRecordsAffected);
	}
	catch( ... )
	{
		nRecordsAffected = -1;
		return false;
	}
}



void CRecordSet::CloseRecordsets()
{
	if( m_bRecordsetOpened )
	{
		if( m_bRecordsetOwner )
		{
			try
			{
				TADORecordSetPtrListIt	it = m_Recordsets.begin();
				TADORecordSetPtrListIt	itEnd = m_Recordsets.end();
				for( ; it != itEnd; ++it )
					(*it)->Close();
			}
			catch ( _com_error& ) {}	// just skip cleanup
			catch ( ... )	{}
		}
		m_Recordsets.empty();
		m_bRecordsetOpened = false;
		m_itActRecordset = m_Recordsets.end();
	}
}


void CRecordSet::ReadFieldsIntoBuffer()
{
	if( !HasNext() )
		return;

	try
	{
		for( long l = 0; l < (*m_itActRecordset)->Fields->GetCount(); l++ )
			SetValueByName( tstring( (*m_itActRecordset)->Fields->GetItem(l)->Name ), (*m_itActRecordset)->Fields->GetItem(l)->Value );
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_GetColumn, _T(""), (LPCTSTR)e.Description() );
	}	
}


_variant_t CRecordSet::InternalGetValue(const tstring& sName, const bool bReadFromBuffer)
{
	if( bReadFromBuffer || !m_bReadAccess )
		return GetValueByName( sName );

	try
	{
		return (*m_itActRecordset)->Fields->GetItem(_bstr_t(sName.c_str()))->Value;
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_GetColumn, sName, (LPCTSTR)e.Description() );
	}
}


void CRecordSet::InternalSetValue(const tstring& sName, const _variant_t& vValue )
{
	try
	{
		(*m_itActRecordset)->Fields->GetItem(_bstr_t(sName.c_str()))->Value = vValue;
	}
	catch( _com_error& e )
	{
		throw CAltovaDBExecuteException( k_AltovaDBExecuteError_SetColumn, sName, (LPCTSTR)e.Description() );
	}	
}


} // namespace altova
