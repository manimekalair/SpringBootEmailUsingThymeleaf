////////////////////////////////////////////////////////////////////////
//
// [=$module]Functions.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$module]Functions.h"

#include "../AltovaText/Command.h"
#include "../AltovaText/Condition.h"
using namespace altova;


namespace [=$module]
{

////////////////////////////////////////////////////////////////////////
//	Handlers
////////////////////////////////////////////////////////////////////////

[foreach $handler in $library.Handlers
]CHandler[=$handler.Name]::CHandler[=$handler.Name]()
:	CFunction()
{
[	' iterate the function commands
	foreach $command in $handler.Commands
		' create the command class name
		$CommandClassName = "CCommand" & $command.CommandName
		'
		' check if there are attached conditions
		if $command.HasConditions
]	{
[		' create the command instance 
]		[=$CommandClassName]* pCommand = new [=$CommandClassName]([if $command.HasParameter] _T("[=$command.Parameter]") [endif][if $command.CommandName = "Enter"], [=$command.ClassName][endif]);
[		'
		' set the condition's operation (default is 'or')
		if $command.Operation = 1
]		pCommand->GetContitions().SetOperator( CConditions::k_AND );
[		endif 'command.Operation
		'
		' iterate the conditions
		foreach $condition in $command.Conditions
			' create the condition class name
			$ConditionClassName = "CCondition" & $condition.ConditionName
			' append the condition to the commands condition list
]		pCommand->AddCondition( new [=$ConditionClassName]([if $condition.HasParameter] _T("[=$condition.Parameter]")[endif][if $condition.Negate], true[endif] ) );
[		next 'condition
		' when the condition fails the following commands are executed
		if $command.HasOtherwise
			' iterate the otherwise commad container
			foreach $otherwise in $command.Otherwise
				' create the command class name
				$OtherwiseClassName = "CCommand" & $otherwise.CommandName
				' append the new command command to the otherwise command list of the current command 
				' restriction: currently the otherwise commands cannot have conditions
]		pCommand->AddOtherwise( new [=$OtherwiseClassName]([if $otherwise.HasParameter] _T("[=$otherwise.Parameter]") [endif][if $otherwise.CommandName = "Enter"], [=$otherwise.ClassName][endif]) );
[			next 'otherwise
		endif 'command.HasOtherwise
		' append the newly created command
]		AddCommand( pCommand );
	}
[	else 'command.HasConditions
]	AddCommand( new [=$CommandClassName]([if $command.HasParameter] _T("[=$command.Parameter]") [endif][if $command.CommandName = "Enter"], [=$command.ClassName][endif]) );
[	endif
][	next 'command
]}

[next' handler
]


////////////////////////////////////////////////////////////////////////
//	Functions
////////////////////////////////////////////////////////////////////////

[foreach $function in $library.Functions
]CFunction[=$function.Name]::CFunction[=$function.Name]()
:	CFunction()
{
[	' iterate the function commands
	foreach $command in $function.Commands
		' create the command class name
		$CommandClassName = "CCommand" & $command.CommandName
		' --- HasConditions ---
		' check if there are attached conditions
		if $command.HasConditions
]	{
[		' create the command instance
]		[=$CommandClassName]* pCommand = new [=$CommandClassName]([if $command.HasParameter] _T("[=$command.Parameter]") [endif][if $command.CommandName = "Enter"], [=$command.ClassName][endif]);
[		if $command.Operation = 1
]		pCommand->GetContitions().SetOperator( CConditions::k_AND );
[		endif
		'
		' iterate the attached conditions
		foreach $condition in $command.Conditions
			' create the condition class name
			$ConditionClassName = "CCondition" & $condition.ConditionName
]		pCommand->AddCondition( new [=$ConditionClassName]([if $condition.HasParameter] _T("[=$condition.Parameter]") [endif][if $condition.Negate], true[endif]) );
[		next' condition
		' --- Otherwise ---
		' when the condition fails the 
		' following commands are executed
		if $command.HasOtherwise
			' iterate the otherwise commad container
			foreach $otherwise in $command.Otherwise
				' create the command class name
				$OtherwiseClassName = "CCommand" & $otherwise.CommandName
]		pCommand->AddOtherwise( new [=$OtherwiseClassName]([if $otherwise.HasParameter] _T("[=$otherwise.Parameter]") [endif][if $otherwise.CommandName = "Enter"], [=$otherwise.ClassName][endif]) );
[			next ' otherwise
		endif ' command.HasOtherwise
		' append the newly created command
]		AddCommand( pCommand );
	}
[		else ' command.HasConditions
	' create the command instance and append it to the functions command list
]	AddCommand( new [=$CommandClassName]([if $command.HasParameter] _T("[=$command.Parameter]") [endif][if $command.CommandName = "Enter"], [=$command.ClassName][endif]) );
[		endif ' command.HasConditions
	next ' command
]}

[next' function
]

}// namespace [=$module]

