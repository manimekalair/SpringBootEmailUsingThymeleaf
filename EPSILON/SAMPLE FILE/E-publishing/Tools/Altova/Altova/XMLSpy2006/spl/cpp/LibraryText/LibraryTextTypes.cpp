////////////////////////////////////////////////////////////////////////
//
// [=$module]Types.cpp
//
// This file was generated by [=$Host].
//
// YOU SHOULD NOT MODIFY THIS FILE, BECAUSE IT WILL BE
// OVERWRITTEN WHEN YOU RE-RUN CODE GENERATION.
//
// Refer to the [=$HostShort] Documentation for further details.
// [=$HostURL]
//
////////////////////////////////////////////////////////////////////////


#include "StdAfx.h"
#include "[=$module]Types.h"

using namespace [=$module];

[if $library.IsTable]
using namespace altova::text::tablelike;
[endif]

////////////////////////////////////////////////////////////////////////
//	Types
////////////////////////////////////////////////////////////////////////

[foreach $node in $library.Nodes]

[if $library.IsTree]
C[=$node.Name]Type::C[=$node.Name]Type()
:	CBaseType(CTextNodeFactory::GetInstance().Create(CNullTextNode::GetInstance(), _T("[=$node.Name]"), _T("[=$node.NativeName]")))
{
[call GenerateCppNodePropertySetter($node)]
}
C[=$node.Name]Type::C[=$node.Name]Type(CTextNode& rNode)
:	CBaseType( &rNode )
[if $node.HasValueType],	[=$node.ValueType]( [if $node.ValueType = "CSchemaDecimal"]CBaseType::MakeDecimal().c_str()[else]rNode.GetValue().c_str()[endif] )
[endif]
{
	GetNode().SetName(_T("[=$node.Name]"));
[call GenerateCppNodePropertySetter($node)]
}

C[=$node.Name]Type::~C[=$node.Name]Type()
{
}

[if $node.HasValueType]
C[=$node.Name]Type::C[=$node.Name]Type([=$node.ValueType] rhs)
:	CBaseType(CTextNodeFactory::GetInstance().Create(CNullTextNode::GetInstance(), _T("[=$node.Name]"), _T("[=$node.NativeName]")))
{
	GetNode().SetValue(rhs);
[call GenerateCppNodePropertySetter($node)]
}
[endif ' HasValueType

foreach $child in $node.Children
$bFound= 0
call NodeContainedInLibraryNodes($child, $bFound)
if $bFound = 1]
bool C[=$node.Name]Type::Has[=$child.Name]() const
{
	return Get[=$child.Name]Count() > 0;
}
int C[=$node.Name]Type::Get[=$child.Name]Count() const
{
	[if $child.NameIndex = -1]
	return GetChildCount(_T("[=$child.UserFriendlyName]"));
	[else]
	if ([=$child.NameIndex]>GetChildCount(_T("[=$child.NativeName]"))) return 0;
	else return 1;
	[endif]
}
C[=$child.Name]Type C[=$node.Name]Type::Get[=$child.Name]() const
{
	[if $child.NameIndex = -1]
	return C[=$child.Name]Type(*GetChildByName(_T("[=$child.UserFriendlyName]")));
	[else
	 $lNameIndex = $child.NameIndex - 1
	]
	return C[=$child.Name]Type(*GetChildByNameAt(_T("[=$child.NativeName]"), [=$lNameIndex]));
	[endif]
}
C[=$child.Name]Type C[=$node.Name]Type::Get[=$child.Name]At(int index) const
{
	[if $child.NameIndex = -1]
	return C[=$child.Name]Type(*GetChildByNameAt(_T("[=$child.UserFriendlyName]"), index));
	[else]
	return Get[=$child.Name]();
	[endif]
}
[if $child.HasValueType]
void C[=$node.Name]Type::Add[=$child.Name]([=$child.ValueType] rhs)
{
	C[=$child.Name]Type [=$child.Name](rhs);
	GetNode().GetChildren().Add(&[=$child.Name].GetNode());
}
[else]
void C[=$node.Name]Type::Add[=$child.Name](C[=$child.Name]Type& rhs)
{
	GetNode().GetChildren().Add(&rhs.GetNode());
}
[endif
endif 'bFound = 1
next ' child

if $library.ParseMode = 0 ' EDI
]
CTextNode* C[=$node.Name]Type::CreateStructureNode(CTextNode& parent)
{
	CTextNode* result= CTextNodeFactory::GetInstance().Create(parent, _T("[=$node.Name]"), _T("[=$node.NativeName]"));
[
foreach $child in $node.Children
	$bFound = 0
	call NodeContainedInLibraryNodes($child, $bFound)
	if $bFound = 1]
	CTextNode* kid[=$child.Name]=C[=$child.Name]Type::CreateStructureNode(*result);
	kid[=$child.Name]->SetPrecedingSeparators(_T("[=$child.PrecedingSeparators]"));
	kid[=$child.Name]->SetFollowingSeparators(_T("[=$child.FollowingSeparators]"));
	kid[=$child.Name]->SetPositionInFather([=$child.PositionInFather]);
[	
	endif '$bFound
next 'child
]
	return result;
}
[
endif ' EDI

else  ' IsTable

if $node.HasValueType]
C[=$node.Name]Type::C[=$node.Name]Type(const [=$node.ValueType]& rhs)
:	[=$node.ValueType](rhs)
{}
[else ' HasValueType
]
[$kids= $node.Children]
C[=$node.Name]Type::C[=$node.Name]Type()
:	CRecord([=$kids.Length])
{}
C[=$node.Name]Type::C[=$node.Name]Type(const CRecord& rhs)
:	CRecord(rhs)
{}
C[=$node.Name]Type& C[=$node.Name]Type::operator= (const C[=$node.Name]Type& rhs)
{
	CRecord::Assign(rhs);
	return *this;
}
[foreach $child in $kids]
bool C[=$node.Name]Type::Has[=$child.Name]() const
{
	return ! CRecord::GetFieldAt([=$child.Index]).empty();
}
int C[=$node.Name]Type::Get[=$child.Name]Count() const
{
	return (Has[=$child.Name]()) ? 1 : 0;
}
void C[=$node.Name]Type::Add[=$child.Name](const C[=$child.Name]Type& rhs)
{
	CRecord::SetFieldAt([=$child.Index], rhs);
}

C[=$child.Name]Type C[=$node.Name]Type::Get[=$child.Name]()
{
	return C[=$child.Name]Type((CSchemaString) CRecord::GetFieldAt([=$child.Index]));
}

C[=$child.Name]Type C[=$node.Name]Type::Get[=$child.Name]At(int)
{
	return this->Get[=$child.Name]();
}
[next 'child
endif ' HasValueType
endif ' IsTree/IsTable
]
////////////////////////////////////////////////////////////////////////
[next ' node]
